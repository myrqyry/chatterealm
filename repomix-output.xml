This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
packages/
  backend/
    scripts/
      join-and-move.js
      listen-deltas.js
      validate-fixes.js
    src/
      __tests__/
        authentication.test.ts
        gameLoop.test.ts
        server.test.ts
      config/
        env.ts
      handlers/
        CharacterHandler.ts
      models/
        GameRoom.ts
        Player.ts
      services/
        __tests__/
          gameStateManager.test.ts
          LootService.test.ts
          PlayerMovementService.test.ts
          PlayerService.test.ts
          StreamOptimizedTwitchService.test.ts
          WebSocketServer.integration.test.ts
          webSocketServer.race.test.ts
        aiProxyService.ts
        AutoWanderService.ts
        CataclysmService.ts
        CombatService.ts
        contentModerationService.ts
        EmojiService.ts
        GameService.ts
        gameStateManager.old.ts
        gameStateManager.test.ts
        gameStateManager.ts
        GameWorldManager.ts
        geminiClient.ts
        HandDrawnBuildingService.ts
        LootManager.ts
        LootService.ts
        NPCManager.ts
        PlayerMovementService.ts
        PlayerService.ts
        RateLimiter.ts
        StreamCommentaryService.ts
        StreamOptimizedTwitchService.ts
        twitchService.ts
        webSocketServer.test.ts
        webSocketServer.ts
      testUtils/
        mockGameWorld.ts
      index.ts
    jest.config.js
    nodemon.json
    package.json
    tsconfig.json
  extensions/
    twitch-panel/
      src/
        components/
          AutoWanderControls.tsx
          CombatStyleSelector.tsx
          LootPreferences.tsx
          PlayerStatusCard.tsx
        main.tsx
        PanelApp.tsx
        types.ts
      index.html
      package.json
      tsconfig.json
      tsconfig.node.json
      vite.config.ts
  frontend/
    public/
      vite.svg
    src/
      ai/
        AITypes.ts
        EntityManager.ts
        GameEntity.ts
        index.ts
        MessageDispatcher.ts
        Telegram.ts
        Time.ts
      components/
        animations/
          CanvasDrawEffect.tsx
          DrawSVGEffect.tsx
          index.ts
          RoughAnimatedShape.tsx
          RoughNotation.tsx
          ScrollAnimatedElement.tsx
        character/
          CharacterBuilder.test.tsx
          CharacterCreator.tsx
          CharacterStats.tsx
          ClassCard.tsx
          ClassEffects.tsx
          EmojiPicker.tsx
          SVGAvatarUpload.tsx
        chat/
          ChatInterface.tsx
          ChatWindow.tsx
          MessageInput.tsx
          MessageList.tsx
          SmartSuggestions.tsx
        dev/
          BiomeDebugTools.tsx
          EmojiSvgSmokeTest.tsx
        GameCanvas/
          hooks/
            useCanvasSetup.ts
            useContainerResize.ts
          managers/
            EffectManager.ts
            ParticleManager.ts
            RegenerationManager.ts
          GameCanvas.tsx
          index.ts
        layout/
          AppHeader.tsx
          BaseLayout.tsx
          BottomSettingsBar.tsx
          GameLayout.tsx
          GameLegend.tsx
          index.ts
          MaterialAppBar.tsx
          ModeNavigation.tsx
          PanelSystem.tsx
          ResponsiveLayout.tsx
          RightSidebar.tsx
        layouts/
          DevLayout.tsx
          DevRouteWrapper.tsx
          PlayLayout.tsx
          SpectateLayout.tsx
        notifications/
          NotificationContainer.tsx
          NotificationItem.tsx
          NotificationSystem.tsx
        panels/
          ChatPanel.tsx
          FriendsPanel.tsx
        player/
          PlayerProfile/
            index.ts
            PlayerProfile.test.tsx
            PlayerProfile.tsx
            PlayerProfileWrapper.tsx
          EnhancedPlayerStatus.tsx
          ExperienceBar.tsx
          HealthBar.tsx
          PlayerStatus.tsx
          StatusDetails.tsx
          StatusEffects.tsx
        renderers/
          canvas/
            CanvasUtils.ts
            GridRenderer.ts
            RenderCoordinator.ts
            tmp.txt
          effects/
            AnimationUtils.ts
            EffectRenderer.ts
            ParticleSystem.ts
          entities/
            BuildingRenderer.ts
            ItemRenderer.ts
            NPCRenderer.ts
            PlayerRenderer.ts
          terrain/
            BiomeRenderer.ts
            ForestRenderer.ts
            MountainRenderer.ts
            OceanRenderer.ts
            TerrainRenderer.ts
          BiomeRenderer.ts
        settings/
          ActionsModal.tsx
          AudioModal.tsx
          GameplayModal.tsx
          OverviewModal.tsx
          UnifiedSettingsMenu.tsx
          UnifiedSettingsMenuModal.tsx
          VisualModal.tsx
          WorldModal.tsx
        shared/
          settings/
            index.ts
            MaterialCheckbox.tsx
            MaterialDropdown.tsx
            MaterialGroup.tsx
            MaterialMultiSelect.tsx
            MaterialSlider.tsx
            SettingCheckbox.tsx
            SettingDropdown.tsx
            SettingGroup.tsx
            SettingSlider.tsx
          CategoryButton.tsx
          Panel.tsx
        sidebar/
          panels/
            ActionsPanel.tsx
            AudioSettings.tsx
            GameplaySettings.tsx
            OverviewPanel.tsx
            PlayerSummaryPanel.tsx
            VisualSettings.tsx
            WorldSettings.tsx
          CategoryNavigation.tsx
          DevSidebar.tsx
          index.ts
          PlayerSidebar.tsx
          PlayerStatusPanel.tsx
          Sidebar.tsx
          SpectatorSidebar.tsx
        ui/
          MaterialButton.tsx
          MaterialCard.tsx
          MaterialChip.tsx
          MaterialDialog.tsx
          MaterialDrawer.tsx
          MaterialIcon.tsx
          MaterialPaper.tsx
          MaterialPopover.tsx
          MaterialTooltip.tsx
        AnimationDemo.tsx
        CataclysmDemo.tsx
        CataclysmVisualizer.tsx
        CharacterBuilder.tsx
        DrawingEffectsDemo.tsx
        EmojiPicker.tsx
        ErrorBoundary.tsx
        index.ts
        SVGAssetDemo.tsx
      constants/
        colors.ts
      hooks/
        useCharacterClasses.ts
        useChat.ts
        useGameWorld.ts
        useNotifications.ts
        usePlayerStatus.ts
        useResponsive.ts
        useSound.ts
        useTheme.ts
      services/
        __tests__/
          BiomeTextureService.test.ts
          BiomeTransitionService.test.ts
          BoundaryTracer.test.ts
          CorruptionOverlayService.test.ts
          UnifiedRoughFillService.test.ts
        chat/
          ChatService.ts
          CommandProcessor.ts
          MessageHandler.ts
          ModerationService.ts
        notification/
          NotificationFactory.ts
          NotificationManager.ts
          NotificationQueue.ts
        player/
          EffectManager.ts
          HealthManager.ts
          StatusCalculator.ts
        worldGeneration/
          BiomeGenerator.ts
          BuildingGenerator.ts
          LootSpawnSystem.ts
          NoiseGenerator.ts
          TerrainGenerator.ts
          WorldGenerator.ts
          WorldTypes.ts
        assetConverter.ts
        BiomeIdentificationService.ts
        BiomeTextureService.ts
        BiomeTransitionService.ts
        commandParser.ts
        CorruptionOverlayService.ts
        EmojiCharacterService.ts
        gsap.ts
        LayoutManagerService.ts
        soundService.ts
        UnifiedRoughFillService.ts
        webSocketClient.ts
      srcs/
        ai/
          AITypes.ts
      stores/
        gameStore.ts
        layoutStore.ts
      test/
        setup.ts
      types/
        chat.ts
        notification.ts
        playerStatus.ts
      utils/
        chat/
          ChatUtils.ts
          MessageUtils.ts
        materialTheme/
          index.ts
          materialTheme.ts
        notification/
          NotificationAnimations.ts
          NotificationStyles.ts
          NotificationUtils.ts
        player/
          EffectUtils.ts
          StatusUtils.ts
        boundaryTracing.test.ts
        boundaryTracing.ts
        classVisuals.ts
        designSystem.ts
        loggingUtils.ts
        RenderingProfiler.ts
        tokens.ts
        ViewportCulling.ts
      App.tsx
      basic.test.ts
      index.css
      main.tsx
      mockData.ts
    ANIMATION_LIBRARIES.md
    index.html
    package.json
    postcss.config.js
    styling-consistency-strategy.md
    tailwind.config.js
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
    vitest.config.ts
  shared/
    src/
      constants/
        biomeConfigs.ts
        colorConstants.ts
        gameConstants.ts
        index.ts
      types/
        biomes.ts
        characterClasses.ts
        commands.ts
        game.ts
        moderation.ts
        network.ts
        ui.ts
      index.ts
    package.json
    tsconfig.json
.gitignore
AGENTS.md
API_REFERENCE.md
BIOME_RENDERING.md
CONTRIBUTING.md
DEPLOYMENT.md
IMPLEMENTATION_SUMMARY.md
package.json
PERFORMANCE_TUNING.md
pnpm-workspace.yaml
README.md
ROUGH_FILL_GUIDE.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/backend/scripts/join-and-move.js">
// Small test client to join the game and issue a move command.
// Usage from repo root:
// SERVER=http://localhost:3001 node packages/backend/scripts/join-and-move.js
// or to force an alternate port: SERVER=http://localhost:3002 node packages/backend/scripts/join-and-move.js

const SERVER = process.env.SERVER || 'http://localhost:3001';
console.log('[TEST_CLIENT] Connecting to', SERVER);

let socket;
try {
  const { io } = require('socket.io-client');
  socket = io(SERVER, {
    transports: ['polling', 'websocket'],
    reconnectionAttempts: 3,
    timeout: 5000
  });
} catch (err) {
  console.error('[TEST_CLIENT] Failed to require socket.io-client:', err.message || err);
  process.exit(2);
}

let joinedId = null;
let gotDelta = false;

socket.on('connect', () => {
  console.log('[TEST_CLIENT] connected, socket id=', socket.id, 'transport=', socket.io.engine.transport.name);
  const payload = { id: `test_player_${Date.now()}`, displayName: 'TestPlayer', class: 'knight', avatar: 'ðŸ™‚' };
  console.log('[TEST_CLIENT] emitting join_game with', payload);
  socket.emit('join_game', payload);
});

socket.on('connect_error', (err) => {
  console.error('[TEST_CLIENT] connect_error', err && err.message ? err.message : err);
});

socket.on('game_joined', (data) => {
  console.log('[TEST_CLIENT] game_joined received for id=', data.player?.id, 'pos=', data.player?.position);
  joinedId = data.player?.id;
  setTimeout(() => {
    console.log('[TEST_CLIENT] sending player_command move down for', joinedId);
    socket.emit('player_command', { type: 'move', playerId: joinedId, data: { direction: 'down' } });
  }, 300);
});

socket.on('command_result', (r) => {
  console.log('[TEST_CLIENT] command_result', JSON.stringify(r));
});

socket.on('game_state_delta', (deltas) => {
  gotDelta = true;
  console.log('[TEST_CLIENT] game_state_delta:', JSON.stringify(deltas, null, 2));
  // exit after a short delay
  setTimeout(() => process.exit(0), 200);
});

socket.on('disconnect', (reason) => {
  console.log('[TEST_CLIENT] disconnected:', reason);
});

// Timeout
setTimeout(() => {
  if (!gotDelta) {
    console.log('[TEST_CLIENT] No deltas received within timeout, exiting.');
    try { socket.disconnect(); } catch (e) {}
    process.exit(1);
  }
}, 9000);
</file>

<file path="packages/backend/scripts/listen-deltas.js">
const { io } = require('socket.io-client');

const SERVER = process.env.SERVER_URL || process.env.SERVER || 'http://localhost:3001';
console.log('Connecting to', SERVER);

let got = false;

// Try websocket first, then fallback to polling if websocket fails
let attemptedPolling = false;
let socket = io(SERVER, { transports: ['websocket'], reconnectionAttempts: 2, timeout: 4000 });

const attachHandlers = (s) => {
  s.on('connect', () => {
    console.log('Connected to server, id=', s.id, 'transport=', s.io.engine.transport.name);
  });

  s.on('connect_error', (err) => {
    console.error('connect_error', err.message || err);
    // If websocket failed and we haven't tried polling, try polling transport
    if (!attemptedPolling && err && (!err.message || err.message.toLowerCase().includes('websocket'))) {
      attemptedPolling = true;
      console.log('Attempting fallback to polling transport...');
      try {
        s.close();
      } catch (e) {}
      socket = io(SERVER, { transports: ['polling'], reconnectionAttempts: 2, timeout: 4000 });
      attachHandlers(socket);
    }
  });

  s.on('disconnect', (reason) => {
    console.log('Disconnected:', reason);
  });

  s.on('game_state_delta', (deltas) => {
    got = true;
    try {
      console.log('Received game_state_delta:', JSON.stringify(deltas, null, 2).slice(0, 2000));
    } catch (e) {
      console.log('Received game_state_delta (non-serializable)');
    }
  });
};

attachHandlers(socket);

// If no deltas in 8s, exit
setTimeout(() => {
  if (!got) {
    console.log('No deltas received in 8s, exiting.');
  } else {
    console.log('Received deltas, exiting.');
  }
  try { socket.disconnect(); } catch (e) {}
  process.exit(0);
}, 8000);
</file>

<file path="packages/backend/src/services/AutoWanderService.ts">
import { GameStateManager } from './gameStateManager';
import { Player, Position, WanderSettings, DangerLevel, DangerAssessment } from 'shared/src/types/game';

export class AutoWanderService {
  private wanderingPlayers: Map<string, WanderSettings> = new Map();
  private dangerZones: Map<string, DangerLevel> = new Map();

  private gameStateManager: GameStateManager;

  constructor(gameStateManager: GameStateManager) {
    this.gameStateManager = gameStateManager;
  }

  public update(): void {
    if (!this.gameStateManager) return;
    this.processAutoWander();
  }

  public startAutoWander(playerId: string, settings: WanderSettings): void {
    this.wanderingPlayers.set(playerId, settings);
  }

  public stopAutoWander(playerId: string): void {
    if (this.wanderingPlayers.has(playerId)) {
      this.wanderingPlayers.delete(playerId);
    }
  }

  private processAutoWander(): void {
    for (const [playerId, settings] of this.wanderingPlayers.entries()) {
      const player = this.gameStateManager.getGameWorld().players.find(p => p.id === playerId);
      if (!player || !player.isAlive) {
        this.stopAutoWander(playerId);
        continue;
      }

      const nextPosition = this.calculateSafeMove(player, settings);
      if (!nextPosition) continue;

      const danger = this.assessDanger(nextPosition, player.level);

      if (danger.level > settings.maxRiskLevel) {

        if (settings.stopOnDanger) {
          this.stopAutoWander(playerId);
          continue;
        }
      }

      const moveResult = this.gameStateManager.movePlayer(playerId, nextPosition);
      if (moveResult.success) {
      }
    }
  }

  private calculateSafeMove(player: Player, settings: WanderSettings): Position | null {
    const validMoves: Position[] = [];
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
            if (dx === 0 && dy === 0) continue;
            const newPos = { x: player.position.x + dx, y: player.position.y + dy };
            if (this.gameStateManager.isPositionValid(newPos)) {
                validMoves.push(newPos);
            }
        }
    }
    if (validMoves.length === 0) return null;
    return validMoves[Math.floor(Math.random() * validMoves.length)];
  }

  private assessDanger(position: Position, playerLevel: number): DangerAssessment {
    const nearbyEnemies = this.gameStateManager.getGameWorld().npcs.filter(npc =>
        Math.abs(npc.position.x - position.x) <= 3 &&
        Math.abs(npc.position.y - position.y) <= 3 &&
        npc.isAlive
    );

    let dangerLevel = 0;
    const threats: string[] = [];

    for (const enemy of nearbyEnemies) {
        dangerLevel += enemy.stats.attack + (enemy.stats.maxHp / 10);
        threats.push(enemy.type);
    }

    return { level: dangerLevel, threats };
  }


  private getPlayerDisplayName(playerId: string): string {
    const player = this.gameStateManager.getGameWorld().players.find(p => p.id === playerId);
    return player ? player.displayName : 'A wanderer';
  }
}
</file>

<file path="packages/backend/nodemon.json">
{
  "watch": ["src"],
  "ignore": ["node_modules/*", "dist/*"],
  "ext": "ts,json",
  "exec": "ts-node src/index.ts",
  "legacyWatch": true
}
</file>

<file path="packages/extensions/twitch-panel/src/components/AutoWanderControls.tsx">
import React from 'react';

interface AutoWanderControlsProps {
    enabled: boolean;
    onToggle: () => void;
}

const AutoWanderControls: React.FC<AutoWanderControlsProps> = ({ enabled, onToggle }) => {
    return (
        <div>
            <label>
                Auto-Wander:
                <input type="checkbox" checked={enabled} onChange={onToggle} />
            </label>
        </div>
    );
};

export default AutoWanderControls;
</file>

<file path="packages/extensions/twitch-panel/src/components/CombatStyleSelector.tsx">
import React from 'react';

type CombatStyle = 'aggressive' | 'defensive' | 'balanced';

interface CombatStyleSelectorProps {
    style: CombatStyle;
    onChange: (style: CombatStyle) => void;
}

const CombatStyleSelector: React.FC<CombatStyleSelectorProps> = ({ style, onChange }) => {
    return (
        <div>
            <h3>Combat Style</h3>
            <select value={style} onChange={(e) => onChange(e.target.value as CombatStyle)}>
                <option value="aggressive">Aggressive</option>
                <option value="defensive">Defensive</option>
                <option value="balanced">Balanced</option>
            </select>
        </div>
    );
};

export default CombatStyleSelector;
</file>

<file path="packages/extensions/twitch-panel/src/components/LootPreferences.tsx">
import React from 'react';

interface LootPreferencesProps {
    preferences: string[];
    onChange: (preferences: string[]) => void;
}

const LootPreferences: React.FC<LootPreferencesProps> = ({ preferences, onChange }) => {
    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const { value, checked } = event.target;
        const newPreferences = checked
            ? [...preferences, value]
            : preferences.filter(pref => pref !== value);
        onChange(newPreferences);
    };

    return (
        <div>
            <h3>Loot Preferences</h3>
            <label>
                <input type="checkbox" value="weapon" checked={preferences.includes('weapon')} onChange={handleChange} />
                Weapons
            </label>
            <label>
                <input type="checkbox" value="armor" checked={preferences.includes('armor')} onChange={handleChange} />
                Armor
            </label>
            <label>
                <input type="checkbox" value="consumable" checked={preferences.includes('consumable')} onChange={handleChange} />
                Consumables
            </label>
        </div>
    );
};

export default LootPreferences;
</file>

<file path="packages/extensions/twitch-panel/src/components/PlayerStatusCard.tsx">
import React from 'react';
import { Player } from '../types';

interface PlayerStatusCardProps {
    player: Player | null;
}

const PlayerStatusCard: React.FC<PlayerStatusCardProps> = ({ player }) => {
    if (!player) {
        return <div>Loading player data...</div>;
    }

    return (
        <div>
            <h2>{player.displayName}</h2>
            <p>Level: {player.level}</p>
            <p>Health: {player.health} / {player.maxHealth}</p>
        </div>
    );
};

export default PlayerStatusCard;
</file>

<file path="packages/extensions/twitch-panel/src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import PanelApp from './PanelApp.tsx'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <PanelApp />
  </React.StrictMode>,
)
</file>

<file path="packages/extensions/twitch-panel/src/PanelApp.tsx">
import React, { useState } from 'react';
import { PanelState } from './types';
import PlayerStatusCard from './components/PlayerStatusCard';
import AutoWanderControls from './components/AutoWanderControls';
import LootPreferences from './components/LootPreferences';
import CombatStyleSelector from './components/CombatStyleSelector';

const PanelApp: React.FC = () => {
  const [panelState, setPanelState] = useState<PanelState>({
    player: {
        id: '1',
        displayName: 'Stream_Viewer',
        level: 1,
        health: 100,
        maxHealth: 100
    },
    autoWander: false,
    preferredLootTypes: [],
    combatStyle: 'balanced',
    notifications: { deaths: true, levelUps: true, rareItems: true }
  });

  const handleAutoWanderToggle = async () => {
    const newState = !panelState.autoWander;
    setPanelState(prev => ({ ...prev, autoWander: newState }));

    // In a real implementation, this would send a request to the backend
    console.log('Toggled auto-wander to:', newState);
    // await fetch('/api/player/settings', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify({
    //     username: getUsername(), // This would need to be implemented
    //     autoWander: newState,
    //     wanderSettings: {
    //       maxDistance: 5,
    //       avoidHighLevelAreas: true,
    //       prioritizeLoot: panelState.preferredLootTypes
    //     }
    //   })
    // });
  };

  return (
    <div className="panel-container">
      <h1>ChatterRealm</h1>
      <PlayerStatusCard player={panelState.player} />
      <AutoWanderControls
        enabled={panelState.autoWander}
        onToggle={handleAutoWanderToggle}
      />
      <LootPreferences
        preferences={panelState.preferredLootTypes}
        onChange={(prefs) => setPanelState(prev => ({ ...prev, preferredLootTypes: prefs }))}
      />
      <CombatStyleSelector
        style={panelState.combatStyle}
        onChange={(style) => setPanelState(prev => ({ ...prev, combatStyle: style }))}
      />
    </div>
  );
};

export default PanelApp;
</file>

<file path="packages/extensions/twitch-panel/src/types.ts">
export interface Player {
    id: string;
    displayName: string;
    level: number;
    health: number;
    maxHealth: number;
}

export interface NotificationSettings {
    deaths: boolean;
    levelUps: boolean;
    rareItems: boolean;
}

export interface WanderSettings {
    maxDistance: number;
    avoidHighLevelAreas: boolean;
    prioritizeLoot: string[];
}

export interface PanelState {
  player: Player | null;
  autoWander: boolean;
  preferredLootTypes: string[];
  combatStyle: 'aggressive' | 'defensive' | 'balanced';
  notifications: NotificationSettings;
}
</file>

<file path="packages/extensions/twitch-panel/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ChatterRealm Panel</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="packages/extensions/twitch-panel/package.json">
{
  "name": "twitch-panel-extension",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@vitejs/plugin-react": "^4.0.3",
    "eslint": "^8.45.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.3",
    "typescript": "^5.0.2",
    "vite": "^4.4.5"
  }
}
</file>

<file path="packages/extensions/twitch-panel/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="packages/extensions/twitch-panel/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="packages/extensions/twitch-panel/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

<file path="packages/frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="packages/frontend/src/components/animations/CanvasDrawEffect.tsx">
import React, { useRef, useEffect, useCallback } from 'react';
import { gsap } from 'gsap';

export interface CanvasDrawEffectProps {
  /** Canvas context to draw on */
  ctx: CanvasRenderingContext2D;
  /** Path data - either SVG path string or array of points */
  path: string | Array<{x: number, y: number}>;
  /** Animation duration in seconds */
  duration?: number;
  /** Delay before animation starts */
  delay?: number;
  /** Whether to auto-play the animation */
  autoPlay?: boolean;
  /** Stroke color */
  strokeColor?: string;
  /** Stroke width */
  strokeWidth?: number;
  /** Animation ease */
  ease?: string;
  /** Callback when animation completes */
  onComplete?: () => void;
  /** Whether to clear canvas before drawing */
  clearBeforeDraw?: boolean;
  /** Position offset */
  offset?: { x: number; y: number };
}

export class CanvasDrawEffect {
  private ctx: CanvasRenderingContext2D;
  private path: string | Array<{x: number, y: number}>;
  private duration: number;
  private delay: number;
  private strokeColor: string;
  private strokeWidth: number;
  private ease: string;
  private onComplete?: () => void;
  private clearBeforeDraw: boolean;
  private offset: { x: number; y: number };
  private animation?: gsap.core.Timeline;

  constructor(props: CanvasDrawEffectProps) {
    this.ctx = props.ctx;
    this.path = props.path;
    this.duration = props.duration || 2;
    this.delay = props.delay || 0;
    this.strokeColor = props.strokeColor || '#ffffff';
    this.strokeWidth = props.strokeWidth || 2;
    this.ease = props.ease || 'power2.out';
    this.onComplete = props.onComplete;
    this.clearBeforeDraw = props.clearBeforeDraw ?? false;
    this.offset = props.offset || { x: 0, y: 0 };

    if (props.autoPlay !== false) {
      this.play();
    }
  }

  private parseSVGPath(pathData: string): Array<{x: number, y: number}> {
    // Simple SVG path parser for basic M, L, C commands
    const commands = pathData.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi) || [];
    const points: Array<{x: number, y: number}> = [];
    let currentX = 0;
    let currentY = 0;

    commands.forEach(command => {
      const type = command[0];
      const args = command.slice(1).trim().split(/[\s,]+/).map(Number);

      switch (type) {
        case 'M':
        case 'L':
          if (args.length >= 2) {
            currentX = args[0];
            currentY = args[1];
            points.push({ x: currentX + this.offset.x, y: currentY + this.offset.y });
          }
          break;
        case 'H':
          currentX = args[0];
          points.push({ x: currentX + this.offset.x, y: currentY + this.offset.y });
          break;
        case 'V':
          currentY = args[0];
          points.push({ x: currentX + this.offset.x, y: currentY + this.offset.y });
          break;
        // Add more command support as needed
      }
    });

    return points;
  }

  private getPathPoints(): Array<{x: number, y: number}> {
    if (Array.isArray(this.path)) {
      return this.path.map(p => ({ x: p.x + this.offset.x, y: p.y + this.offset.y }));
    } else {
      return this.parseSVGPath(this.path);
    }
  }

  play() {
    const points = this.getPathPoints();
    if (points.length < 2) return;

    // Kill any existing animation
    this.stop();

    this.animation = gsap.timeline({
      delay: this.delay,
      onComplete: this.onComplete
    });

    // Animate drawing by revealing segments progressively
    for (let i = 1; i < points.length; i++) {
      const startPoint = points[i - 1];
      const endPoint = points[i];
      const segmentDuration = this.duration / (points.length - 1);

      this.animation.add(() => {
        if (this.clearBeforeDraw) {
          this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        }

        this.ctx.strokeStyle = this.strokeColor;
        this.ctx.lineWidth = this.strokeWidth;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        this.ctx.beginPath();
        this.ctx.moveTo(startPoint.x, startPoint.y);
        this.ctx.lineTo(endPoint.x, endPoint.y);
        this.ctx.stroke();
      }, i * segmentDuration);
    }
  }

  stop() {
    if (this.animation) {
      this.animation.kill();
      this.animation = undefined;
    }
  }

  reset() {
    this.stop();
    if (this.clearBeforeDraw) {
      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    }
  }
}

// React hook for canvas drawing effects
export const useCanvasDrawEffect = (
  ctx: CanvasRenderingContext2D | null,
  path: string | Array<{x: number, y: number}>,
  options: Omit<CanvasDrawEffectProps, 'ctx' | 'path'> = {}
) => {
  const effectRef = useRef<CanvasDrawEffect | null>(null);

  useEffect(() => {
    if (!ctx) return;

    effectRef.current = new CanvasDrawEffect({
      ctx,
      path,
      ...options
    });

    return () => {
      effectRef.current?.stop();
    };
  }, [ctx, path, options]);

  const play = useCallback(() => {
    effectRef.current?.play();
  }, []);

  const stop = useCallback(() => {
    effectRef.current?.stop();
  }, []);

  const reset = useCallback(() => {
    effectRef.current?.reset();
  }, []);

  return { play, stop, reset };
};

// Utility functions for common canvas drawing effects
export const createCanvasCirclePath = (
  centerX: number,
  centerY: number,
  radius: number,
  segments: number = 32
): Array<{x: number, y: number}> => {
  const points: Array<{x: number, y: number}> = [];
  for (let i = 0; i <= segments; i++) {
    const angle = (i / segments) * Math.PI * 2;
    points.push({
      x: centerX + Math.cos(angle) * radius,
      y: centerY + Math.sin(angle) * radius
    });
  }
  return points;
};

export const createCanvasRectanglePath = (
  x: number,
  y: number,
  width: number,
  height: number
): Array<{x: number, y: number}> => {
  return [
    { x, y },
    { x: x + width, y },
    { x: x + width, y: y + height },
    { x, y: y + height },
    { x, y } // Close the rectangle
  ];
};

export const createCanvasLightningPath = (
  startX: number,
  startY: number,
  endX: number,
  endY: number,
  segments: number = 8,
  intensity: number = 20
): Array<{x: number, y: number}> => {
  const points: Array<{x: number, y: number}> = [{ x: startX, y: startY }];

  const dx = (endX - startX) / segments;
  const dy = (endY - startY) / segments;

  for (let i = 1; i < segments; i++) {
    const baseX = startX + dx * i;
    const baseY = startY + dy * i;
    const offset = (Math.random() - 0.5) * intensity;

    // Perpendicular offset
    const angle = Math.atan2(dy, dx) + Math.PI / 2;
    const offsetX = Math.cos(angle) * offset;
    const offsetY = Math.sin(angle) * offset;

    points.push({
      x: baseX + offsetX,
      y: baseY + offsetY
    });
  }

  points.push({ x: endX, y: endY });
  return points;
};

export const createCanvasStarPath = (
  centerX: number,
  centerY: number,
  outerRadius: number,
  innerRadius: number,
  points: number = 5
): Array<{x: number, y: number}> => {
  const coords: Array<{x: number, y: number}> = [];
  const angle = Math.PI / points;

  for (let i = 0; i < points * 2; i++) {
    const radius = i % 2 === 0 ? outerRadius : innerRadius;
    const x = centerX + Math.cos(i * angle - Math.PI / 2) * radius;
    const y = centerY + Math.sin(i * angle - Math.PI / 2) * radius;
    coords.push({ x, y });
  }

  return coords;
};

// React component for canvas drawing effects
export interface CanvasDrawEffectComponentProps extends Omit<CanvasDrawEffectProps, 'ctx'> {
  /** Canvas ref to draw on */
  canvasRef: React.RefObject<HTMLCanvasElement>;
  /** Whether the effect is active */
  active?: boolean;
}

export const CanvasDrawEffectComponent: React.FC<CanvasDrawEffectComponentProps> = ({
  canvasRef,
  path,
  active = true,
  ...props
}) => {
  useEffect(() => {
    if (!active || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const effect = new CanvasDrawEffect({
      ctx,
      path,
      ...props
    });

    return () => {
      effect.stop();
    };
  }, [canvasRef, path, active, props]);

  return null; // This component doesn't render anything visible
};
</file>

<file path="packages/frontend/src/components/animations/DrawSVGEffect.tsx">
import React, { useRef, useEffect, useState } from 'react';
import { gsap } from 'gsap';
import { DrawSVGPlugin } from 'gsap/DrawSVGPlugin';

// Register the plugin
gsap.registerPlugin(DrawSVGPlugin);

export interface DrawSVGEffectRef {
  play: () => void;
  reset: () => void;
  isAnimating: boolean;
}

export interface DrawSVGEffectProps {
  /** Unique ID for the effect */
  id: string;
  /** SVG path data to animate */
  pathData: string;
  /** Animation duration in seconds */
  duration?: number;
  /** Delay before animation starts */
  delay?: number;
  /** Whether to auto-play the animation */
  autoPlay?: boolean;
  /** Stroke color */
  strokeColor?: string;
  /** Stroke width */
  strokeWidth?: number;
  /** Fill color (optional) */
  fillColor?: string;
  /** Animation ease */
  ease?: string;
  /** Callback when animation completes */
  onComplete?: () => void;
  /** Custom CSS classes */
  className?: string;
  /** Position offset from top-left of container */
  position?: { x: number; y: number };
  /** Size of the SVG element */
  size?: { width: number; height: number };
}

export const DrawSVGEffect = React.forwardRef<DrawSVGEffectRef, DrawSVGEffectProps>(({
  id,
  pathData,
  duration = 2,
  delay = 0,
  autoPlay = true,
  strokeColor = '#ffffff',
  strokeWidth = 2,
  fillColor,
  ease = 'power2.out',
  onComplete,
  className = '',
  position = { x: 0, y: 0 },
  size = { width: 100, height: 100 }
}, ref) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const pathRef = useRef<SVGPathElement>(null);
  const [isAnimating, setIsAnimating] = useState(false);

  const play = React.useCallback(() => {
    if (!pathRef.current) return;

    setIsAnimating(true);
    gsap.fromTo(pathRef.current,
      { drawSVG: '0%' },
      {
        drawSVG: '100%',
        duration,
        ease,
        onComplete: () => {
          setIsAnimating(false);
          onComplete?.();
        }
      }
    );
  }, [duration, ease, onComplete]);

  const reset = React.useCallback(() => {
    if (pathRef.current) {
      gsap.set(pathRef.current, { drawSVG: '0%' });
      setIsAnimating(false);
    }
  }, []);

  React.useImperativeHandle(ref, () => ({
    play,
    reset,
    isAnimating
  }), [play, reset, isAnimating]);

  useEffect(() => {
    if (!pathRef.current || !autoPlay) return;

    const tl = gsap.timeline({
      delay,
      onComplete: () => {
        setIsAnimating(false);
        onComplete?.();
      }
    });

    tl.fromTo(pathRef.current,
      { drawSVG: '0%' },
      {
        drawSVG: '100%',
        duration,
        ease,
        onStart: () => setIsAnimating(true)
      }
    );

    return () => {
      tl.kill();
    };
  }, [pathData, duration, delay, autoPlay, ease, onComplete]);

  return (
    <svg
      ref={svgRef}
      className={`draw-svg-effect ${className}`}
      style={{
        position: 'absolute',
        left: position.x,
        top: position.y,
        width: size.width,
        height: size.height,
        pointerEvents: 'none',
        zIndex: 10
      }}
      viewBox={`0 0 ${size.width} ${size.height}`}
    >
      <path
        ref={pathRef}
        d={pathData}
        stroke={strokeColor}
        strokeWidth={strokeWidth}
        fill={fillColor || 'none'}
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  );
});

// Utility component for multiple connected paths
export interface DrawSVGPathEffectProps {
  paths: Array<{
    id: string;
    pathData: string;
    strokeColor?: string;
    strokeWidth?: number;
    delay?: number;
  }>;
  duration?: number;
  stagger?: number;
  autoPlay?: boolean;
  onComplete?: () => void;
  position?: { x: number; y: number };
  size?: { width: number; height: number };
}

export const DrawSVGPathEffect: React.FC<DrawSVGPathEffectProps> = ({
  paths,
  duration = 1,
  stagger = 0.2,
  autoPlay = true,
  onComplete,
  position = { x: 0, y: 0 },
  size = { width: 100, height: 100 }
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const pathRefs = useRef<(SVGPathElement | null)[]>([]);

  useEffect(() => {
    if (!autoPlay || pathRefs.current.length === 0) return;

    const tl = gsap.timeline({
      onComplete
    });

    pathRefs.current.forEach((path, index) => {
      if (path) {
        tl.fromTo(path,
          { drawSVG: '0%' },
          {
            drawSVG: '100%',
            duration,
            ease: 'power2.out'
          },
          index * stagger
        );
      }
    });

    return () => {
      tl.kill();
    };
  }, [paths, duration, stagger, autoPlay, onComplete]);

  return (
    <svg
      ref={svgRef}
      style={{
        position: 'absolute',
        left: position.x,
        top: position.y,
        width: size.width,
        height: size.height,
        pointerEvents: 'none',
        zIndex: 10
      }}
      viewBox={`0 0 ${size.width} ${size.height}`}
    >
      {paths.map((pathConfig, index) => (
        <path
          key={pathConfig.id}
          ref={(el) => pathRefs.current[index] = el}
          d={pathConfig.pathData}
          stroke={pathConfig.strokeColor || '#ffffff'}
          strokeWidth={pathConfig.strokeWidth || 2}
          fill="none"
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      ))}
    </svg>
  );
};

// Utility functions for common game effects
export const createCircleDrawEffect = (
  centerX: number,
  centerY: number,
  radius: number
): string => {
  return `M ${centerX - radius} ${centerY} A ${radius} ${radius} 0 1 1 ${centerX - radius} ${centerY + 0.01}`;
};

export const createRectangleDrawEffect = (
  x: number,
  y: number,
  width: number,
  height: number
): string => {
  return `M ${x} ${y} L ${x + width} ${y} L ${x + width} ${y + height} L ${x} ${y + height} Z`;
};

export const createLightningBoltEffect = (
  startX: number,
  startY: number,
  endX: number,
  endY: number,
  segments: number = 5
): string => {
  const points = [];
  points.push([startX, startY]);

  const dx = (endX - startX) / segments;
  const dy = (endY - startY) / segments;

  for (let i = 1; i < segments; i++) {
    const x = startX + dx * i;
    const y = startY + dy * i;
    const offset = (Math.random() - 0.5) * 20;
    points.push([x + offset, y + offset]);
  }

  points.push([endX, endY]);

  return 'M ' + points.map(([x, y]) => `${x} ${y}`).join(' L ');
};

export const createStarDrawEffect = (
  centerX: number,
  centerY: number,
  outerRadius: number,
  innerRadius: number,
  points: number = 5
): string => {
  const angle = Math.PI / points;
  let path = '';

  for (let i = 0; i < points * 2; i++) {
    const radius = i % 2 === 0 ? outerRadius : innerRadius;
    const x = centerX + Math.cos(i * angle - Math.PI / 2) * radius;
    const y = centerY + Math.sin(i * angle - Math.PI / 2) * radius;

    if (i === 0) {
      path += `M ${x} ${y}`;
    } else {
      path += ` L ${x} ${y}`;
    }
  }

  return path + ' Z';
};
</file>

<file path="packages/frontend/src/components/animations/index.ts">
// Animation Components Index
export { RoughAnimatedShape, useRoughAnnotation } from './RoughAnimatedShape';
export { ScrollAnimatedElement, GameScrollAnimator, useScrollAnimation } from './ScrollAnimatedElement';
export {
  RoughNotation,
  useRoughNotation,
  GameAchievement,
  GameObjective,
  GameHighlight
} from './RoughNotation';
export {
  DrawSVGEffect,
  DrawSVGPathEffect,
  createCircleDrawEffect,
  createRectangleDrawEffect,
  createLightningBoltEffect,
  createStarDrawEffect
} from './DrawSVGEffect';
export {
  CanvasDrawEffect,
  useCanvasDrawEffect,
  CanvasDrawEffectComponent,
  createCanvasCirclePath,
  createCanvasRectanglePath,
  createCanvasLightningPath,
  createCanvasStarPath
} from './CanvasDrawEffect';
</file>

<file path="packages/frontend/src/components/animations/RoughAnimatedShape.tsx">
import React, { useRef, useEffect } from 'react';
import { gsap } from 'gsap';
import rough from 'roughjs';
import { RoughCanvas } from 'roughjs/bin/canvas';

interface RoughAnimatedShapeProps {
  width?: number;
  height?: number;
  animationType?: 'draw' | 'fade' | 'scale' | 'bounce';
  duration?: number;
  delay?: number;
  roughness?: number;
  stroke?: string;
  strokeWidth?: number;
  fill?: string;
  fillStyle?: 'hachure' | 'solid' | 'zigzag' | 'cross-hatch' | 'dots' | 'dashed' | 'zigzag-line';
  shape?: 'rectangle' | 'circle' | 'ellipse' | 'line' | 'path';
  shapeProps?: any;
  className?: string;
}

export const RoughAnimatedShape: React.FC<RoughAnimatedShapeProps> = ({
  width = 200,
  height = 200,
  animationType = 'draw',
  duration = 2,
  delay = 0,
  roughness = 1,
  stroke = '#000',
  strokeWidth = 2,
  fill = 'transparent',
  fillStyle = 'hachure',
  shape = 'rectangle',
  shapeProps = {},
  className = '',
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const svgRef = useRef<SVGSVGElement | null>(null);
  const pathRef = useRef<SVGPathElement | null>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return;

    // Handle HiDPI / devicePixelRatio so canvas drawing aligns with SVG/CSS coordinates
    const dpr = typeof window !== 'undefined' ? (window.devicePixelRatio || 1) : 1;
    // Keep CSS size at logical pixels, back buffer at physical pixels
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    canvas.width = Math.max(1, Math.round(width * dpr));
    canvas.height = Math.max(1, Math.round(height * dpr));

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Scale drawing operations so 1 unit === 1 CSS pixel
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Clear in CSS pixel space
    ctx.clearRect(0, 0, width, height);

    // Create rough canvas after sizing/scaling so rough uses the correct context
    const rc = rough.canvas(canvas);

    // Set rough.js options
    const options = {
      roughness,
      stroke,
      strokeWidth,
      fill: fill !== 'transparent' ? fill : undefined,
      fillStyle: fill !== 'transparent' ? fillStyle : undefined,
      ...shapeProps,
    };

    // Draw shape based on type
    let drawable;
    switch (shape) {
      case 'rectangle':
        drawable = rc.rectangle(20, 20, width - 40, height - 40, options);
        break;
      case 'circle':
        drawable = rc.circle(width / 2, height / 2, Math.min(width, height) - 40, options);
        break;
      case 'ellipse':
        drawable = rc.ellipse(width / 2, height / 2, width - 40, height - 40, options);
        break;
      case 'line':
        drawable = rc.line(20, height / 2, width - 20, height / 2, options);
        break;
      default:
        drawable = rc.rectangle(20, 20, width - 40, height - 40, options);
    }

    // Apply GSAP animation based on type
    const tl = gsap.timeline({ delay });

    switch (animationType) {
      case 'draw':
        // Animate container then overlay SVG path to simulate progressive drawing
        tl.fromTo(container, {
          opacity: 0,
          scale: 0.8
        }, {
          opacity: 1,
          scale: 1,
          duration: duration * 0.3,
          ease: "back.out(1.7)"
        });

        // Build a path that matches the rough shape geometry so we can animate its stroke
        const createPathData = () => {
          switch (shape) {
            case 'rectangle':
              return `M 20 20 L ${width - 20} 20 L ${width - 20} ${height - 20} L 20 ${height - 20} Z`;
            case 'circle': {
              const cx = width / 2;
              const cy = height / 2;
              const r = Math.max(0, Math.min(width, height) / 2 - 20);
              // two arcs to make a full circle
              return `M ${cx + r} ${cy} A ${r} ${r} 0 1 0 ${cx - r} ${cy} A ${r} ${r} 0 1 0 ${cx + r} ${cy}`;
            }
            case 'ellipse': {
              const rx = Math.max(0, (width - 40) / 2);
              const ry = Math.max(0, (height - 40) / 2);
              const cx = width / 2;
              const cy = height / 2;
              return `M ${cx + rx} ${cy} A ${rx} ${ry} 0 1 0 ${cx - rx} ${cy} A ${rx} ${ry} 0 1 0 ${cx + rx} ${cy}`;
            }
            case 'line':
              return `M 20 ${height / 2} L ${width - 20} ${height / 2}`;
            default:
              return `M 20 20 L ${width - 20} 20 L ${width - 20} ${height - 20} L 20 ${height - 20} Z`;
          }
        };

        const pathData = createPathData();

        // If svg and path nodes exist, set path d and prepare stroke-dash animation
        const setupAndAnimatePath = () => {
          const pathEl = pathRef.current;
          const svgEl = svgRef.current;
          if (!pathEl || !svgEl) return;

          // Set path data first
          pathEl.setAttribute('d', pathData);

          // Defer measurement/animation to next paint to ensure getTotalLength returns a valid value
          // (this avoids timing races on some browsers / SSR / fast renders)
          requestAnimationFrame(() => {
            try {
              const len = pathEl.getTotalLength();
              // If length is 0 for some reason, fallback to simple fade
              if (!len || len === 0) {
                pathEl.style.opacity = '0';
                svgEl.style.display = 'none';
                return;
              }

              pathEl.style.strokeDasharray = `${len}`;
              pathEl.style.strokeDashoffset = `${len}`;
              pathEl.style.opacity = '1';

              // Animate stroke drawing
              gsap.to(pathEl, {
                strokeDashoffset: 0,
                duration: duration,
                ease: "power1.out",
                delay: 0
              });

              // Fade out overlay SVG after the draw finishes and remove from layout
              gsap.to(svgEl, {
                opacity: 0,
                duration: 0.25,
                delay: duration,
                onComplete: () => {
                  // Hide/remove overlay to avoid interaction or layout issues
                  try { svgEl.style.display = 'none'; } catch (e) { /* ignore */ }
                }
              });
            } catch (e) {
              // If anything goes wrong (eg. getTotalLength not supported), hide overlay
              try {
                pathEl.style.opacity = '0';
                svgEl.style.display = 'none';
              } catch (err) { /* ignore */ }
            }
          });
        };

        // Schedule path animation to run after the initial transform (so user sees the container pop)
        tl.call(setupAndAnimatePath, null, `+=0`);
        break;

      case 'fade':
        tl.fromTo(container, {
          opacity: 0,
          y: 20
        }, {
          opacity: 1,
          y: 0,
          duration: duration,
          ease: "power2.out"
        });
        break;

      case 'scale':
        tl.fromTo(container, {
          scale: 0,
          rotation: -180
        }, {
          scale: 1,
          rotation: 0,
          duration: duration,
          ease: "back.out(1.7)"
        });
        break;

      case 'bounce':
        tl.fromTo(container, {
          y: -50,
          opacity: 0
        }, {
          y: 0,
          opacity: 1,
          duration: duration,
          ease: "bounce.out"
        });
        break;

      default:
        tl.fromTo(container, {
          opacity: 0
        }, {
          opacity: 1,
          duration: duration
        });
    }

    return () => {
      tl.kill();
    };
  }, [width, height, animationType, duration, delay, roughness, stroke, strokeWidth, fill, fillStyle, shape, shapeProps]);

  return (
    <div ref={containerRef} className={`rough-animated-shape ${className}`} style={{ position: 'relative', width, height }}>
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        style={{ display: 'block' }}
      />
      <svg
        ref={svgRef}
        width={width}
        height={height}
        viewBox={`0 0 ${width} ${height}`}
        style={{ position: 'absolute', left: 0, top: 0, pointerEvents: 'none', overflow: 'visible', opacity: 1 }}
        aria-hidden="true"
      >
        <path
          ref={pathRef}
          d=""
          fill="none"
          stroke={stroke}
          strokeWidth={strokeWidth}
          strokeLinecap="round"
          strokeLinejoin="round"
          style={{ transition: 'opacity 0.2s' }}
        />
      </svg>
    </div>
  );
};

// Hook for creating animated rough annotations
export const useRoughAnnotation = () => {
  const annotate = (
    element: HTMLElement,
    type: 'underline' | 'highlight' | 'circle' | 'box' = 'underline',
    options: {
      color?: string;
      strokeWidth?: number;
      roughness?: number;
      animationDuration?: number;
      delay?: number;
    } = {}
  ) => {
    const {
      color = '#ff6b6b',
      strokeWidth = 2,
      roughness = 1,
      animationDuration = 1,
      delay = 0
    } = options;

    // Create annotation overlay
    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.pointerEvents = 'none';
    overlay.style.zIndex = '1000';

    const rect = element.getBoundingClientRect();
    const parentRect = element.parentElement?.getBoundingClientRect() || { left: 0, top: 0 };

    overlay.style.left = `${rect.left - parentRect.left}px`;
    overlay.style.top = `${rect.top - parentRect.top}px`;
    overlay.style.width = `${rect.width}px`;
    overlay.style.height = `${rect.height}px`;

    element.parentElement?.appendChild(overlay);

    // Create canvas for rough drawing
    const canvas = document.createElement('canvas');
    canvas.width = rect.width;
    canvas.height = rect.height;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    overlay.appendChild(canvas);

    const rc = rough.canvas(canvas);

    // Animate based on type
    const tl = gsap.timeline({ delay });

    switch (type) {
      case 'underline':
        tl.fromTo(overlay, { opacity: 0 }, { opacity: 1, duration: animationDuration * 0.3 })
          .fromTo(overlay,
            { scaleX: 0 },
            {
              scaleX: 1,
              duration: animationDuration,
              transformOrigin: 'left center',
              ease: "power2.out"
            },
            0.1
          );
        // Draw underline
        setTimeout(() => {
          rc.line(0, rect.height - 5, rect.width, rect.height - 5, {
            roughness,
            stroke: color,
            strokeWidth
          });
        }, delay * 1000 + 100);
        break;

      case 'highlight':
        tl.fromTo(overlay, { opacity: 0 }, { opacity: 1, duration: animationDuration });
        // Draw highlight box
        setTimeout(() => {
          rc.rectangle(2, 2, rect.width - 4, rect.height - 4, {
            roughness,
            stroke: color,
            strokeWidth,
            fill: color,
            fillStyle: 'solid'
          });
        }, delay * 1000);
        break;

      case 'circle':
        tl.fromTo(overlay, { scale: 0, opacity: 0 }, {
          scale: 1,
          opacity: 1,
          duration: animationDuration,
          ease: "back.out(1.7)"
        });
        // Draw circle
        setTimeout(() => {
          rc.circle(rect.width / 2, rect.height / 2, Math.min(rect.width, rect.height) - 10, {
            roughness,
            stroke: color,
            strokeWidth
          });
        }, delay * 1000);
        break;

      case 'box':
        tl.fromTo(overlay, { scale: 0, opacity: 0 }, {
          scale: 1,
          opacity: 1,
          duration: animationDuration,
          ease: "back.out(1.7)"
        });
        // Draw box
        setTimeout(() => {
          rc.rectangle(5, 5, rect.width - 10, rect.height - 10, {
            roughness,
            stroke: color,
            strokeWidth
          });
        }, delay * 1000);
        break;
    }

    // Auto-remove after animation
    setTimeout(() => {
      gsap.to(overlay, {
        opacity: 0,
        duration: 0.5,
        onComplete: () => overlay.remove()
      });
    }, (delay + animationDuration + 2) * 1000);

    return overlay;
  };

  return { annotate };
};
</file>

<file path="packages/frontend/src/components/animations/RoughNotation.tsx">
import React, { useRef, useEffect } from 'react';
import { annotate } from 'rough-notation';
import type { Annotation } from 'rough-notation/lib/model';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';

gsap.registerPlugin(ScrollTrigger);

interface RoughNotationProps {
  children: React.ReactNode;
  type?: 'underline' | 'box' | 'circle' | 'highlight' | 'strike-through' | 'crossed-off';
  color?: string;
  strokeWidth?: number;
  padding?: number;
  iterations?: number;
  animationDuration?: number;
  animationDelay?: number;
  multiline?: boolean;
  className?: string;
  trigger?: 'hover' | 'click' | 'scroll' | 'manual';
  show?: boolean;
}

export const RoughNotation: React.FC<RoughNotationProps> = ({
  children,
  type = 'underline',
  color = '#ff6b6b',
  strokeWidth = 2,
  padding = 5,
  iterations = 2,
  animationDuration = 800,
  animationDelay = 0,
  multiline = false,
  className = '',
  trigger = 'manual',
  show = false,
}) => {
  const elementRef = useRef<HTMLElement>(null);
  const annotationRef = useRef<Annotation | null>(null);

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const annotation = annotate(element, {
      type,
      color,
      strokeWidth,
      padding,
      iterations,
      animationDuration,
      multiline,
    });
    annotationRef.current = annotation;

    const ctx = gsap.context(() => {
      const handleTrigger = () => annotation.show();
      const handleHide = () => annotation.hide();

      if (trigger === 'scroll') {
        ScrollTrigger.create({
          trigger: element,
          start: 'top 80%',
          onEnter: handleTrigger,
          onLeaveBack: handleHide,
          onLeave: handleHide,
        });
      } else if (trigger === 'hover') {
        element.addEventListener('mouseenter', handleTrigger);
        element.addEventListener('mouseleave', handleHide);
      } else if (trigger === 'click') {
        element.addEventListener('click', handleTrigger);
      }
      
      return () => {
        element.removeEventListener('mouseenter', handleTrigger);
        element.removeEventListener('mouseleave', handleHide);
        element.removeEventListener('click', handleTrigger);
      };
    }, elementRef);

    return () => {
      ctx.revert();
      annotation.remove();
    };
  }, [type, color, strokeWidth, padding, iterations, animationDuration, multiline, trigger]);

  useEffect(() => {
    if (trigger === 'manual' && annotationRef.current) {
      if (show) {
        annotationRef.current.show();
      } else {
        annotationRef.current.hide();
      }
    }
  }, [show, trigger]);

  return (
    <span
      ref={elementRef}
      className={`rough-notation ${className}`}
      style={{ cursor: trigger === 'click' ? 'pointer' : 'inherit' }}
    >
      {children}
    </span>
  );
};

// Hook for programmatic rough notation control
export const useRoughNotation = () => {
  const annotationsRef = useRef<Map<string, Annotation>>(new Map());

  useEffect(() => {
    // Cleanup on unmount
    return () => {
      annotationsRef.current.forEach(annotation => annotation.remove());
    };
  }, []);

  const createAnnotation = (
    element: HTMLElement,
    id: string,
    options: {
      type: 'underline' | 'box' | 'circle' | 'highlight' | 'strike-through' | 'crossed-off';
      color?: string;
      strokeWidth?: number;
      padding?: number;
      iterations?: number;
      animationDuration?: number;
      multiline?: boolean;
    } = {} as any
  ) => {
    const annotation = annotate(element, options);
    annotationsRef.current.set(id, annotation);
    return annotation;
  };

  const show = (id: string) => {
    annotationsRef.current.get(id)?.show();
  };

  const hide = (id: string) => {
    annotationsRef.current.get(id)?.hide();
  };

  const remove = (id: string) => {
    const annotation = annotationsRef.current.get(id);
    if (annotation) {
      annotation.remove();
      annotationsRef.current.delete(id);
    }
  };

  const animateSequence = (
    elements: Array<{ element: HTMLElement; id: string; options?: any; delay?: number }>
  ) => {
    const tl = gsap.timeline();
    const createdAnnotations: Annotation[] = [];

    elements.forEach(({ element, id, options = {}, delay = 0 }, index) => {
      const annotation = createAnnotation(element, id, options);
      createdAnnotations.push(annotation);
      tl.call(() => annotation.show(), [], delay + index * 0.5);
    });

    // Add a cleanup for the timeline
    tl.eventCallback('onReverseComplete', () => {
      createdAnnotations.forEach(ann => ann.remove());
    });
    
    return tl;
  };

  return {
    createAnnotation,
    show,
    hide,
    remove,
    animateSequence
  };
};

// Game-specific annotation components
export const GameAchievement: React.FC<{
  children: React.ReactNode;
  achieved?: boolean;
  className?: string;
}> = ({ children, achieved = false, className = '' }) => {
  return (
    <RoughNotation
      type="highlight"
      color={achieved ? "#4ade80" : "#f59e0b"}
      animationDuration={1000}
      trigger="manual"
      show={achieved}
      className={`game-achievement ${className}`}
    >
      {children}
    </RoughNotation>
  );
};

export const GameObjective: React.FC<{
  children: React.ReactNode;
  completed?: boolean;
  className?: string;
}> = ({ children, completed = false, className = '' }) => {
  return (
    <RoughNotation
      type={completed ? "strike-through" : "underline"}
      color={completed ? "#10b981" : "#3b82f6"}
      animationDuration={800}
      trigger="manual"
      show={true}
      className={`game-objective ${className}`}
    >
      {children}
    </RoughNotation>
  );
};

export const GameHighlight: React.FC<{
  children: React.ReactNode;
  type?: 'important' | 'warning' | 'success' | 'info';
  trigger?: 'hover' | 'click' | 'scroll';
  className?: string;
}> = ({ children, type = 'important', trigger = 'hover', className = '' }) => {
  const colors = {
    important: '#ef4444',
    warning: '#f59e0b',
    success: '#10b981',
    info: '#3b82f6'
  };

  return (
    <RoughNotation
      type="box"
      color={colors[type]}
      strokeWidth={3}
      padding={8}
      animationDuration={600}
      trigger={trigger}
      className={`game-highlight game-highlight-${type} ${className}`}
    >
      {children}
    </RoughNotation>
  );
};
</file>

<file path="packages/frontend/src/components/animations/ScrollAnimatedElement.tsx">
import React, { useRef, useEffect } from 'react';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';

// Register ScrollTrigger plugin
gsap.registerPlugin(ScrollTrigger);

interface ScrollAnimatedElementProps {
  children: React.ReactNode;
  animation?: 'fadeIn' | 'slideUp' | 'slideDown' | 'slideLeft' | 'slideRight' | 'scale' | 'rotate';
  trigger?: string | HTMLElement;
  start?: string;
  end?: string;
  scrub?: boolean | number;
  pin?: boolean;
  markers?: boolean;
  className?: string;
}

export const ScrollAnimatedElement: React.FC<ScrollAnimatedElementProps> = ({
  children,
  animation = 'fadeIn',
  trigger,
  start = 'top 80%',
  end = 'bottom 20%',
  scrub = false,
  pin = false,
  markers = false,
  className = '',
}) => {
  const elementRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const ctx = gsap.context(() => {
      // Set initial state based on animation type
      let initialProps: any = {};
      let animateProps: any = {};

      switch (animation) {
        case 'fadeIn':
          initialProps = { opacity: 0 };
          animateProps = { opacity: 1 };
          break;
        case 'slideUp':
          initialProps = { opacity: 0, y: 50 };
          animateProps = { opacity: 1, y: 0 };
          break;
        case 'slideDown':
          initialProps = { opacity: 0, y: -50 };
          animateProps = { opacity: 1, y: 0 };
          break;
        case 'slideLeft':
          initialProps = { opacity: 0, x: 50 };
          animateProps = { opacity: 1, x: 0 };
          break;
        case 'slideRight':
          initialProps = { opacity: 0, x: -50 };
          animateProps = { opacity: 1, x: 0 };
          break;
        case 'scale':
          initialProps = { opacity: 0, scale: 0.8 };
          animateProps = { opacity: 1, scale: 1 };
          break;
        case 'rotate':
          initialProps = { opacity: 0, rotation: -10 };
          animateProps = { opacity: 1, rotation: 0 };
          break;
        default:
          initialProps = { opacity: 0 };
          animateProps = { opacity: 1 };
      }

      // Set initial state
      gsap.set(element, initialProps);

      // Create ScrollTrigger animation
      gsap.to(element, {
        ...animateProps,
        duration: 1,
        ease: 'power2.out',
        scrollTrigger: {
          trigger: trigger || element,
          start,
          end,
          scrub,
          pin,
          markers,
          toggleActions: 'play none none reverse'
        }
      });
    }, elementRef); // scope the context to the component

    return () => ctx.revert(); // cleanup
  }, [animation, trigger, start, end, scrub, pin, markers]);

  return (
    <div ref={elementRef} className={`scroll-animated-element ${className}`}>
      {children}
    </div>
  );
};

// Hook for creating scroll-triggered animations
export const useScrollAnimation = () => {
  const createScrollTrigger = (
    element: HTMLElement | string,
    animation: {
      from?: any;
      to?: any;
      duration?: number;
      ease?: string;
    },
    trigger: {
      start?: string;
      end?: string;
      scrub?: boolean | number;
      pin?: boolean;
      markers?: boolean;
    } = {}
  ) => {
    const {
      from = { opacity: 0, y: 50 },
      to = { opacity: 1, y: 0 },
      duration = 1,
      ease = 'power2.out'
    } = animation;

    const {
      start = 'top 80%',
      end = 'bottom 20%',
      scrub = false,
      pin = false,
      markers = false
    } = trigger;

    // Set initial state
    gsap.set(element, from);

    // Create animation
    gsap.to(element, {
      ...to,
      duration,
      ease,
      scrollTrigger: {
        trigger: element,
        start,
        end,
        scrub,
        pin,
        markers,
        toggleActions: 'play none none reverse'
      }
    });
  };

  const createParallax = (
    element: HTMLElement,
    speed: number = 0.5,
    direction: 'up' | 'down' | 'left' | 'right' = 'up'
  ) => {
    const directionMap = {
      up: { y: -speed * 100 },
      down: { y: speed * 100 },
      left: { x: -speed * 100 },
      right: { x: speed * 100 }
    };

    gsap.to(element, {
      ...directionMap[direction],
      ease: 'none',
      scrollTrigger: {
        trigger: element,
        start: 'top bottom',
        end: 'bottom top',
        scrub: true
      }
    });
  };

  const createReveal = (
    element: HTMLElement,
    direction: 'up' | 'down' | 'left' | 'right' = 'up',
    distance: number = 50
  ) => {
    const directionMap = {
      up: { y: -distance },
      down: { y: distance },
      left: { x: -distance },
      right: { x: distance }
    };

    gsap.fromTo(element,
      {
        opacity: 0,
        ...directionMap[direction]
      },
      {
        opacity: 1,
        x: 0,
        y: 0,
        duration: 1,
        ease: 'power2.out',
        scrollTrigger: {
          trigger: element,
          start: 'top 80%',
          toggleActions: 'play none none reverse'
        }
      }
    );
  };

  return {
    createScrollTrigger,
    createParallax,
    createReveal
  };
};

// Component for animating game UI elements on scroll
export const GameScrollAnimator: React.FC<{
  children: React.ReactNode;
  className?: string;
}> = ({ children, className = '' }) => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const ctx = gsap.context(() => {
      // Animate game UI elements as they come into view
      const uiElements = container.querySelectorAll('.game-ui-element');

      uiElements.forEach((element, index) => {
        gsap.fromTo(element,
          {
            opacity: 0,
            y: 30,
            scale: 0.9
          },
          {
            opacity: 1,
            y: 0,
            scale: 1,
            duration: 0.8,
            ease: 'back.out(1.7)',
            scrollTrigger: {
              trigger: element,
              start: 'top 85%',
              toggleActions: 'play none none reverse'
            },
            delay: index * 0.1
          }
        );
      });
    }, containerRef); // scope the context to the component

    return () => ctx.revert(); // cleanup
  }, []);

  return (
    <div ref={containerRef} className={`game-scroll-animator ${className}`}>
      {children}
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/character/CharacterCreator.tsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { CharacterClass, CharacterVisual } from 'shared';
import { EmojiCharacterService } from '../../services/EmojiCharacterService';
import { useCharacterClasses } from '../../hooks/useCharacterClasses';
import { useGameStore } from '../../stores/gameStore';
import { EmojiPicker } from './EmojiPicker';
import { ClassCard } from './ClassCard';
import { CharacterStats } from './CharacterStats';
import { ClassBackgroundEffects } from './ClassEffects';

export const CharacterCreator: React.FC = () => {
  const [selectedEmoji, setSelectedEmoji] = useState('ðŸ§™â€â™‚ï¸');
  const [selectedClass, setSelectedClass] = useState<CharacterClass | null>(null);
  const [characterPreview, setCharacterPreview] = useState<CharacterVisual | null>(null);
  const [currentAnimationFrame, setCurrentAnimationFrame] = useState(0);
  const [characterName, setCharacterName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [emojiService] = useState(() => new EmojiCharacterService());
  const { characterClasses } = useCharacterClasses();
  const { handleCreateCharacter } = useGameStore();
  const navigate = useNavigate();

  useEffect(() => {
    let animationInterval: NodeJS.Timeout;

    const generateCharacterPreview = async () => {
      if (!selectedClass) return;

      setIsLoading(true);
      setError(null);
      try {
        const preview = await emojiService.createCharacterFromEmoji(selectedEmoji, selectedClass);
        setCharacterPreview(preview);

        animationInterval = setInterval(() => {
          setCurrentAnimationFrame(prev => (prev + 1) % (preview.animationFrames.length || 1));
        }, preview.animationSpeed);
      } catch (e) {
        console.error("Error generating character preview:", e);
        setError("Could not generate character preview.");
      } finally {
        setIsLoading(false);
      }
    };

    generateCharacterPreview();

    return () => {
      if (animationInterval) {
        clearInterval(animationInterval);
      }
    };
  }, [selectedEmoji, selectedClass]);

  const createCharacter = async () => {
    if (!selectedClass || !characterPreview || !characterName.trim()) {
      setError("Please select a class, and enter a name.");
      return;
    }

    setIsLoading(true);
    setError(null);

    const characterData = {
      id: `player_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: characterName.trim(),
      emoji: selectedEmoji,
      characterClass: selectedClass,
      visual: characterPreview,
      stats: { ...selectedClass.baseStats },
      level: 1,
      experience: 0,
      resources: {
        [selectedClass.primaryResource]: 100
      },
      abilities: selectedClass.abilities.filter(ability => ability.unlockLevel <= 1),
      inventory: [],
      equipment: {},
      position: { x: 0, y: 0 },
      isAlive: true,
      spawnTime: Date.now(),
      lastActive: Date.now()
    };

    try {
      await handleCreateCharacter(characterData);
      navigate('/play');
    } catch (err) {
      console.error('Failed to create character:', err);
      setError('Failed to create character. Please try again.');
      setIsLoading(false);
    }
  };

  return (
    <div className="character-creator bg-gray-900 p-6 rounded-lg max-w-4xl mx-auto">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">

        <div className="preview-section">
          <h2 className="text-2xl font-bold mb-4 text-green-400">Character Preview</h2>

          <div className="preview-container bg-black p-8 rounded-lg relative h-64 flex items-center justify-center">
            {isLoading && <div className="text-white">Loading Preview...</div>}
            {error && !isLoading && <div className="text-red-500">{error}</div>}
            {characterPreview && !isLoading && (
              <div
                className="character-preview-avatar scale-150"
                dangerouslySetInnerHTML={{
                  __html: characterPreview.animationFrames[currentAnimationFrame] || ''
                }}
              />
            )}

            {selectedClass && (
              <div className="class-effects absolute inset-0 pointer-events-none">
                <ClassBackgroundEffects characterClass={selectedClass} />
              </div>
            )}
          </div>

          {selectedClass && (
            <CharacterStats characterClass={selectedClass} />
          )}
        </div>

        <div className="creation-controls">
          <h2 className="text-2xl font-bold mb-4 text-green-400">Create Your Survivor</h2>

          <div className="emoji-selection mb-6">
            <h3 className="text-lg font-semibold mb-3">Choose Your Avatar</h3>
            <EmojiPicker
              selectedEmoji={selectedEmoji}
              onEmojiSelect={setSelectedEmoji}
              categories={['people', 'animals', 'objects', 'symbols']}
            />
          </div>

          <div className="class-selection">
            <h3 className="text-lg font-semibold mb-3">Select Your Path</h3>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
              {characterClasses.map(charClass => (
                <ClassCard
                  key={charClass.id}
                  characterClass={charClass}
                  isSelected={selectedClass?.id === charClass.id}
                  onSelect={() => setSelectedClass(charClass)}
                />
              ))}
            </div>
          </div>

          <div className="character-name mt-6">
            <h3 className="text-lg font-semibold mb-3">Survivor Name</h3>
            <input
              type="text"
              className="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white"
              placeholder="Enter your wasteland name..."
              maxLength={20}
              value={characterName}
              onChange={(e) => setCharacterName(e.target.value)}
            />
          </div>

          <button
            className="create-character-btn mt-6 w-full bg-green-600 hover:bg-green-500 text-white py-3 rounded-lg font-semibold disabled:bg-gray-500"
            disabled={!selectedClass || !characterName.trim() || isLoading}
            onClick={createCharacter}
          >
            {isLoading ? 'Entering Wasteland...' : 'Enter the Wasteland'}
          </button>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/character/CharacterStats.tsx">
import React from 'react';
import { CharacterClass } from 'shared';

export const CharacterStats: React.FC<{ characterClass: CharacterClass }> = ({ characterClass }) => {
  return (
    <div className="character-stats mt-4 bg-gray-800 p-4 rounded-lg">
      <h3 className="text-lg font-semibold mb-3 text-center">{characterClass.name}</h3>
      <p className="text-sm text-gray-300 mb-4 italic">"{characterClass.lore}"</p>

      <div className="stats-grid grid grid-cols-2 gap-2 text-sm">
        {Object.entries(characterClass.baseStats).map(([stat, value]) => (
          <div key={stat} className="stat-row flex justify-between">
            <span className="capitalize text-gray-400">{stat}:</span>
            <span className="text-white font-semibold">{value}</span>
          </div>
        ))}
      </div>

      <div className="resource-info mt-4 pt-4 border-t border-gray-700">
        <div className="flex justify-between text-sm">
          <span className="text-gray-400">Resource:</span>
          <span className="text-white capitalize">{characterClass.primaryResource.replace('_', ' ')}</span>
        </div>
      </div>

      <div className="abilities-preview mt-4">
        <h4 className="text-sm font-semibold mb-2 text-gray-300">Starting Abilities</h4>
        {characterClass.abilities.filter(ability => ability.unlockLevel <= 2).map(ability => (
          <div key={ability.id} className="ability-item mb-2 p-2 bg-gray-900 rounded">
            <div className="flex justify-between items-center">
              <span className="text-sm font-medium">{ability.name}</span>
              <span className="text-xs text-gray-400">Lvl {ability.unlockLevel}</span>
            </div>
            <p className="text-xs text-gray-400 mt-1">{ability.description}</p>
          </div>
        ))}
      </div>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/character/ClassCard.tsx">
import React from 'react';
import { CharacterClass } from 'shared';

export const ClassCard: React.FC<{
  characterClass: CharacterClass;
  isSelected: boolean;
  onSelect: () => void;
}> = ({ characterClass, isSelected, onSelect }) => {
  return (
    <div
      className={`class-card p-4 rounded-lg border-2 cursor-pointer transition-all ${
        isSelected
          ? 'border-green-500 bg-green-900/20'
          : 'border-gray-600 bg-gray-800 hover:border-gray-500'
      }`}
      onClick={onSelect}
    >
      <div
        className="class-icon w-12 h-12 rounded-full mb-3 mx-auto"
        style={{
          background: `linear-gradient(135deg, ${characterClass.primaryColor}, ${characterClass.secondaryColor})`
        }}
      />
      <h4 className="text-sm font-semibold text-center mb-2">{characterClass.name}</h4>
      <p className="text-xs text-gray-400 text-center">{characterClass.description}</p>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/character/ClassEffects.tsx">
import React, { useEffect, useRef } from 'react';
import { CharacterClass } from 'shared';
import { getClassBackgroundGradient, getClassEffectClasses, getClassFilter } from '../../utils/classVisuals';

const createParticleSystem = (characterClass: CharacterClass): HTMLElement => {
  const container = document.createElement('div');
  container.className = 'particles absolute inset-0';

  const particleCount = 15;
  const particleType = getParticleType(characterClass.id);

  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.className = `particle particle-${particleType}`;
    particle.style.cssText = `
      position: absolute;
      width: ${Math.random() * 4 + 2}px;
      height: ${Math.random() * 4 + 2}px;
      background: ${characterClass.primaryColor};
      border-radius: 50%;
      opacity: ${Math.random() * 0.6 + 0.2};
      animation: ${particleType}-float ${Math.random() * 3 + 2}s infinite linear;
      left: ${Math.random() * 100}%;
      top: ${Math.random() * 100}%;
      animation-delay: ${Math.random() * 2}s;
    `;

    container.appendChild(particle);
  }

  return container;
};

const getParticleType = (classId: string): string => {
  switch (classId) {
    case 'quantum-drifter': return 'quantum';
    case 'tech-shaman': return 'circuit';
    case 'bio-hacker': return 'organic';
    case 'void-walker': return 'void';
    case 'nano-smith': return 'nano';
    case 'psy-scavenger': return 'psychic';
    default: return 'default';
  }
};

export const ClassBackgroundEffects: React.FC<{ characterClass: CharacterClass }> = ({ characterClass }) => {
  const effectsRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const effects = effectsRef.current;
    if (!effects) return;

    // Create class-specific particle effects
    const particleSystem = createParticleSystem(characterClass);
    effects.appendChild(particleSystem);

    return () => {
      if (effects.contains(particleSystem)) {
        effects.removeChild(particleSystem);
      }
    };
  }, [characterClass]);

  return (
    <div
      ref={effectsRef}
      className={`class-effects absolute inset-0 ${getClassEffectClasses(characterClass.id)}`}
      style={{
        background: getClassBackgroundGradient(characterClass),
        filter: getClassFilter(characterClass.id)
      }}
    />
  );
};
</file>

<file path="packages/frontend/src/components/character/EmojiPicker.tsx">
import React from 'react';
import { CharacterClass } from 'shared';

export const EmojiPicker: React.FC<{
  selectedEmoji: string;
  onEmojiSelect: (emoji: string) => void;
  categories: string[];
}> = ({ selectedEmoji, onEmojiSelect, categories }) => {
  const emojisByCategory = {
    people: ['ðŸ‘¤', 'ðŸ§™â€â™‚ï¸', 'ðŸ§™â€â™€ï¸', 'ðŸ‘¨â€ðŸ’»', 'ðŸ‘©â€ðŸ’»', 'ðŸ¦¾', 'ðŸ¤–', 'ðŸ‘»', 'ðŸ§›â€â™‚ï¸', 'ðŸ§›â€â™€ï¸', 'ðŸ§žâ€â™‚ï¸', 'ðŸ§žâ€â™€ï¸'],
    animals: ['ðŸº', 'ðŸ¦…', 'ðŸ', 'ðŸ¦‚', 'ðŸ•·ï¸', 'ðŸ¦‡', 'ðŸ‰', 'ðŸ¦–', 'ðŸ™', 'ðŸ¦‘', 'ðŸ‘¾', 'ðŸ¦ '],
    objects: ['âš”ï¸', 'ðŸ›¡ï¸', 'ðŸ”®', 'âš¡', 'ðŸ”¥', 'â„ï¸', 'â˜¢ï¸', 'âš›ï¸', 'ðŸ”¬', 'ðŸ’Ž', 'ðŸ§¬', 'ðŸŽ­'],
    symbols: ['ðŸ’€', 'â˜ ï¸', 'âš ï¸', 'ðŸ”¥', 'ðŸ’¥', 'âœ¨', 'ðŸŒŸ', 'ðŸ’«', 'ðŸ”®', 'ðŸŽ¯', 'ðŸŽ²', 'â™ ï¸']
  };

  return (
    <div className="emoji-picker bg-gray-800 p-4 rounded-lg">
      {categories.map(category => (
        <div key={category} className="emoji-category mb-4">
          <h4 className="text-sm font-semibold mb-2 capitalize text-gray-400">{category}</h4>
          <div className="grid grid-cols-6 gap-2">
            {(emojisByCategory as any)[category]?.map((emoji: string) => (
              <button
                key={emoji}
                className={`emoji-option p-2 rounded text-2xl hover:bg-gray-700 transition-colors ${
                  selectedEmoji === emoji ? 'bg-blue-600' : ''
                }`}
                onClick={() => onEmojiSelect(emoji)}
              >
                {emoji}
              </button>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/chat/ChatInterface.tsx">
import React from 'react';
import { Player } from '../../types/chat';
import { useChat } from '../../hooks/useChat';
import ChatWindow from './ChatWindow';
import { commandProcessor } from '../../services/chat/CommandProcessor'; // Import the commandProcessor

interface ChatInterfaceProps {
  players: Player[];
  onWorldUpdate: (players: Player[]) => void;
}

const ChatInterface: React.FC<ChatInterfaceProps> = ({ players, onWorldUpdate }) => {
  const {
    messages,
    inputMessage,
    setInputMessage,
    username,
    setUsername,
    displayName,
    setDisplayName,
    channelPoints,
    setChannelPoints,
    isConnected,
    sendChatCommand,
    handleKeyPress,
    setInputMessageAndFocus,
  } = useChat(onWorldUpdate);

  const presetCommands = commandProcessor.getPresetCommands();

  return (
    <ChatWindow
      messages={messages}
      inputMessage={inputMessage}
      setInputMessage={setInputMessage}
      handleKeyPress={handleKeyPress}
      sendChatCommand={sendChatCommand}
      isConnected={isConnected}
      username={username}
      displayName={displayName}
      channelPoints={channelPoints}
      setChannelPoints={setChannelPoints}
      players={players}
      presetCommands={presetCommands}
      setInputMessageAndFocus={setInputMessageAndFocus}
    />
  );
};

export default ChatInterface;
</file>

<file path="packages/frontend/src/components/chat/MessageInput.tsx">
import React from 'react';

interface MessageInputProps {
  inputMessage: string;
  setInputMessage: (message: string) => void;
  handleKeyPress: (e: React.KeyboardEvent) => void;
  sendChatCommand: () => void;
  isConnected: boolean;
}

const MessageInput: React.FC<MessageInputProps> = ({
  inputMessage,
  setInputMessage,
  handleKeyPress,
  sendChatCommand,
  isConnected,
}) => {
  return (
    <div className="message-input-area">
      <input
        type="text"
        placeholder="Type a command (e.g., !help, !spawn knight)"
        value={inputMessage}
        onChange={(e) => setInputMessage(e.target.value)}
        onKeyPress={handleKeyPress}
        className="message-input"
      />
      <button
        onClick={sendChatCommand}
        disabled={!isConnected}
        className="send-button"
      >
        Send
      </button>
    </div>
  );
};

export default MessageInput;
</file>

<file path="packages/frontend/src/components/dev/BiomeDebugTools.tsx">
import React from 'react';

const BiomeVisualizer = () => <div>Biome Visualizer Placeholder</div>;
const RoughFillTester = () => <div>Rough Fill Tester Placeholder</div>;
const PerformanceMonitor = () => <div>Performance Monitor Placeholder</div>;
const BiomeConfigEditor = () => <div>Biome Config Editor Placeholder</div>;

export const BiomeDebugTools: React.FC = () => {
  return (
    <div className="biome-debug-tools" style={{ position: 'absolute', top: 10, right: 10, background: 'rgba(0,0,0,0.5)', color: 'white', padding: 10, zIndex: 1000 }}>
      <h3>Biome Debug Tools</h3>
      <BiomeVisualizer />
      <RoughFillTester />
      <PerformanceMonitor />
      <BiomeConfigEditor />
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/dev/EmojiSvgSmokeTest.tsx">
import React, { useEffect, useState } from 'react';
import { assetConverter } from '../../services/assetConverter';

const EMOJIS = ['ðŸ˜€', 'ðŸ‘©\u200dðŸ‘©\u200dðŸ‘§', 'ðŸ‘\u{1f3fd}'];

const EmojiSvgSmokeTest: React.FC = () => {
  const [results, setResults] = useState<Record<string, { svg?: string; error?: string }>>({});

  useEffect(() => {
    let mounted = true;

    const run = async () => {
      const out: Record<string, { svg?: string; error?: string }> = {};

      for (const e of EMOJIS) {
        try {
          // Try svgmoji first then fallback to noto via the service
          const svg = await assetConverter.fetchEmojiSvg(e, 'svgmoji');
          const converted = await assetConverter.convertSvgToRough(svg, assetConverter.getDefaultOptions());
          out[e] = { svg: converted.svg };
        } catch (err) {
          out[e] = { error: String(err) };
        }

        if (!mounted) break;
        setResults({ ...out });
      }
    };

    run();
    return () => { mounted = false; };
  }, []);

  return (
    <div style={{ padding: 12, color: 'white' }}>
      <h3>Emoji SVG Smoke Test (dev only)</h3>
      {EMOJIS.map(e => (
        <div key={e} style={{ marginBottom: 12, background: 'rgba(255,255,255,0.03)', padding: 8, borderRadius: 6 }}>
          <div style={{ fontSize: 28 }}>{e}</div>
          <div style={{ marginTop: 8 }}>
            {results[e]?.svg ? (
              <div dangerouslySetInnerHTML={{ __html: results[e].svg }} />
            ) : results[e]?.error ? (
              <div style={{ color: 'salmon' }}>Error: {results[e].error}</div>
            ) : (
              <div style={{ color: '#ccc' }}>Loading...</div>
            )}
          </div>
        </div>
      ))}
    </div>
  );
};

export default EmojiSvgSmokeTest;
</file>

<file path="packages/frontend/src/components/GameCanvas/hooks/useCanvasSetup.ts">
import { useRef, useEffect, useState } from 'react';
import { GAME_CONFIG } from 'shared';

interface CanvasSetup {
  canvas: HTMLCanvasElement | null;
  ctx: CanvasRenderingContext2D | null;
  tileSizePx: number;
  offset: { x: number; y: number };
  dpr: number;
  renderScale: number;
  isReady: boolean;
}

export const useCanvasSetup = (
  canvasRef: React.RefObject<HTMLCanvasElement>,
  containerSize: { width: number; height: number },
  grid: { length: number } | null,
  innerPadding: number = 8,
  renderScale: number = 1.0 // Default to full resolution for crisp rendering
): CanvasSetup => {
  const [isReady, setIsReady] = useState(false);
  const setupRef = useRef<CanvasSetup>({
    canvas: null,
    ctx: null,
    tileSizePx: 0,
    offset: { x: 0, y: 0 },
    dpr: 1,
    renderScale: renderScale,
    isReady: false,
  });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !containerSize.width || !containerSize.height || !grid) {
      setIsReady(false);
      return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('useCanvasSetup: cannot get 2d context');
      return;
    }

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const numTilesX = grid[0]?.length || 60;
    const numTilesY = grid.length || 30;
    const gridSize = GAME_CONFIG.tileSize;

    // Calculate scaling
    const effectiveCssWidth = Math.max(0, containerSize.width - innerPadding * 2);
    const effectiveCssHeight = Math.max(0, containerSize.height - innerPadding * 2);
    const scaleX = effectiveCssWidth / (numTilesX * gridSize);
    const scaleY = effectiveCssHeight / (numTilesY * gridSize);
    const worldScale = Math.min(scaleX, scaleY);
    const clampedWorldScale = Math.max(1.0, Math.min(worldScale, 5.0));

    const tileSizePx = gridSize * clampedWorldScale;
    const renderedWidth = numTilesX * tileSizePx;
    const renderedHeight = numTilesY * tileSizePx;

    // Apply render scaling for performance optimization
    const scaledWidth = Math.floor(containerSize.width * renderScale);
    const scaledHeight = Math.floor(containerSize.height * renderScale);

    // Ensure dimensions don't exceed reasonable bounds (prevent runaway growth)
    const maxReasonableWidth = 4096; // 4K width max
    const maxReasonableHeight = 2160; // 4K height max
    const boundedScaledWidth = Math.min(scaledWidth, maxReasonableWidth);
    const boundedScaledHeight = Math.min(scaledHeight, maxReasonableHeight);

    // Debug logging
    console.log('CanvasSetup:', {
      container: { width: Math.round(containerSize.width), height: Math.round(containerSize.height) },
      scaled: { width: boundedScaledWidth, height: boundedScaledHeight },
      final: { width: Math.floor(boundedScaledWidth * dpr), height: Math.floor(boundedScaledHeight * dpr) },
      dpr, renderScale
    });

    // Set canvas dimensions with scaling
    canvas.style.width = `${containerSize.width}px`;
    canvas.style.height = `${containerSize.height}px`;
    canvas.width = Math.floor(boundedScaledWidth * dpr);
    canvas.height = Math.floor(boundedScaledHeight * dpr);

    // Reset transform to identity first, then apply our transforms
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    
    // Apply DPR and render scaling
    ctx.setTransform(dpr * renderScale, 0, 0, dpr * renderScale, 0, 0);
    ctx.imageSmoothingEnabled = false; // Disable smoothing for pixel-perfect rendering
    ctx.imageSmoothingQuality = 'high';

    // Center the game world
    const offsetX = innerPadding + (effectiveCssWidth - renderedWidth) / 2;
    const offsetY = innerPadding + (effectiveCssHeight - renderedHeight) / 2;
    ctx.translate(offsetX, offsetY);

    // Update ref
    setupRef.current = {
      canvas,
      ctx,
      tileSizePx,
      offset: { x: offsetX, y: offsetY },
      dpr,
      renderScale,
      isReady: true,
    };

    setIsReady(true);

    // Cleanup on unmount
    return () => {
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
    };
  }, [canvasRef, containerSize, grid, innerPadding, renderScale]);

  return setupRef.current;
};
</file>

<file path="packages/frontend/src/components/GameCanvas/hooks/useContainerResize.ts">
import { useState, useEffect, useRef } from 'react';

interface ContainerSize {
  width: number;
  height: number;
}

export const useContainerResize = (containerRef: React.RefObject<HTMLDivElement>): ContainerSize => {
  const [containerSize, setContainerSize] = useState<ContainerSize>({ width: 0, height: 0 });
  const resizeObserverRef = useRef<ResizeObserver | null>(null);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        // Debug logging to track container size changes
        console.log('ContainerResize:', { width: Math.round(width), height: Math.round(height) });
        setContainerSize({ width, height });
      }
    });

    resizeObserver.observe(container);
    resizeObserverRef.current = resizeObserver;

    return () => {
      if (resizeObserverRef.current) {
        resizeObserverRef.current.disconnect();
      }
    };
  }, [containerRef]);

  return containerSize;
};
</file>

<file path="packages/frontend/src/components/GameCanvas/managers/EffectManager.ts">
import { useState, useCallback } from 'react';
import { createCanvasCirclePath, createCanvasLightningPath, createCanvasStarPath } from '../../animations/CanvasDrawEffect';

interface DrawEffect {
  id: string;
  path: Array<{ x: number; y: number }>;
  active: boolean;
  duration?: number;
  strokeColor?: string;
  strokeWidth?: number;
}

interface EffectManagerProps {
  canvasRef: React.RefObject<HTMLCanvasElement>;
}

export const useEffectManager = ({ canvasRef }: EffectManagerProps) => {
  const [drawEffects, setDrawEffects] = useState<DrawEffect[]>([]);

  const triggerDrawEffect = useCallback((
    x: number,
    y: number,
    effectType: 'circle' | 'lightning' | 'star' = 'circle'
  ) => {
    const effectId = `effect-${Date.now()}-${Math.random()}`;

    let path: Array<{ x: number; y: number }>;
    let strokeColor: string;
    let duration: number;
    let strokeWidth: number = 3;

    switch (effectType) {
      case 'circle':
        path = createCanvasCirclePath(x, y, 30, 16);
        strokeColor = '#00ff88';
        duration = 1.5;
        break;
      case 'lightning':
        const endX = x + (Math.random() - 0.5) * 100;
        const endY = y + (Math.random() - 0.5) * 100;
        path = createCanvasLightningPath(x, y, endX, endY, 6, 15);
        strokeColor = '#ffff00';
        duration = 0.8;
        strokeWidth = 2;
        break;
      case 'star':
        path = createCanvasStarPath(x, y, 25, 15, 5);
        strokeColor = '#ff6b6b';
        duration = 2;
        strokeWidth = 2;
        break;
      default:
        path = createCanvasCirclePath(x, y, 20);
        strokeColor = '#ffffff';
        duration = 1;
    }

    setDrawEffects(prev => [...prev, {
      id: effectId,
      path,
      active: true,
      duration,
      strokeColor,
      strokeWidth
    }]);

    setTimeout(() => {
      setDrawEffects(prev => prev.filter(effect => effect.id !== effectId));
    }, duration * 1000 + 100);
  }, [canvasRef]);

  return {
    drawEffects,
    triggerDrawEffect,
  };
};
</file>

<file path="packages/frontend/src/components/GameCanvas/managers/ParticleManager.ts">
import { useState, useCallback, useRef } from 'react';
import { Particle, updateParticles, addParticles } from '../../renderers/effects/ParticleSystem';
import { AnimationSettings } from 'shared';

interface ParticleManagerProps {
  animationSettings: AnimationSettings;
  onAddParticles?: (x: number, y: number, color: string, count?: number) => void;
}

export const useParticleManager = ({ animationSettings, onAddParticles }: ParticleManagerProps) => {
  const particlesRef = useRef<Particle[]>([]);

  const addParticlesToState = useCallback((x: number, y: number, color: string, count: number = 5) => {
    const newParticles = addParticles(x, y, color, count);
    particlesRef.current = [...particlesRef.current, ...newParticles];
    if (onAddParticles) {
      onAddParticles(x, y, color, count);
    }
  }, [onAddParticles]);

  // Update particles - this will be called from the main render loop
  const updateParticlesInState = useCallback(() => {
    if (animationSettings?.showParticles !== false) {
      particlesRef.current = updateParticles(particlesRef.current);
    }
  }, [animationSettings?.showParticles]);

  return {
    particles: particlesRef.current,
    addParticles: addParticlesToState,
    updateParticles: updateParticlesInState,
  };
};
</file>

<file path="packages/frontend/src/components/GameCanvas/managers/RegenerationManager.ts">
import { useState, useEffect } from 'react';
import { createCanvasCirclePath, createCanvasStarPath, createCanvasLightningPath } from '../../animations/CanvasDrawEffect';
import { GameWorld } from 'shared';

interface RegenerationEffect {
  id: string;
  x: number;
  y: number;
  type: 'circle' | 'star' | 'lightning';
  active: boolean;
}

interface RegenerationManagerProps {
  gameWorld: GameWorld | null;
  tileSizePx: number;
  grid: any[][] | null;
}

export const useRegenerationManager = ({ gameWorld, tileSizePx, grid }: RegenerationManagerProps) => {
  const [regenerationEffects, setRegenerationEffects] = useState<RegenerationEffect[]>([]);

  useEffect(() => {
    if (gameWorld?.phase === 'rebirth' && grid) {
      const effects: RegenerationEffect[] = [];
      const numEffects = Math.min(20, Math.floor((grid.length * (grid[0]?.length || 0)) / 50));

      for (let i = 0; i < numEffects; i++) {
        const x = Math.floor(Math.random() * (grid[0]?.length || 60));
        const y = Math.floor(Math.random() * grid.length);
        const types: ('circle' | 'star' | 'lightning')[] = ['circle', 'star', 'lightning'];
        const type = types[Math.floor(Math.random() * types.length)];

        effects.push({
          id: `regen-${i}-${Date.now()}`,
          x: x * tileSizePx + tileSizePx / 2,
          y: y * tileSizePx + tileSizePx / 2,
          type,
          active: true
        });
      }

      setRegenerationEffects(effects);

      const timer = setTimeout(() => {
        setRegenerationEffects([]);
      }, 5000);

      return () => clearTimeout(timer);
    }
  }, [gameWorld?.phase, grid, tileSizePx]);

  return { regenerationEffects };
};
</file>

<file path="packages/frontend/src/components/layout/AppHeader.tsx">
import React from 'react';
import { MaterialChip } from '../index';
import { useGameStore } from '../../stores/gameStore';
import { MODE_STYLES, SPACING, TYPOGRAPHY, COMMON_STYLES, Z_INDEX } from '../../utils/designSystem';

interface AppHeaderProps {
  mode: 'play' | 'spectate' | 'dev';
  children?: React.ReactNode;
}

const AppHeader: React.FC<AppHeaderProps> = ({ mode, children }) => {
  const { gameWorld } = useGameStore();
  const modeConfig = MODE_STYLES[mode];

  return (
    <header
      className="flex items-center justify-between px-4 py-2 border-b backdrop-blur-sm"
      style={{
        background: 'rgba(25, 23, 36, 0.9)',
        borderColor: 'rgba(196, 167, 231, 0.2)',
        height: 'var(--header-height)',
        zIndex: Z_INDEX.sticky,
      }}
    >
      {/* Left Section - Logo and Mode Info */}
      <div className="flex items-center gap-3">
        <h1
          className="m-0 font-extrabold text-2xl"
          style={{
            ...COMMON_STYLES.titleGradient,
            textShadow: '0 0 10px rgba(196, 167, 231, 0.5)',
          }}
        >
          ChatteRealm
        </h1>

        <span
          className="text-lg font-medium"
          style={{ color: 'var(--color-text-secondary)' }}
        >
          {modeConfig.headerIcon} {mode.charAt(0).toUpperCase() + mode.slice(1)} Mode
        </span>

        <MaterialChip
          label={`Phase: ${gameWorld?.phase || 'Unknown'}`}
          size="small"
          sx={{
            backgroundColor: 'rgba(76, 175, 80, 0.2)',
            color: 'var(--color-text-primary)',
            fontSize: TYPOGRAPHY.fontSize.xs,
          }}
        />
      </div>

      {/* Center Section - Custom Content */}
      {children && (
        <div className="flex items-center">
          {children}
        </div>
      )}

      {/* Right Section - Game Stats and Navigation */}
      <div className="flex items-center gap-2">
        <MaterialChip
          label={`${gameWorld?.players?.length || 0} Players`}
          size="small"
          sx={{
            backgroundColor: 'rgba(33, 150, 243, 0.2)',
            color: 'var(--color-text-primary)',
            fontSize: TYPOGRAPHY.fontSize.xs,
          }}
        />

        <MaterialChip
          label={`${gameWorld?.npcs?.length || 0} NPCs`}
          size="small"
          sx={{
            backgroundColor: 'rgba(156, 39, 176, 0.2)',
            color: 'var(--color-text-primary)',
            fontSize: TYPOGRAPHY.fontSize.xs,
          }}
        />

        {/* Mode-specific additional chips */}
        {mode === 'spectate' && (
          <MaterialChip
            label={`${gameWorld?.items?.length || 0} Items`}
            size="small"
            sx={{
              backgroundColor: 'rgba(255, 152, 0, 0.2)',
              color: 'var(--color-text-primary)',
              fontSize: TYPOGRAPHY.fontSize.xs,
            }}
          />
        )}

        {mode === 'dev' && (
          <>
            <MaterialChip
              label={`${gameWorld?.items?.length || 0} Items`}
              size="small"
              sx={{
                backgroundColor: 'rgba(255, 152, 0, 0.2)',
                color: 'var(--color-text-primary)',
                fontSize: TYPOGRAPHY.fontSize.xs,
              }}
            />
            <MaterialChip
              label="DEV"
              size="small"
              sx={{
                backgroundColor: 'rgba(244, 67, 54, 0.2)',
                color: 'var(--color-text-primary)',
                fontWeight: TYPOGRAPHY.fontWeight.bold,
                fontSize: TYPOGRAPHY.fontSize.xs,
              }}
            />
          </>
        )}
      </div>
    </header>
  );
};

export default AppHeader;
</file>

<file path="packages/frontend/src/components/layout/GameLegend.tsx">
import React from 'react';
import { MaterialChip, MaterialPaper } from '../index';
import { Z_INDEX, TYPOGRAPHY, COMMON_STYLES } from '../../utils/designSystem';

interface GameLegendProps {
  position?: 'bottom' | 'top' | 'left' | 'right';
  className?: string;
}

const GameLegend: React.FC<GameLegendProps> = ({
  position = 'bottom',
  className = ''
}) => {
  const legendItems = [
    { label: 'Knight', color: 'var(--color-legend-knight)' },
    { label: 'Rogue', color: 'var(--color-legend-rogue)' },
    { label: 'Mage', color: 'var(--color-legend-mage)' },
    { label: 'NPC', color: 'var(--color-legend-npc)' },
    { label: 'Item', color: 'var(--color-legend-item)' },
  ];

  const positionStyles = {
    bottom: {
      bottom: '20px',
      left: '50%',
      transform: 'translateX(-50%)',
    },
    top: {
      top: '20px',
      left: '50%',
      transform: 'translateX(-50%)',
    },
    left: {
      top: '50%',
      left: '20px',
      transform: 'translateY(-50%)',
    },
    right: {
      top: '50%',
      right: '20px',
      transform: 'translateY(-50%)',
    },
  };

  return (
    <MaterialPaper
      className={`game-legend ${className}`}
      sx={{
        position: 'absolute',
        display: 'flex',
        gap: 1,
        p: 1,
        zIndex: Z_INDEX.fixed,
        ...COMMON_STYLES.glass,
        ...positionStyles[position],
      }}
    >
      {legendItems.map((item) => (
        <MaterialChip
          key={item.label}
          label={item.label}
          size="small"
          sx={{
            backgroundColor: item.color,
            color: 'white',
            fontSize: TYPOGRAPHY.fontSize.xs,
            height: '20px',
            '& .MuiChip-label': {
              px: 1,
            },
          }}
        />
      ))}
    </MaterialPaper>
  );
};

export default GameLegend;
</file>

<file path="packages/frontend/src/components/layout/index.ts">
export { default as AppHeader } from './AppHeader';
export { default as BaseLayout } from './BaseLayout';
</file>

<file path="packages/frontend/src/components/layout/ResponsiveLayout.tsx">
import React, { useState, useEffect } from 'react';

interface ResponsiveLayoutProps {
  children: React.ReactNode;
}

interface BreakpointInfo {
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
  screenWidth: number;
}

export const useResponsive = (): BreakpointInfo => {
  const [breakpoint, setBreakpoint] = useState<BreakpointInfo>({
    isMobile: false,
    isTablet: false,
    isDesktop: true,
    screenWidth: 1200
  });

  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      setBreakpoint({
        isMobile: width < 768,
        isTablet: width >= 768 && width < 1024,
        isDesktop: width >= 1024,
        screenWidth: width
      });
    };

    // Initial check
    handleResize();

    // Add event listener
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return breakpoint;
};

const ResponsiveLayout: React.FC<ResponsiveLayoutProps> = ({ children }) => {
  const { isMobile, isTablet } = useResponsive();

  return (
    <div className={`responsive-layout ${isMobile ? 'mobile' : isTablet ? 'tablet' : 'desktop'}`}>
      {children}
    </div>
  );
};

export default ResponsiveLayout;
</file>

<file path="packages/frontend/src/components/layouts/DevRouteWrapper.tsx">
import React from 'react';
import DevLayout from './DevLayout';

const DevRouteWrapper: React.FC<{ children?: React.ReactNode }> = ({ children }) => {
  return (
    <DevLayout>
      {/* DevLayout wasn't originally accepting children; this wrapper will just render children below the header */}
      <div style={{ position: 'absolute', top: 120, left: 24, right: 24, bottom: 24, overflow: 'auto', zIndex: 1100 }}>
        {children}
      </div>
    </DevLayout>
  );
};

export default DevRouteWrapper;
</file>

<file path="packages/frontend/src/components/notifications/NotificationContainer.tsx">
import React from 'react';
import NotificationItem from './NotificationItem';
import { NotificationData } from '../../types/notification';

interface NotificationContainerProps {
  notifications: NotificationData[];
  onDismiss: (id: string) => void;
}

const NotificationContainer: React.FC<NotificationContainerProps> = ({ 
  notifications, 
  onDismiss 
}) => {
  return (
    <div className="notification-system">
      {notifications.map(notification => (
        <NotificationItem
          key={notification.id}
          notification={notification}
          onDismiss={onDismiss}
        />
      ))}
    </div>
  );
};

export default NotificationContainer;
</file>

<file path="packages/frontend/src/components/notifications/NotificationItem.tsx">
import React, { useEffect, useState } from 'react';
import { gsap } from 'gsap';
import { NotificationData, NotificationType, NotificationAction } from '../../types/notification';
import { getNotificationStyle } from '../../utils/notification/NotificationStyles'; // Will be created later

interface NotificationItemProps {
  notification: NotificationData;
  onDismiss: (id: string) => void;
}

const NotificationItem: React.FC<NotificationItemProps> = ({ 
  notification, 
  onDismiss 
}) => {
  const notificationRef = React.useRef<HTMLDivElement>(null);
  const progressRef = React.useRef<HTMLDivElement>(null);
  const [isVisible, setIsVisible] = useState(false);

  const style = getNotificationStyle(notification.type);
  const displayIcon = notification.icon || style.icon;
  const duration = notification.duration || 4000;

  useEffect(() => {
    const element = notificationRef.current;
    const progress = progressRef.current;
    
    if (!element || !progress) return;

    // Animation timeline
    const tl = gsap.timeline();

    // Slide in from right
    tl.fromTo(element, 
      { 
        x: 300, 
        opacity: 0, 
        scale: 0.8 
      },
      { 
        x: 0, 
        opacity: 1, 
        scale: 1,
        duration: 0.5,
        ease: "back.out(1.7)"
      }
    );

    // Progress bar animation
    if (!notification.persistent) {
      tl.fromTo(progress,
        { width: '100%' },
        {
          width: '0%',
          duration: duration / 1000,
          ease: "none",
          onComplete: () => {
            handleDismiss();
          }
        },
        0.3 // Start slightly after slide-in
      );
    }

    setIsVisible(true);

    return () => {
      tl.kill();
    };
  }, [notification, duration]);

  const handleDismiss = () => {
    const element = notificationRef.current;
    if (!element) return;

    // Slide out animation
    gsap.to(element, {
      x: 300,
      opacity: 0,
      scale: 0.8,
      duration: 0.3,
      ease: "back.in(1.7)",
      onComplete: () => {
        onDismiss(notification.id);
      }
    });
  };

  const handleActionClick = (action: NotificationAction) => {
    action.action();
    if (!notification.persistent) {
      handleDismiss();
    }
  };

  return (
    <div
      ref={notificationRef}
      className="notification-item rounded-md shadow-md overflow-hidden max-w-sm w-full mb-3"
      style={{ background: style.background, border: style.border }}
    >
      <div className="notification-content p-3">
        <div className="notification-header flex items-start gap-3">
          <div className="notification-icon text-xl">{displayIcon}</div>
          <div className="notification-text flex-1">
            <h4 className="notification-title text-text-primary font-semibold text-sm m-0">{notification.title}</h4>
            <p className="notification-message text-text-secondary text-sm m-0">{notification.message}</p>
          </div>
          <button 
            className="notification-close text-text-secondary text-lg p-1"
            onClick={handleDismiss}
            aria-label="Dismiss notification"
          >
            Ã—
          </button>
        </div>
        
        {notification.actions && notification.actions.length > 0 && (
          <div className="notification-actions mt-3 flex gap-2">
            {notification.actions.map((action: NotificationAction, index: number) => (
              <button
                key={index}
                className={`notification-action-btn px-3 py-1 rounded-md text-sm ${action.style === 'primary' ? 'bg-primary text-on-primary' : 'bg-transparent border border-divider text-text-primary'}`}
                onClick={() => handleActionClick(action)}
              >
                {action.label}
              </button>
            ))}
          </div>
        )}
      </div>
      
      {!notification.persistent && (
        <div className="notification-progress h-1 bg-[rgba(0,0,0,0.08)]">
          <div ref={progressRef} className="notification-progress-bar h-1 bg-primary w-full"></div>
        </div>
      )}
    </div>
  );
};

export default NotificationItem;
</file>

<file path="packages/frontend/src/components/player/ExperienceBar.tsx">
import React from 'react';
import { ExperienceBarProps } from '../../types/playerStatus';

export const ExperienceBar: React.FC<ExperienceBarProps> = ({ currentExperience, level }) => {
  // This is simplified. In a real game, maxExperience for a level would be needed.
  const experiencePercentage = (currentExperience / 100) * 100;

  return (
    <div className="relative w-full h-3 rounded-md bg-[var(--color-surface-variant)] overflow-hidden">
      <div className="absolute left-0 top-0 h-full bg-[var(--color-accent)]" style={{ width: `${experiencePercentage}%` }} />
      <span className="absolute left-2 top-1/2 -translate-y-1/2 text-xs text-[var(--color-text-secondary)]">LVL {level} - EXP {currentExperience}/100</span>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/player/HealthBar.tsx">
import React from 'react';
import { HealthBarProps } from '../../types/playerStatus';
import { calculateHealthStatus } from '../../utils/player/StatusUtils'; // Adjusted import path

export const HealthBar: React.FC<HealthBarProps> = ({ currentHealth, maxHealth }) => {
  const healthPercentage = (currentHealth / maxHealth) * 100;
  const healthStatus = calculateHealthStatus(healthPercentage); // Uses the new utility function

  return (
    <div className="relative w-full h-4 rounded-md bg-[var(--color-surface-variant)] overflow-hidden">
      <div
        className={`absolute left-0 top-0 h-full rounded-md health-status-${healthStatus} bg-[var(--color-health)]`}
        style={{ width: `${healthPercentage}%` }}
      />
      <span className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 text-xs text-[var(--color-text-primary)]">{currentHealth}/{maxHealth}</span>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/player/PlayerStatus.tsx">
import React from 'react';
import { PlayerStatusComponentProps } from '../../types/playerStatus';
import { HealthBar } from './HealthBar';
import { ExperienceBar } from './ExperienceBar';
import { StatusEffects } from './StatusEffects';
import { StatusDetails } from './StatusDetails';

export const PlayerStatus: React.FC<PlayerStatusComponentProps> = ({ stats, effects, player }) => {
  return (
    <div className="player-status">
      <h3>{player.name}</h3>
      <HealthBar currentHealth={stats.health} maxHealth={stats.maxHealth} />
      <ExperienceBar currentExperience={stats.experience} level={stats.level} />
      <StatusEffects effects={effects} />
      <StatusDetails stats={stats} />
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/player/StatusDetails.tsx">
import React from 'react';
import { PlayerStats } from '../../types/playerStatus';

export interface StatusDetailsProps {
  stats: PlayerStats;
}

export const StatusDetails: React.FC<StatusDetailsProps> = ({ stats }) => {
  return (
    <div className="status-details">
      <p>Mana: {stats.mana}/{stats.maxMana}</p>
      <p>Stamina: {stats.stamina}/{stats.maxStamina}</p>
      <p>Hunger: {stats.hunger}</p>
      <p>Thirst: {stats.thirst}</p>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/player/StatusEffects.tsx">
import React from 'react';
import { PlayerEffect } from '../../types/playerStatus';
import { getEffectDescription } from '../../utils/player/EffectUtils'; // Adjusted import path

export interface StatusEffectsProps {
  effects: PlayerEffect[];
}

export const StatusEffects: React.FC<StatusEffectsProps> = ({ effects }) => {
  return (
    <div className="status-effects">
      <h4>Effects:</h4>
      {effects.length === 0 ? (
        <p>No active effects.</p>
      ) : (
        <ul>
          {effects.map((effect, index) => (
            <li key={index}>
              {getEffectDescription(effect)}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/renderers/canvas/CanvasUtils.ts">
// Draw backdrop using CSS pixel dimensions so it's not affected by any DPR
// transform applied on the context by the caller.
export const setupCanvas = (
  canvas: HTMLCanvasElement,
  ctx: CanvasRenderingContext2D,
  numTilesX: number,
  numTilesY: number,
  gridSize: number,
  cssWidth: number,
  cssHeight: number
) => {
  // Clear backing buffer first
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw background using CSS coordinates. Temporarily reset transform to
  // identity so our CSS-based gradient and fill aren't scaled by DPR.
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  const bgGradient = ctx.createLinearGradient(0, 0, cssWidth, cssHeight);
  bgGradient.addColorStop(0, '#191724');
  bgGradient.addColorStop(1, '#1f1d2e');
  ctx.fillStyle = bgGradient;
  ctx.fillRect(0, 0, cssWidth, cssHeight);

  ctx.restore();
};
</file>

<file path="packages/frontend/src/components/renderers/canvas/GridRenderer.ts">
export const drawAnimatedGridLines = (rc: any, numTilesX: number, numTilesY: number, gridSize: number, time: number) => {
  const pulseIntensity = 0.6 + Math.sin(time * 0.015) * 0.2; // Slightly faster pulsing

  // Draw grid lines with subtle animation
  for (let x = 0; x <= numTilesX; x++) {
    rc.line(x * gridSize, 0, x * gridSize, numTilesY * gridSize, {
      stroke: `rgba(255, 255, 255, ${0.1 + pulseIntensity * 0.15})`, // More visible pulsing
      strokeWidth: 2 // Thicker
    });
  }
  for (let y = 0; y <= numTilesY; y++) {
    rc.line(0, y * gridSize, numTilesX * gridSize, y * gridSize, {
      stroke: `rgba(255, 255, 255, ${0.1 + pulseIntensity * 0.15})`,
      strokeWidth: 2
    });
  }
};
</file>

<file path="packages/frontend/src/components/renderers/canvas/RenderCoordinator.ts">
import type { Player, Item } from 'shared';
import { BiomeType, AnimationSettings } from 'shared';
import { GAME_CONFIG } from 'shared';
import { BiomeIdentificationService } from '../../../services/BiomeIdentificationService';
import { BiomeRenderer } from '../BiomeRenderer';
import { drawAnimatedItem } from '../entities/ItemRenderer';
import { drawAnimatedNPC } from '../entities/NPCRenderer';
import { drawAnimatedPlayer } from '../entities/PlayerRenderer';
import { drawAnimatedBuilding } from '../entities/BuildingRenderer';
import { drawEffects } from '../effects/EffectRenderer';
import { drawAnimatedGridLines } from './GridRenderer';
import { Particle } from '../effects/ParticleSystem';

export interface ParticleEmitter {
  (x: number, y: number, color: string, count?: number): void;
}

export const renderGame = (
  rc: any,
  ctx: CanvasRenderingContext2D,
  grid: { type: BiomeType }[][],
  players: Player[],
  npcs: any[],
  items: Item[],
  buildings: any[],
  showGrid: boolean,
  time: number,
  animationSettings: AnimationSettings,
  currentParticles: Particle[],
  addParticlesFn: ParticleEmitter,
  tileSize: number = GAME_CONFIG.tileSize, // Use shared tile size constant as fallback
  nightMode: boolean = false
) => {
  const gridSize = tileSize; // Use the passed tileSize parameter
  const numTilesX = grid[0]?.length || 20;
  const numTilesY = grid.length || 15;

  // Calculate rendered dimensions
  const renderedWidth = numTilesX * gridSize;
  const renderedHeight = numTilesY * gridSize;

  const biomeIdentificationService = new BiomeIdentificationService();
  const biomeRenderer = new BiomeRenderer(rc);

  // Clear the entire canvas first to prevent ghost frames
  // Clear the logical rendering area (accounting for transforms)
  ctx.clearRect(-gridSize, -gridSize, renderedWidth + 2 * gridSize, renderedHeight + 2 * gridSize);

  // Identify and render biomes
  const biomes = biomeIdentificationService.identifyBiomeRegions(grid);
  biomeRenderer.setAnimationFrame(time);
  biomes.forEach(biome => {
    biomeRenderer.drawBiome(biome, tileSize);
  });

  // Draw animated buildings
  buildings.forEach(async building => {
    try {
      await drawAnimatedBuilding(rc, building.position.x, building.position.y, gridSize, building, time, animationSettings.seed);
    } catch (error) {
      console.warn('Failed to render building:', error);
    }
  });

  // Draw animated items with floating effect
  items.forEach(item => {
    if (item.position) {
      drawAnimatedItem(rc, item.position.x, item.position.y, gridSize, item, time, animationSettings.seed);
    }
  });

  // Draw animated NPCs with movement
  npcs.forEach(npc => {
    if (npc.isAlive) {
      drawAnimatedNPC(rc, npc.position.x, npc.position.y, gridSize, time, animationSettings.seed);
    }
  });

  // Draw animated players with special effects
  players.forEach(async player => {
    if (player.isAlive) {
      try {
        await drawAnimatedPlayer(rc, player.position.x, player.position.y, gridSize, player, time, addParticlesFn, animationSettings.seed);
      } catch (error) {
        console.warn('Failed to render player:', error);
        // Fallback to basic rendering if emoji fails
        const centerX = player.position.x * gridSize + gridSize / 2;
        const centerY = player.position.y * gridSize + gridSize / 2;
        rc.circle(centerX, centerY, 12, {
          fill: '#FFD700',
          fillStyle: 'solid',
          stroke: '#FFF',
          strokeWidth: 2,
          roughness: 1
        });
      }
    }
  });

  // Draw animated particles
  drawEffects(ctx, currentParticles);

  // Subtle environmental overlays: moving cloud shadows and light shafts
  // These are intentionally low-cost and low-opacity so they remain atmospheric.

  const drawCloudShadows = () => {
    ctx.save();
    // Soft multiply so shadows darken underlying colors
    ctx.globalCompositeOperation = 'multiply';

    // Parameters tuned for subtlety
    const baseAlpha = 0.06;
    const cloudCount = 3; // few, large clouds

    for (let i = 0; i < cloudCount; i++) {
      const speed = 0.02 + i * 0.005; // Slower cloud movement
      const cx = ((time * speed * 60) % (renderedWidth * 2)) - renderedWidth * 0.5 + i * 120;
      const cy = renderedHeight * (0.2 + (i * 0.15));
      const rx = renderedWidth * (0.6 - i * 0.12);
      const ry = renderedHeight * (0.35 - i * 0.08);

      // Create radial gradient for a soft cloud
      const g = ctx.createRadialGradient(cx, cy, Math.min(10, ry * 0.05), cx, cy, Math.max(rx, ry));
      // center is transparent darker (to allow underlying highlights), edges are slightly darker
      g.addColorStop(0, `rgba(0,0,0,${baseAlpha * 0.25})`);
      g.addColorStop(0.5, `rgba(0,0,0,${baseAlpha * 0.75})`);
      g.addColorStop(1, `rgba(0,0,0,0)`);

      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  };

  const drawLightShafts = () => {
    ctx.save();
    // Very subtle additive shafts to emulate sun filtering through foliage
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.06 * (0.7 + 0.3 * Math.sin(time * 0.002)); // Much slower, gentler pulsing

    // Draw 2 diagonal thin shafts
    for (let i = 0; i < 2; i++) {
      const shaftWidth = renderedWidth * 0.15; // Slightly wider shafts
      const pos = (time * 0.01 + i * 0.5) % (renderedWidth + renderedHeight) - (renderedHeight * 0.5); // Slower movement

      // create gradient along the shaft
      const g = ctx.createLinearGradient(-renderedHeight, pos, renderedWidth, pos + renderedHeight);
      g.addColorStop(0, 'rgba(255,255,255,0)');
      g.addColorStop(0.45, 'rgba(255,255,230,0.06)');
      g.addColorStop(0.55, 'rgba(255,255,230,0.02)');
      g.addColorStop(1, 'rgba(255,255,255,0)');

      ctx.fillStyle = g;
      // rotate the context slightly to make shafts diagonal
      ctx.translate(0, 0);
      ctx.beginPath();
      ctx.rect(-renderedHeight, pos - shaftWidth / 2, renderedWidth + renderedHeight * 2, shaftWidth);
      ctx.fill();
    }

    ctx.restore();
  };

  // Draw overlays after particles but before grid lines so grid remains crisp
  try {
    drawCloudShadows();
    drawLightShafts();
  } catch (e) {
    // Swallow any drawing errors to avoid interfering with main render loop
    // eslint-disable-next-line no-console
    console.warn('Render overlay error', e);
  }

  // Apply night mode overlay if enabled
  if (nightMode) {
    ctx.save();
    // Use overlay blend mode for better color mixing with purple tint
    ctx.globalCompositeOperation = 'overlay';
    ctx.fillStyle = 'rgba(30, 15, 45, 0.8)'; // Dark purple overlay
    ctx.fillRect(0, 0, renderedWidth, renderedHeight);

    // Add a second pass with multiply for deeper darkness
    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = 'rgba(25, 20, 35, 0.6)'; // Additional dark purple multiply
    ctx.fillRect(0, 0, renderedWidth, renderedHeight);

    ctx.restore();
  }

  // Draw animated grid lines with subtle pulsing
  if (showGrid) {
    drawAnimatedGridLines(rc, numTilesX, numTilesY, gridSize, time);
  }
};
</file>

<file path="packages/frontend/src/components/renderers/canvas/tmp.txt">
22:23:21.078 Global.ts:72  * Tone.js v14.7.77 * 
22:23:21.080 AudioContext.ts:13 [Deprecation] The ScriptProcessorNode is deprecated. Use AudioWorkletNode instead. (https://bit.ly/audio-worklet)
(anonymous) @ test-audio-node-disconnect-method-support.js:3
rt @ test-audio-node-disconnect-method-support.js:2
(anonymous) @ audio-node-constructor.js:161
(anonymous) @ cache-test-result.js:12
(anonymous) @ audio-node-constructor.js:160
(anonymous) @ audio-destination-node-constructor.js:8
(anonymous) @ minimal-base-audio-context-constructor.js:11
(anonymous) @ base-audio-context-constructor.js:4
(anonymous) @ audio-context-constructor.js:22
(anonymous) @ AudioContext.ts:13
Gi @ Context.ts:120
Ji @ Global.ts:26
(anonymous) @ index.ts:33
s @ bootstrap:19
(anonymous) @ bootstrap:83
(anonymous) @ Tone.js:1
(anonymous) @ universalModuleDefinition:9
(anonymous) @ universalModuleDefinition:1
22:23:21.081 AudioContext.ts:13 The AudioContext was not allowed to start. It must be resumed (or created) after a user gesture on the page. https://developer.chrome.com/blog/autoplay/#web_audio
(anonymous) @ test-audio-node-disconnect-method-support.js:30
rt @ test-audio-node-disconnect-method-support.js:2
(anonymous) @ audio-node-constructor.js:161
(anonymous) @ cache-test-result.js:12
(anonymous) @ audio-node-constructor.js:160
(anonymous) @ audio-destination-node-constructor.js:8
(anonymous) @ minimal-base-audio-context-constructor.js:11
(anonymous) @ base-audio-context-constructor.js:4
(anonymous) @ audio-context-constructor.js:22
(anonymous) @ AudioContext.ts:13
Gi @ Context.ts:120
Ji @ Global.ts:26
(anonymous) @ index.ts:33
s @ bootstrap:19
(anonymous) @ bootstrap:83
(anonymous) @ Tone.js:1
(anonymous) @ universalModuleDefinition:9
(anonymous) @ universalModuleDefinition:1
22:23:21.083 Context.ts:196 The AudioContext was not allowed to start. It must be resumed (or created) after a user gesture on the page. https://developer.chrome.com/blog/autoplay/#web_audio
ae @ test-audio-scheduled-source-node-start-method-negative-parameters-support.js:4
(anonymous) @ native-constant-source-node-factory.js:15
(anonymous) @ cache-test-result.js:12
(anonymous) @ native-constant-source-node-factory.js:15
(anonymous) @ constant-source-node-constructor.js:16
createConstantSource @ base-audio-context-constructor.js:37
createConstantSource @ Context.ts:196
Ao @ ToneConstantSource.ts:27
Do @ Signal.ts:67
Eo @ TickSignal.ts:38
Ro @ TickSource.ts:53
qo @ Clock.ts:84
Yo @ Transport.ts:172
(anonymous) @ Transport.ts:725
(anonymous) @ ContextInitialization.ts:24
initialize @ ContextInitialization.ts:24
get transport @ Context.ts:301
(anonymous) @ index.ts:33
s @ bootstrap:19
(anonymous) @ bootstrap:83
(anonymous) @ Tone.js:1
(anonymous) @ universalModuleDefinition:9
(anonymous) @ universalModuleDefinition:1
22:23:21.083 ToneConstantSource.ts:73 The AudioContext was not allowed to start. It must be resumed (or created) after a user gesture on the page. https://developer.chrome.com/blog/autoplay/#web_audio
start @ constant-source-node-constructor.js:42
start @ ToneConstantSource.ts:73
Do @ Signal.ts:75
Eo @ TickSignal.ts:38
Ro @ TickSource.ts:53
qo @ Clock.ts:84
Yo @ Transport.ts:172
(anonymous) @ Transport.ts:725
(anonymous) @ ContextInitialization.ts:24
initialize @ ContextInitialization.ts:24
get transport @ Context.ts:301
(anonymous) @ index.ts:33
s @ bootstrap:19
(anonymous) @ bootstrap:83
(anonymous) @ Tone.js:1
(anonymous) @ universalModuleDefinition:9
(anonymous) @ universalModuleDefinition:1
22:23:21.104 client:789 [vite] connecting...
22:23:21.524 chunk-3LBSCF6M.js?v=439028ad:21609 Download the React DevTools for a better development experience: https://reactjs.org/link/react-devtools
22:23:21.695 react-router-dom.js?v=439028ad:4393 âš ï¸ React Router Future Flag Warning: React Router will begin wrapping state updates in `React.startTransition` in v7. You can use the `v7_startTransition` future flag to opt-in early. For more information, see https://reactrouter.com/v6/upgrading/future#v7_starttransition.
warnOnce @ react-router-dom.js?v=439028ad:4393
logDeprecation @ react-router-dom.js?v=439028ad:4396
logV6DeprecationWarnings @ react-router-dom.js?v=439028ad:4399
(anonymous) @ react-router-dom.js?v=439028ad:5271
commitHookEffectListMount @ chunk-3LBSCF6M.js?v=439028ad:16963
commitPassiveMountOnFiber @ chunk-3LBSCF6M.js?v=439028ad:18206
commitPassiveMountEffects_complete @ chunk-3LBSCF6M.js?v=439028ad:18179
commitPassiveMountEffects_begin @ chunk-3LBSCF6M.js?v=439028ad:18169
commitPassiveMountEffects @ chunk-3LBSCF6M.js?v=439028ad:18159
flushPassiveEffectsImpl @ chunk-3LBSCF6M.js?v=439028ad:19543
flushPassiveEffects @ chunk-3LBSCF6M.js?v=439028ad:19500
(anonymous) @ chunk-3LBSCF6M.js?v=439028ad:19381
workLoop @ chunk-3LBSCF6M.js?v=439028ad:197
flushWork @ chunk-3LBSCF6M.js?v=439028ad:176
performWorkUntilDeadline @ chunk-3LBSCF6M.js?v=439028ad:384
22:23:21.695 react-router-dom.js?v=439028ad:4393 âš ï¸ React Router Future Flag Warning: Relative route resolution within Splat routes is changing in v7. You can use the `v7_relativeSplatPath` future flag to opt-in early. For more information, see https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath.
warnOnce @ react-router-dom.js?v=439028ad:4393
logDeprecation @ react-router-dom.js?v=439028ad:4396
logV6DeprecationWarnings @ react-router-dom.js?v=439028ad:4402
(anonymous) @ react-router-dom.js?v=439028ad:5271
commitHookEffectListMount @ chunk-3LBSCF6M.js?v=439028ad:16963
commitPassiveMountOnFiber @ chunk-3LBSCF6M.js?v=439028ad:18206
commitPassiveMountEffects_complete @ chunk-3LBSCF6M.js?v=439028ad:18179
commitPassiveMountEffects_begin @ chunk-3LBSCF6M.js?v=439028ad:18169
commitPassiveMountEffects @ chunk-3LBSCF6M.js?v=439028ad:18159
flushPassiveEffectsImpl @ chunk-3LBSCF6M.js?v=439028ad:19543
flushPassiveEffects @ chunk-3LBSCF6M.js?v=439028ad:19500
(anonymous) @ chunk-3LBSCF6M.js?v=439028ad:19381
workLoop @ chunk-3LBSCF6M.js?v=439028ad:197
flushWork @ chunk-3LBSCF6M.js?v=439028ad:176
performWorkUntilDeadline @ chunk-3LBSCF6M.js?v=439028ad:384
22:23:21.703 useContainerResize.ts:20 ContainerResize: {width: 1108, height: 158}
22:23:21.704 client:912 [vite] connected.
22:23:22.458 webSocketClient.ts:35 WebSocket connection to 'ws://localhost:3001/socket.io/?EIO=4&transport=websocket' failed: 
createSocket @ socket__io-client.js?v=439028ad:1059
doOpen @ socket__io-client.js?v=439028ad:986
open @ socket__io-client.js?v=439028ad:503
_open @ socket__io-client.js?v=439028ad:1328
_SocketWithoutUpgrade @ socket__io-client.js?v=439028ad:1289
SocketWithUpgrade @ socket__io-client.js?v=439028ad:1633
Socket @ socket__io-client.js?v=439028ad:1759
open @ socket__io-client.js?v=439028ad:3125
Manager @ socket__io-client.js?v=439028ad:3057
lookup2 @ socket__io-client.js?v=439028ad:3393
connect @ webSocketClient.ts:35
WebSocketClient @ webSocketClient.ts:27
getInstance @ webSocketClient.ts:354
(anonymous) @ webSocketClient.ts:361
22:23:22.459 loggingUtils.ts:35 [WS_CONNECT_ERROR] Connection error: websocket error
log @ loggingUtils.ts:35
throttledError @ loggingUtils.ts:103
(anonymous) @ webSocketClient.ts:83
Emitter.emit @ socket__io-client.js?v=439028ad:354
onerror @ socket__io-client.js?v=439028ad:2560
Emitter.emit @ socket__io-client.js?v=439028ad:354
onError @ socket__io-client.js?v=439028ad:3137
Emitter.emit @ socket__io-client.js?v=439028ad:354
_onError @ socket__io-client.js?v=439028ad:1597
Emitter.emit @ socket__io-client.js?v=439028ad:354
onError @ socket__io-client.js?v=439028ad:495
ws.onerror @ socket__io-client.js?v=439028ad:1010
22:23:23.598 socket__io-client.js?v=439028ad:1059 WebSocket connection to 'ws://localhost:3001/socket.io/?EIO=4&transport=websocket' failed: 
createSocket @ socket__io-client.js?v=439028ad:1059
doOpen @ socket__io-client.js?v=439028ad:986
open @ socket__io-client.js?v=439028ad:503
_open @ socket__io-client.js?v=439028ad:1328
_SocketWithoutUpgrade @ socket__io-client.js?v=439028ad:1289
SocketWithUpgrade @ socket__io-client.js?v=439028ad:1633
Socket @ socket__io-client.js?v=439028ad:1759
open @ socket__io-client.js?v=439028ad:3125
(anonymous) @ socket__io-client.js?v=439028ad:3343
22:23:25.940 socket__io-client.js?v=439028ad:1059 WebSocket connection to 'ws://localhost:3001/socket.io/?EIO=4&transport=websocket' failed: 
createSocket @ socket__io-client.js?v=439028ad:1059
doOpen @ socket__io-client.js?v=439028ad:986
open @ socket__io-client.js?v=439028ad:503
_open @ socket__io-client.js?v=439028ad:1328
_SocketWithoutUpgrade @ socket__io-client.js?v=439028ad:1289
SocketWithUpgrade @ socket__io-client.js?v=439028ad:1633
Socket @ socket__io-client.js?v=439028ad:1759
open @ socket__io-client.js?v=439028ad:3125
(anonymous) @ socket__io-client.js?v=439028ad:3343
22:23:30.661 socket__io-client.js?v=439028ad:1059 WebSocket connection to 'ws://localhost:3001/socket.io/?EIO=4&transport=websocket' failed: 
createSocket @ socket__io-client.js?v=439028ad:1059
doOpen @ socket__io-client.js?v=439028ad:986
open @ socket__io-client.js?v=439028ad:503
_open @ socket__io-client.js?v=439028ad:1328
_SocketWithoutUpgrade @ socket__io-client.js?v=439028ad:1289
SocketWithUpgrade @ socket__io-client.js?v=439028ad:1633
Socket @ socket__io-client.js?v=439028ad:1759
open @ socket__io-client.js?v=439028ad:3125
(anonymous) @ socket__io-client.js?v=439028ad:3343
22:23:30.662 loggingUtils.ts:48 [WS_CONNECT_ERROR] [3 suppressed] Connection error: websocket error
log @ loggingUtils.ts:48
throttledError @ loggingUtils.ts:103
(anonymous) @ webSocketClient.ts:83
Emitter.emit @ socket__io-client.js?v=439028ad:354
onerror @ socket__io-client.js?v=439028ad:2560
Emitter.emit @ socket__io-client.js?v=439028ad:354
onError @ socket__io-client.js?v=439028ad:3137
Emitter.emit @ socket__io-client.js?v=439028ad:354
_onError @ socket__io-client.js?v=439028ad:1597
Emitter.emit @ socket__io-client.js?v=439028ad:354
onError @ socket__io-client.js?v=439028ad:495
ws.onerror @ socket__io-client.js?v=439028ad:1010
</file>

<file path="packages/frontend/src/components/renderers/effects/AnimationUtils.ts">
export const getFloatOffset = (time: number, x: number, y: number, amplitude: number = 2, frequency: number = 0.05): number => {
  return Math.sin(time * frequency + x + y) * amplitude;
};

export const getPulseScale = (time: number, baseScale: number = 1, amplitude: number = 0.05, frequency: number = 0.1): number => {
  return baseScale + Math.sin(time * frequency) * amplitude;
};

export const getWindOffset = (time: number, x: number, y: number, amplitude: number = 2.5, frequency: number = 0.02): number => {
  return Math.sin(time * frequency + x + y) * amplitude;
};

export const getWaveOffset = (time: number, x: number, w: number, amplitude: number = 2, frequency: number = 0.08): number => {
  return Math.sin(time * frequency + x * 0.5 + w) * amplitude;
};

export const getCurrentOffset = (time: number, y: number, amplitude: number = 3, frequency: number = 0.12): number => {
  return Math.sin(time * frequency + y) * amplitude;
};

export const getSwayOffset = (time: number, x: number, t: number, amplitude: number = 2, frequency: number = 0.03): number => {
  return Math.sin(time * frequency + x + t) * amplitude;
};
</file>

<file path="packages/frontend/src/components/renderers/effects/EffectRenderer.ts">
import { drawParticles, Particle } from './ParticleSystem';

export const drawEffects = (ctx: CanvasRenderingContext2D, particles: Particle[]) => {
  drawParticles(ctx, particles);
  // Additional effects logic can be added here
};
</file>

<file path="packages/frontend/src/components/renderers/effects/ParticleSystem.ts">
export interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  color: string;
  size: number;
}

export const addParticles = (x: number, y: number, color: string, count: number = 5): Particle[] => {
  const newParticles: Particle[] = [];
  for (let i = 0; i < count; i++) {
    newParticles.push({
      x: x + (Math.random() - 0.5) * 20,
      y: y + (Math.random() - 0.5) * 20,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      life: 30,
      maxLife: 30,
      color,
      size: Math.random() * 3 + 1
    });
  }
  return newParticles;
};

export const updateParticles = (prevParticles: Particle[]): Particle[] => {
  return prevParticles
    .map(p => ({
      ...p,
      x: p.x + p.vx,
      y: p.y + p.vy,
      life: p.life - 1,
      vy: p.vy + 0.1 // gravity
    }))
    .filter(p => p.life > 0);
};

export const drawParticles = (ctx: CanvasRenderingContext2D, particles: Particle[]) => {
  particles.forEach(particle => {
    // Use ease-out quadratic for smoother fade
    const lifeRatio = particle.life / particle.maxLife;
    const alpha = lifeRatio * lifeRatio; // quadratic ease-out
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = particle.color;
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
};
</file>

<file path="packages/frontend/src/components/renderers/entities/BuildingRenderer.ts">
import type { Building } from 'shared';
import { assetConverter } from '../../../services/assetConverter';

// Cache for building emoji SVGs
const buildingEmojiCache = new Map<string, { svg: string; lastUsed: number }>();

// Render a building with animated emoji
export const drawAnimatedBuilding = async (rc: any, x: number, y: number, gridSize: number, building: Building, time: number, seed?: number) => {
  const centerX = x * gridSize + gridSize / 2;
  const centerY = y * gridSize + gridSize / 2;
  const ctx = (rc as any).ctx;

  // Priority 1: Use pre-generated roughSvg if available
  if (building.roughSvg) {
    try {
      const converted = await assetConverter.convertSvgToCanvas(building.roughSvg, {
        roughness: 1.0 + Math.sin(time * 0.02) * 0.2,
        bowing: 1.3 + Math.sin(time * 0.03) * 0.3,
        randomize: true,
        seed: seed || Math.floor(time * 1000) % 1000
      });

      if (converted.canvas) {
        const scaleX = (building.size.width * gridSize) / 32;
        const scaleY = (building.size.height * gridSize) / 32;
        const scale = Math.min(scaleX, scaleY) * 0.8;

        const svgX = centerX - (32 * scale) / 2;
        const svgY = centerY - (32 * scale) / 2;

        ctx.save();
        ctx.drawImage(converted.canvas, svgX, svgY, 32 * scale, 32 * scale);
        ctx.restore();
      }
    } catch (error) {
      console.warn('Failed to render pre-generated building SVG:', error);
      drawFallbackBuilding(rc, centerX, centerY, gridSize, building, time);
    }
  } else if (building.emoji) { // Priority 2: Fallback to emoji rendering
    try {
      // Check cache first
      const cacheKey = building.emoji;
      let emojiSvg = buildingEmojiCache.get(cacheKey);

      // If not in cache or older than 5 minutes, fetch it
      if (!emojiSvg || (Date.now() - emojiSvg.lastUsed) > 300000) {
        const fetchedSvg = await assetConverter.fetchEmojiSvg(building.emoji, 'svgmoji', {
          rough: true,
          preset: 'sketch',
          options: {
            roughness: 1.0 + Math.sin(time * 0.02) * 0.2, // Animate roughness
            bowing: 1.3 + Math.sin(time * 0.03) * 0.3,   // Animate bowing
            randomize: true,
            seed: seed || Math.floor(time * 1000) % 1000
          }
        });
        emojiSvg = { svg: fetchedSvg, lastUsed: Date.now() };
        buildingEmojiCache.set(cacheKey, emojiSvg);
      }

      if (emojiSvg.svg) {
        // Convert SVG to rough.js canvas and draw it
        const converted = await assetConverter.convertSvgToCanvas(emojiSvg.svg, {
          roughness: 1.0 + Math.sin(time * 0.02) * 0.2,
          bowing: 1.3 + Math.sin(time * 0.03) * 0.3,
          randomize: true,
          seed: seed || Math.floor(time * 1000) % 1000
        });

        if (converted.canvas) {
          // Scale based on building size
          const scaleX = (building.size.width * gridSize) / 32;
          const scaleY = (building.size.height * gridSize) / 32;
          const scale = Math.min(scaleX, scaleY) * 0.8; // Slightly smaller to fit

          const emojiX = centerX - (32 * scale) / 2;
          const emojiY = centerY - (32 * scale) / 2;

          // Draw the rough canvas onto the main canvas
          ctx.save();
          ctx.drawImage(converted.canvas, emojiX, emojiY, 32 * scale, 32 * scale);
          ctx.restore();
        }
      }
    } catch (error) {
      console.warn('Failed to render building emoji:', error);
      // Fall back to simple rendering
      drawFallbackBuilding(rc, centerX, centerY, gridSize, building, time);
    }
  } else {
    // Fallback rendering
    drawFallbackBuilding(rc, centerX, centerY, gridSize, building, time);
  }

  // Draw building name if it's a large building
  if (building.size.width > 1 || building.size.height > 1) {
    if (ctx) {
      ctx.fillStyle = '#000';
      ctx.font = 'bold 8px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(building.name, centerX + 1, centerY - building.size.height * gridSize / 2 - 5);

      ctx.fillStyle = '#FFF';
      ctx.fillText(building.name, centerX, centerY - building.size.height * gridSize / 2 - 6);
    }
  }
};

// Fallback rendering for buildings when emoji fails
const drawFallbackBuilding = (rc: any, centerX: number, centerY: number, gridSize: number, building: Building, time: number) => {
  const width = building.size.width * gridSize;
  const height = building.size.height * gridSize;
  const x = centerX - width / 2;
  const y = centerY - height / 2;

  // Building base with animated roughness
  const animatedRoughness = 1.2 + Math.sin(time * 0.01) * 0.3;
  rc.rectangle(x, y, width, height, {
    fill: '#8B4513',
    fillStyle: 'solid',
    stroke: '#654321',
    strokeWidth: 2,
    roughness: animatedRoughness
  });

  // Building details based on type
  switch (building.type) {
    case 'house':
      // Simple house with door
      rc.rectangle(x + width * 0.4, y + height * 0.6, width * 0.2, height * 0.4, {
        fill: '#654321',
        fillStyle: 'solid',
        roughness: animatedRoughness * 0.8
      });
      break;

    case 'castle':
      // Castle with towers
      rc.rectangle(x + width * 0.1, y, width * 0.15, height * 0.8, {
        fill: '#696969',
        fillStyle: 'solid',
        roughness: animatedRoughness
      });
      rc.rectangle(x + width * 0.75, y, width * 0.15, height * 0.8, {
        fill: '#696969',
        fillStyle: 'solid',
        roughness: animatedRoughness
      });
      break;

    case 'tower':
      // Tall tower
      rc.rectangle(x + width * 0.3, y, width * 0.4, height, {
        fill: '#708090',
        fillStyle: 'solid',
        roughness: animatedRoughness
      });
      break;

    case 'shop':
      // Shop with sign
      rc.rectangle(x + width * 0.3, y + height * 0.2, width * 0.4, height * 0.3, {
        fill: '#FFF',
        fillStyle: 'solid',
        roughness: animatedRoughness * 0.7
      });
      break;

    case 'tavern':
      // Tavern with windows
      for (let i = 0; i < 2; i++) {
        rc.rectangle(x + width * (0.2 + i * 0.3), y + height * 0.3, width * 0.15, height * 0.2, {
          fill: '#FFD700',
          fillStyle: 'solid',
          roughness: animatedRoughness * 0.6
        });
      }
      break;

    case 'temple':
      // Temple with pillars
      for (let i = 0; i < 3; i++) {
        rc.rectangle(x + width * (0.15 + i * 0.25), y + height * 0.2, width * 0.08, height * 0.6, {
          fill: '#F5F5DC',
          fillStyle: 'solid',
          roughness: animatedRoughness
        });
      }
      break;

    default:
      // Generic building
      rc.rectangle(x + width * 0.1, y + height * 0.1, width * 0.8, height * 0.8, {
        fill: '#D2B48C',
        fillStyle: 'solid',
        roughness: animatedRoughness
      });
  }
};
</file>

<file path="packages/frontend/src/components/renderers/entities/ItemRenderer.ts">
import type { Item } from 'shared';

// Optional `seed` parameter is accepted for deterministic/randomized effects
// (kept optional so existing callers without a seed continue to work).
export const drawAnimatedItem = (rc: any, x: number, y: number, gridSize: number, item: Item, time: number, seed?: number) => {
  const centerX = x * gridSize + gridSize / 2;
  const centerY = y * gridSize + gridSize / 2;

  // Floating animation
  const floatOffset = Math.sin(time * 0.015 + x + y) * 2; // Much slower, gentler float

  // Tarkov-style looting visual states
  if (item.isHidden) {
    // Hidden item - show as mysterious obscured shape
    drawHiddenItem(rc, centerX, centerY + floatOffset, time);
    return;
  }

  if (item.revealProgress < 1.0) {
    // Revealing item - show progress indicator
    drawRevealingItem(rc, centerX, centerY + floatOffset, item, time);
    return;
  }

  // Fully revealed item
  drawRevealedItem(rc, centerX, centerY + floatOffset, item, time, gridSize);
};

const drawHiddenItem = (rc: any, centerX: number, centerY: number, time: number) => {
  // Mysterious obscured shape with pulsing effect
  const pulseScale = 1 + Math.sin(time * 0.02) * 0.1;

  // Outer mystery glow
  rc.circle(centerX, centerY, 15 * pulseScale, {
    fill: '#666666',
    fillStyle: 'solid',
    stroke: '#999999',
    strokeWidth: 2,
    roughness: 2.0
  });

  // Question mark or mystery symbol
  const ctx = (rc as any).ctx;
  if (ctx) {
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(time * 0.005); // Slow rotation

    // Draw a question mark shape
    rc.circle(0, -3, 3, {
      fill: '#FFFFFF',
      fillStyle: 'solid',
      stroke: '#666666',
      strokeWidth: 2
    });

    // Question mark dot
    rc.circle(0, 5, 1, {
      fill: '#FFFFFF',
      fillStyle: 'solid'
    });

    ctx.restore();
  }
};

const drawRevealingItem = (rc: any, centerX: number, centerY: number, item: Item, time: number) => {
  // Show item with reveal progress
  const progress = item.revealProgress;

  // Background reveal circle
  rc.circle(centerX, centerY, 18, {
    fill: '#333333',
    fillStyle: 'solid',
    stroke: '#666666',
    strokeWidth: 2
  });

  // Progress arc
  const ctx = (rc as any).ctx;
  if (ctx) {
    ctx.save();
    ctx.translate(centerX, centerY);

    // Draw progress arc
    ctx.beginPath();
    ctx.arc(0, 0, 16, -Math.PI / 2, -Math.PI / 2 + (progress * 2 * Math.PI));
    ctx.lineWidth = 3;
    ctx.strokeStyle = getRarityColor(item.rarity);
    ctx.stroke();

    ctx.restore();
  }

  // Partially revealed item (scaled by progress)
  const scale = 0.3 + (progress * 0.7); // Start small, grow as revealed
  if (ctx) {
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.scale(scale, scale);

    drawItemShape(rc, 0, 0, item, time);

    ctx.restore();
  }

  // Progress text
  if (ctx) {
    ctx.save();
    ctx.translate(centerX, centerY + 25);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.round(progress * 100)}%`, 0, 0);
    ctx.restore();
  }
};

const drawRevealedItem = (rc: any, centerX: number, centerY: number, item: Item, time: number, gridSize: number) => {
  const rarityColors = {
    common: '#9CA3AF',
    uncommon: '#10B981',
    rare: '#3B82F6',
    epic: '#8B5CF6',
    legendary: '#F59E0B'
  };

  const color = rarityColors[item.rarity as 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary'] || '#9CA3AF';

  // Lootable indicator (green glow if can be looted)
  if (item.canBeLooted) {
    rc.circle(centerX, centerY, 14, {
      fill: '#00FF00',
      fillStyle: 'solid',
      stroke: '#FFFFFF',
      strokeWidth: 2,
      roughness: 1.0
    });
  }

  // Animated glow effect
  rc.circle(centerX, centerY, 12, {
    fill: color,
    fillStyle: 'solid',
    stroke: '#FFF',
    strokeWidth: 7,
    roughness: 1.5
  });

  // Inner item shape
  drawItemShape(rc, centerX, centerY, item, time);

  // Sparkle effects for rare items
  if (item.rarity === 'legendary' || item.rarity === 'epic') {
    for (let s = 0; s < 3; s++) {
      const sparkleX = centerX + Math.sin(time * 0.025 + s * 2) * 6;
      const sparkleY = centerY + Math.cos(time * 0.05 + s * 2) * 8;
      rc.circle(sparkleX, sparkleY, 2, {
        fill: '#FFD700',
        fillStyle: 'solid'
      });
    }
  }
};

const drawItemShape = (rc: any, centerX: number, centerY: number, item: Item, time: number) => {
  const rotation = time * 0.01; // Slower rotation
  const ctx = (rc as any).ctx;
  if (ctx) {
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(rotation);

    const color = getRarityColor(item.rarity);

    // Draw different shapes based on item type
    if (item.type === 'weapon') {
      // Sword shape
      rc.rectangle(-3, -8, 6, 12, {
        fill: '#C0C0C0',
        fillStyle: 'solid',
        stroke: '#808080',
        strokeWidth: 4
      });
    } else if (item.type === 'consumable') {
      // Potion bottle
      rc.rectangle(-3, -6, 6, 9, {
        fill: color,
        fillStyle: 'solid',
        stroke: '#000',
        strokeWidth: 4
      });
      // Cork
      rc.rectangle(-2, -9, 4, 3, {
        fill: '#8B4513',
        fillStyle: 'solid'
      });
    } else {
      // Generic item
      rc.circle(0, 0, 5, {
        fill: color,
        fillStyle: 'solid',
        stroke: '#000',
        strokeWidth: 4
      });
    }

    ctx.restore();
  }
};

const getRarityColor = (rarity: string): string => {
  const colors = {
    common: '#9CA3AF',
    uncommon: '#10B981',
    rare: '#3B82F6',
    epic: '#8B5CF6',
    legendary: '#F59E0B'
  };
  return colors[rarity as keyof typeof colors] || '#9CA3AF';
};
</file>

<file path="packages/frontend/src/components/renderers/entities/NPCRenderer.ts">
// Accept optional `seed` parameter for deterministic animation variations.
export const drawAnimatedNPC = (rc: any, x: number, y: number, gridSize: number, time: number, seed?: number) => {
  const centerX = x * gridSize + gridSize / 2;
  const centerY = y * gridSize + gridSize / 2;

  // Breathing animation
  const breathScale = 1 + Math.sin(time * 0.05) * 0.1;

  // Pulsing danger aura
  const auraRadius = 14 + Math.sin(time * 0.04) * 1.5; // Much slower, gentler aura
  rc.circle(centerX, centerY, auraRadius, {
    fill: '#DC143C',
    fillStyle: 'solid',
    stroke: '#8B0000',
    strokeWidth: 2,
    roughness: 2
  });

  // Main NPC body with breathing animation
  rc.circle(centerX, centerY, 8 * breathScale, {
    fill: '#DC143C',
    fillStyle: 'solid',
    stroke: '#8B0000',
    strokeWidth: 3,
    roughness: 1.5
  });

  // Angry eyes that follow movement
  const eyeOffset = Math.sin(time * 0.03) * 2;
  rc.circle(centerX - 3, centerY - 2 + eyeOffset, 1.5, {
    fill: '#FFF',
    fillStyle: 'solid'
  });
  rc.circle(centerX + 3, centerY - 2 + eyeOffset, 1.5, {
    fill: '#FFF',
    fillStyle: 'solid'
  });

  // Pupil
  rc.circle(centerX - 3, centerY - 2 + eyeOffset, 0.8, {
    fill: '#000',
    fillStyle: 'solid'
  });
  rc.circle(centerX + 3, centerY - 2 + eyeOffset, 0.8, {
    fill: '#000',
    fillStyle: 'solid'
  });

  // Spikes/horns using polygon
  for (let s = 0; s < 4; s++) {
    const angle = (s * Math.PI * 2) / 4;
    const spikeX = centerX + Math.cos(angle) * 10;
    const spikeY = centerY + Math.sin(angle) * 10;
    rc.polygon([
      [spikeX - 2, spikeY - 2],
      [spikeX + 2, spikeY - 2],
      [spikeX, spikeY + 2]
    ], {
      fill: '#8B0000',
      fillStyle: 'solid',
      roughness: 1
    });
  }
};
</file>

<file path="packages/frontend/src/components/renderers/entities/PlayerRenderer.ts">
import type { Player } from 'shared';
import { assetConverter } from '../../../services/assetConverter';

interface ParticleEmitter {
  (x: number, y: number, color: string, count?: number): void;
}

// Cache for emoji SVGs to avoid repeated fetches
const emojiCache = new Map<string, { svg: string; lastUsed: number }>();

// Accept optional `seed` parameter for deterministic/randomized particle effects.
export const drawAnimatedPlayer = async (rc: any, x: number, y: number, gridSize: number, player: Player, time: number, addParticles: ParticleEmitter, seed?: number) => {
  const centerX = x * gridSize + gridSize / 2;
  const centerY = y * gridSize + gridSize / 2;
  const ctx = (rc as any).ctx;

  // Class-specific colors and effects (kept for compatibility)
  const classData = {
    knight: { color: '#FFD700', secondary: '#B8860B', particleColor: '#FFD700' },
    rogue: { color: '#8B0000', secondary: '#DC143C', particleColor: '#FF4500' },
    mage: { color: '#4B0082', secondary: '#8A2BE2', particleColor: '#9370DB' }
  };

  const currentClass = classData[player.class as keyof typeof classData] || classData.knight;

  // Try to render emoji avatar
  let emojiRendered = false;
  if (player.avatar && player.avatar.trim()) {
    try {
      // Check cache first
      const cacheKey = player.avatar;
      let emojiSvg = emojiCache.get(cacheKey);

      // If not in cache or older than 5 minutes, fetch it
      if (!emojiSvg || (Date.now() - emojiSvg.lastUsed) > 300000) {
        const fetchedSvg = await assetConverter.fetchEmojiSvg(player.avatar, 'svgmoji', {
          rough: true,
          preset: 'sketch',
          options: {
            roughness: 1.2,
            bowing: 1.5,
            randomize: true,
            seed: seed || Math.floor(time * 1000) % 1000 // Use time-based seed for animation
          }
        });
        emojiSvg = { svg: fetchedSvg, lastUsed: Date.now() };
        emojiCache.set(cacheKey, emojiSvg);
      }

      if (emojiSvg.svg) {
        // Convert SVG to rough.js canvas and draw it
        const converted = await assetConverter.convertSvgToCanvas(emojiSvg.svg, {
          roughness: 1.2 + Math.sin(time * 0.01) * 0.3, // Animate roughness
          bowing: 1.5 + Math.sin(time * 0.015) * 0.5,   // Animate bowing
          randomize: true,
          seed: seed || Math.floor(time * 1000) % 1000
        });

        if (converted.canvas) {
          // Scale and position the emoji canvas
          const scale = (gridSize * 0.6) / 32; // Assuming 32px emoji, scale to 60% of grid size
          const emojiSize = 32 * scale;
          const emojiX = centerX - emojiSize / 2;
          const emojiY = centerY - emojiSize / 2;

          // Draw the rough canvas onto the main canvas
          ctx.save();
          ctx.drawImage(converted.canvas, emojiX, emojiY, emojiSize, emojiSize);
          ctx.restore();
        }

        emojiRendered = true;
      }
    } catch (error) {
      console.warn('Failed to render emoji avatar:', error);
      // Fall back to default rendering
    }
  }

  // Fallback to class-specific rendering if emoji failed
  if (!emojiRendered) {
    // Magical aura for all players
    const auraRadius = 24 + Math.sin(time * 0.02) * 2; // Much slower, gentler aura pulsing
    rc.circle(centerX, centerY, auraRadius, {
      fill: currentClass.color,
      fillStyle: 'solid',
      stroke: currentClass.secondary,
      strokeWidth: 4, // Thicker stroke
      roughness: 2
    });

    // Main player body with subtle pulsing
    const pulseScale = 1 + Math.sin(time * 0.025) * 0.05; // Much slower, gentler pulsing
    rc.circle(centerX, centerY, 14 * pulseScale, { // Larger base size
      fill: currentClass.color,
      fillStyle: 'solid',
      stroke: '#FFF',
      strokeWidth: 6, // Thicker stroke
      roughness: 1
    });

    // Class-specific visual effects
    if (player.class === 'knight') {
      // Knight: Shield effect
      rc.rectangle(centerX - 10, centerY - 10, 6, 16, { // Larger shield
        fill: '#C0C0C0',
        fillStyle: 'solid',
        stroke: '#808080',
        strokeWidth: 4, // Thicker
        roughness: 1
      });
      // Cross on shield
      rc.line(centerX - 7, centerY - 8, centerX - 7, centerY + 8, { // Larger cross
        stroke: '#FFD700',
        strokeWidth: 6 // Thicker
      });
      rc.line(centerX - 10, centerY, centerX - 4, centerY, {
        stroke: '#FFD700',
        strokeWidth: 6
      });
    } else if (player.class === 'rogue') {
      // Rogue: Daggers/stealth effect
      for (let d = 0; d < 2; d++) {
        const daggerX = centerX + (d === 0 ? -8 : 8); // Further apart
        const daggerY = centerY - 3;
        rc.polygon([
          [daggerX - 2, daggerY - 6], // Larger daggers
          [daggerX + 2, daggerY - 6],
          [daggerX, daggerY + 3]
        ], {
          fill: '#C0C0C0',
          fillStyle: 'solid',
          stroke: '#808080',
          strokeWidth: 4 // Thicker
        });
      }
    } else if (player.class === 'mage') {
      // Mage: Magical runes
      const runeOffset = Math.sin(time * 0.015) * 3; // Much slower rune movement
      for (let r = 0; r < 3; r++) {
        const angle = (r * Math.PI * 2) / 3;
        const runeX = centerX + Math.cos(angle) * (16 + runeOffset); // Larger radius
        const runeY = centerY + Math.sin(angle) * (16 + runeOffset);
        rc.circle(runeX, runeY, 3, { // Larger runes
          fill: '#9370DB',
          fillStyle: 'solid',
          stroke: '#8A2BE2',
          strokeWidth: 4 // Thicker
        });
      }
    }
  }

  // Health bar above player
  const healthPercent = player.stats.hp / player.stats.maxHp;
  const barWidth = 28; // Wider health bar
  const barHeight = 5; // Taller health bar

  // Background
  rc.rectangle(centerX - barWidth/2, centerY - 25, barWidth, barHeight, {
    fill: '#8B0000',
    fillStyle: 'solid',
    roughness: 0.5
  });

  // Health fill
  rc.rectangle(centerX - barWidth/2, centerY - 25, barWidth * healthPercent, barHeight, {
    fill: healthPercent > 0.6 ? '#32CD32' : healthPercent > 0.3 ? '#FFD700' : '#DC143C',
    fillStyle: 'solid',
    roughness: 0.5
  });

  // Player name with shadow effect
  if (ctx) {
    ctx.fillStyle = '#000';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(player.displayName, centerX + 1, centerY - 32);

    ctx.fillStyle = '#FFF';
    ctx.fillText(player.displayName, centerX, centerY - 33);
  }

  // Class indicator
  if (ctx && player.class) {
    ctx.fillStyle = currentClass.secondary;
    ctx.font = '8px Arial';
    ctx.fillText(player.class.toUpperCase(), centerX, centerY + 27);
  }

  // Occasional particle effects for active players
  if (Math.random() < 0.02) {
    addParticles(centerX, centerY, currentClass.particleColor, 3);
  }
};
</file>

<file path="packages/frontend/src/components/renderers/terrain/BiomeRenderer.ts">
import type { AnimationSettings } from 'shared';
import { BiomeType } from 'shared';

export const drawBiome = (rc: any, startX: number, startY: number, gridSize: number, terrainType: BiomeType, time: number, settings: AnimationSettings) => {
  // Simplified Rough.js options to avoid errors
  const roughness = settings?.roughness || 1.5;
  const fillStyle = settings?.fillStyle || 'hachure';

  // Get biome-specific fill styles
  const getBiomeFillStyle = (terrainType: BiomeType): string => {
    switch (terrainType) {
      case BiomeType.SNOW:
      case BiomeType.ICE:
      case BiomeType.SNOWY_HILLS:
        return 'cross-hatch';
      case BiomeType.DUNES:
      case BiomeType.SAND:
      case BiomeType.OASIS:
        return 'hachure';
      case BiomeType.DENSE_JUNGLE:
      case BiomeType.JUNGLE:
        return 'cross-hatch';
      case BiomeType.DEEP_WATER:
      case BiomeType.MARSH:
      case BiomeType.SWAMP:
        return 'dots';
      default:
        return fillStyle;
    }
  };

  // Get biome-specific colors with unified styling
  const getBiomeColor = (terrainType: BiomeType): { fill: string, stroke: string } => {
    switch (terrainType) {
      case BiomeType.PLAIN:
        return { fill: '#90EE90', stroke: '#7BC97B' }; // Lighter green stroke
      case BiomeType.GRASSLAND:
        return { fill: '#84cc16', stroke: '#6BA312' }; // Darker green stroke
      case BiomeType.FOREST:
        return { fill: '#166534', stroke: '#0F4A2A' }; // Darker green stroke
      case BiomeType.MOUNTAIN:
        return { fill: '#a8a29e', stroke: '#8B8682' }; // Slightly darker gray
      case BiomeType.SNOW:
      case BiomeType.ICE:
        return { fill: '#f8fafc', stroke: '#E8ECF0' }; // Very light blue-gray
      case BiomeType.DUNES:
      case BiomeType.SAND:
        return { fill: '#f4a460', stroke: '#D4A050' }; // Golden brown
      case BiomeType.WATER:
      case BiomeType.OCEAN:
      case BiomeType.RIVER:
        return { fill: '#1e293b', stroke: '#2A3441' }; // Slightly lighter blue
      default:
        return { fill: '#90EE90', stroke: '#7BC97B' };
    }
  };

  const colors = getBiomeColor(terrainType);

  // Simple rectangle with unified styling - thicker strokes for better visibility
  rc.rectangle(startX, startY, gridSize, gridSize, {
    fill: colors.fill,
    fillStyle: getBiomeFillStyle(terrainType),
    stroke: colors.stroke,
    strokeWidth: 2, // Thicker for better visibility
    fillWeight: 2.0, // Thicker fill lines
    roughness: roughness * 0.8, // Slightly smoother edges
    bowing: 0.8 // Reduced bowing for more uniform shapes
  });
};
</file>

<file path="packages/frontend/src/components/renderers/terrain/ForestRenderer.ts">
import type { AnimationSettings } from 'shared';
import { BiomeType } from 'shared';

export const drawForest = (rc: any, startX: number, startY: number, gridSize: number, terrainType: BiomeType, time: number, settings: AnimationSettings) => {
  const roughness = settings?.roughness || 1.5;
  const fillStyle = settings?.fillStyle || 'hachure';
  const treeSwaySpeed = settings?.treeSwaySpeed || 0.025; // Slightly faster tree swaying

  switch (terrainType) {
    case BiomeType.DENSE_FOREST:
      // Very thick forest
      rc.rectangle(startX, startY, gridSize, gridSize, {
        fill: '#14532d',
        fillStyle: 'cross-hatch',
        stroke: '#1A5A35', // Lighter green stroke
        strokeWidth: 2, // Thicker for cohesion
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.8, // Smoother
        bowing: 0.8 // More uniform
      });
      // Dense trees
      for (let t = 0; t < 4; t++) {
        const treeX = startX + 3 + (t % 2) * 10;
        const treeY = startY + 4 + Math.floor(t / 2) * 8;
        const swayOffset = Math.sin(time * treeSwaySpeed + startX + t) * 2;
        rc.line(treeX + swayOffset, treeY + 8, treeX + swayOffset, treeY, {
          stroke: '#92400e',
          strokeWidth: 3, // Thicker trunks
          roughness: roughness * 0.9
        });
        rc.circle(treeX + swayOffset, treeY - 2, 4, {
          fill: '#166534',
          fillStyle: 'hachure',
          roughness: roughness * 1.1
        });
      }
      break;

    case BiomeType.FOREST:
      // Regular forest
      rc.rectangle(startX, startY, gridSize, gridSize, {
        fill: '#166534',
        fillStyle: 'hachure',
        stroke: '#1B703D', // Lighter green stroke
        strokeWidth: 2, // Thicker for cohesion
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.8,
        bowing: 0.8
      });
      // Forest trees
      for (let t = 0; t < 3; t++) {
        const treeX = startX + 4 + t * 6;
        const treeY = startY + 6;
        const swayOffset = Math.sin(time * treeSwaySpeed + startX + t) * 1.5;
        rc.line(treeX + swayOffset, treeY + 8, treeX + swayOffset, treeY, {
          stroke: '#a16207',
          strokeWidth: 3, // Thicker trunks
          roughness: roughness * 0.8
        });
        rc.circle(treeX + swayOffset, treeY - 2, 3.5, {
          fill: '#22c55e',
          fillStyle: 'hachure',
          roughness: roughness * 1.0
        });
      }
      break;

    case BiomeType.CLEARING:
      // Forest clearing
      rc.rectangle(startX, startY, gridSize, gridSize, {
        fill: '#84cc16',
        fillStyle: 'hachure',
        stroke: '#7AB312', // Lighter green stroke
        strokeWidth: 2, // Thicker for cohesion
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.8,
        bowing: 0.8
      });
      // Small campfire
      rc.circle(startX + 8, startY + 10, 2, {
        fill: '#f59e0b',
        fillStyle: 'solid',
        roughness: roughness * 0.4
      });
      break;
  }
};
</file>

<file path="packages/frontend/src/components/renderers/terrain/MountainRenderer.ts">
import type { AnimationSettings } from 'shared';
import { BiomeType } from 'shared';

export const drawMountain = (rc: any, startX: number, startY: number, gridSize: number, terrainType: BiomeType, time: number, settings: AnimationSettings) => {
  const roughness = settings?.roughness || 1.5;

  switch (terrainType) {
    case BiomeType.MOUNTAIN_PEAK:
      // Snow-capped mountain peaks
      rc.rectangle(startX, startY, gridSize, gridSize, {
        fill: '#64748b',
        fillStyle: 'cross-hatch',
        stroke: '#5A6B7D', // Lighter slate stroke
        strokeWidth: 2, // Thicker for cohesion
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.8, // Smoother
        bowing: 0.8 // More uniform
      });
      // Peak details
      rc.polygon([
        [startX + 2, startY + 15],
        [startX + 10, startY + 2],
        [startX + 18, startY + 15]
      ], {
        fill: '#f1f5f9',
        fillStyle: 'hachure',
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.9
      });
      break;

    case BiomeType.MOUNTAIN:
      // Rocky mountains with shadow
      rc.rectangle(startX, startY, gridSize, gridSize, {
        fill: '#78716c',
        fillStyle: 'cross-hatch',
        stroke: '#6B6763', // Lighter stone stroke
        strokeWidth: 2, // Thicker for cohesion
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.8,
        bowing: 0.8
      });
      // Mountain silhouette
      rc.polygon([
        [startX, startY + 18],
        [startX + 8, startY + 5],
        [startX + 16, startY + 12],
        [startX + gridSize, startY + 18]
      ], {
        fill: '#374151',
        fillStyle: 'hachure',
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 1.0
      });
      break;

    case BiomeType.HILLS:
      // Rolling hills
      rc.rectangle(startX, startY, gridSize, gridSize, {
        fill: '#a3a3a3',
        fillStyle: 'hachure',
        stroke: '#858585', // Lighter gray stroke
        strokeWidth: 2, // Thicker for cohesion
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.8,
        bowing: 0.8
      });
      // Hill contours
      rc.ellipse(startX + 8, startY + 12, 12, 6, {
        fill: '#d4d4d8',
        fillStyle: 'hachure',
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.6
      });
      break;
  }
};
</file>

<file path="packages/frontend/src/components/renderers/terrain/OceanRenderer.ts">
import type { AnimationSettings } from 'shared';
import { BiomeType } from 'shared'; // Import from shared

export const drawOcean = (rc: any, startX: number, startY: number, gridSize: number, terrainType: BiomeType, time: number, settings: AnimationSettings) => {
  const roughness = settings?.roughness || 1.5;
  const bowing = settings?.bowing || 1.2;

  switch (terrainType) {
    case BiomeType.WATER:
    case BiomeType.OCEAN:
      // Ocean/deep water with wave animation
      rc.rectangle(startX, startY, gridSize, gridSize, {
        fill: '#1e40af',
        fillStyle: 'dots',
        stroke: '#2A4A8A', // Lighter blue stroke for better cohesion
        strokeWidth: 2, // Thicker
        roughness: roughness * 0.8, // Smoother edges
        bowing: 0.8 // More uniform shapes
      });
      // Animated waves
      for (let w = 0; w < 3; w++) {
        const waveOffset = Math.sin(time * 0.025 + startX * 0.5 + w) * 2; // Slightly faster waves
        rc.line(startX, startY + 5 + w * 10 + waveOffset, startX + gridSize, startY + 5 + w * 10 + waveOffset, { // More spaced waves
          stroke: '#3b82f6',
          strokeWidth: 3, // Thicker
          roughness: roughness * 0.6,
          bowing: bowing * 0.4
        });
      }
      break;

    case BiomeType.RIVER:
      // Flowing river with current animation
      rc.rectangle(startX, startY, gridSize, gridSize, {
        fill: '#3b82f6',
        fillStyle: 'hachure',
        stroke: '#2D5AA8', // Lighter blue stroke
        strokeWidth: 2, // Thicker for cohesion
        fillWeight: 2.0, // Thicker fill lines
        roughness: roughness * 0.8,
        bowing: 0.8
      });
      // Animated current
      const currentOffset = Math.sin(time * 0.03 + startY) * 3; // Slightly faster current
      rc.line(startX + 2, startY + 5 + currentOffset, startX + gridSize - 2, startY + 12 + currentOffset, { // Longer current line
        stroke: '#60a5fa',
        strokeWidth: 4, // Thicker current
        roughness: roughness * 0.5,
        bowing: bowing * 0.6
      });
      break;
  }
};
</file>

<file path="packages/frontend/src/components/renderers/terrain/TerrainRenderer.ts">
import type { AnimationSettings } from 'shared';
import { BiomeType } from 'shared';
import { drawOcean } from './OceanRenderer';
import { drawMountain } from './MountainRenderer';
import { drawForest } from './ForestRenderer';
import { drawBiome } from './BiomeRenderer'; // For grassland, plain, etc.

export const drawAnimatedTerrainTile = (rc: any, x: number, y: number, gridSize: number, terrainType: BiomeType, time: number, settings: AnimationSettings) => {
  const startX = x * gridSize;
  const startY = y * gridSize;

  switch (terrainType) {
    case BiomeType.WATER:
    case BiomeType.OCEAN:
    case BiomeType.RIVER:
      drawOcean(rc, startX, startY, gridSize, terrainType, time, settings);
      break;
    case BiomeType.MOUNTAIN_PEAK:
    case BiomeType.MOUNTAIN:
    case BiomeType.HILLS:
      drawMountain(rc, startX, startY, gridSize, terrainType, time, settings);
      break;
    case BiomeType.DENSE_FOREST:
    case BiomeType.FOREST:
    case BiomeType.CLEARING:
      drawForest(rc, startX, startY, gridSize, terrainType, time, settings);
      break;
    case BiomeType.GRASSLAND:
    case BiomeType.PLAIN:
    case BiomeType.FLOWER_FIELD:
    case BiomeType.ROLLING_HILLS:
    case BiomeType.ROUGH_TERRAIN:
    case BiomeType.ANCIENT_RUINS:
    case BiomeType.SNOW:
    case BiomeType.ICE:
    case BiomeType.SNOWY_HILLS:
    case BiomeType.DUNES:
    case BiomeType.OASIS:
    case BiomeType.SAND:
    case BiomeType.DENSE_JUNGLE:
    case BiomeType.JUNGLE:
    case BiomeType.DEEP_WATER:
    case BiomeType.MARSH:
    case BiomeType.SWAMP:
      drawBiome(rc, startX, startY, gridSize, terrainType, time, settings);
      break;
    default:
      console.warn('Unknown terrain type:', terrainType);
  }
};
</file>

<file path="packages/frontend/src/components/renderers/BiomeRenderer.ts">
import { Biome, BIOME_RENDER_CONFIGS } from 'shared';
import { RoughCanvas } from 'roughjs/bin/canvas';
import { UnifiedRoughFillService } from '../../services/UnifiedRoughFillService';
import { BiomeTextureService } from '../../services/BiomeTextureService';

export class BiomeRenderer {
    private unifiedRoughFillService: UnifiedRoughFillService;
    private textureService: BiomeTextureService;
    private currentAnimationFrame: number = 0;

    constructor(private rc: RoughCanvas) {
        this.unifiedRoughFillService = new UnifiedRoughFillService(this.rc);
        this.textureService = new BiomeTextureService();
    }

    public setAnimationFrame(frame: number): void {
        this.currentAnimationFrame = frame;
    }

    public drawBiome(biome: Biome, tileSize: number): void {
        this.unifiedRoughFillService.applyUnifiedBiomeFill(
            biome,
            tileSize,
            this.currentAnimationFrame
        );

        const config = BIOME_RENDER_CONFIGS[biome.type];
        if (config.textureOverlay) {
            this.textureService.addTextureOverlay(
                biome,
                config.textureOverlay,
                this.rc,
                this.currentAnimationFrame
            );
        }
    }
}
</file>

<file path="packages/frontend/src/components/settings/AudioModal.tsx">
import React from 'react';
import { useGameStore } from '../../stores/gameStore';
import { SettingSlider, SettingCheckbox, MaterialMultiSelect } from '../shared/settings';
import { MaterialCard } from '../index';

const AudioModal: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  const { unifiedSettings, updateAudioSettings, updateNotificationSettings } = useGameStore();

  const notificationTypeOptions = [
    { value: 'desktop', label: 'Desktop' },
    { value: 'sound', label: 'Sound' },
    { value: 'ingame', label: 'In-Game' },
  ];

  return (
    <div className="p-6 h-full overflow-auto font-mono bg-gradient-to-br from-background-primary/95 to-surface/90">
      {/* Modal Header */}
      <div className="flex items-center justify-between mb-8 pb-4 border-b-2 border-primary/30">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-orange-400 to-orange-600 flex items-center justify-center shadow-lg shadow-orange-500/30">
            <span className="text-2xl">ðŸŽµ</span>
          </div>
          <div>
            <h1 className="m-0 text-text-primary text-2xl font-bold text-shadow">
              Audio
            </h1>
            <p className="mt-1 mb-0 text-text-secondary text-sm font-normal">
              Sound and music controls
            </p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="w-10 h-10 rounded-full bg-white/10 border-none text-text-primary cursor-pointer flex items-center justify-center text-lg transition-all duration-200 hover:bg-white/20 hover:scale-105"
        >
          âœ•
        </button>
      </div>

      <div className="flex flex-col gap-6">
        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(255, 152, 0, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(255, 152, 0, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(255, 152, 0, 0.15)',
              borderColor: 'rgba(255, 152, 0, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-orange-400 to-orange-600 flex items-center justify-center">
              <span className="text-lg">ðŸ”Š</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Volume Controls
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingSlider
              label="Master Volume"
              value={unifiedSettings.audio.audioMasterVolume}
              min={0} max={100} step={5}
              onChange={(v) => updateAudioSettings({ audioMasterVolume: v })}
              unit="%" showReset resetValue={80}
              description="Global mix level"
            />
            <SettingSlider
              label="SFX Volume"
              value={unifiedSettings.audio.sfxVolume}
              min={0} max={100} step={5}
              onChange={(v) => updateAudioSettings({ sfxVolume: v })}
              unit="%" showReset resetValue={70}
              description="Sound effects loudness"
            />
            <SettingSlider
              label="Music Volume"
              value={unifiedSettings.audio.musicVolume}
              min={0} max={100} step={5}
              onChange={(v) => updateAudioSettings({ musicVolume: v })}
              unit="%" showReset resetValue={60}
              description="Background soundtrack volume"
            />
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(255, 152, 0, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(255, 152, 0, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(255, 152, 0, 0.15)',
              borderColor: 'rgba(255, 152, 0, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-orange-400 to-orange-600 flex items-center justify-center">
              <span className="text-lg">ðŸ”ˆ</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Audio Toggles
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingCheckbox
              label="Enable SFX"
              checked={unifiedSettings.audio.soundEnabled}
              onChange={(c) => updateAudioSettings({ soundEnabled: c })}
              description="Play sound effects"
            />
            <SettingCheckbox
              label="Enable Music"
              checked={unifiedSettings.audio.musicEnabled}
              onChange={(c) => updateAudioSettings({ musicEnabled: c })}
              description="Play background music"
            />
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(255, 152, 0, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(255, 152, 0, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(255, 152, 0, 0.15)',
              borderColor: 'rgba(255, 152, 0, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-orange-400 to-orange-600 flex items-center justify-center">
              <span className="text-lg">ðŸ””</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Notifications
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingCheckbox
              label="Desktop Notifications"
              checked={unifiedSettings.notifications.desktopNotifications}
              onChange={(c) => updateNotificationSettings({ desktopNotifications: c })}
              description="Show desktop notifications"
            />
            <SettingCheckbox
              label="Sound Notifications"
              checked={unifiedSettings.notifications.soundNotifications}
              onChange={(c) => updateNotificationSettings({ soundNotifications: c })}
              description="Play sound on notifications"
            />
            <SettingCheckbox
              label="Battle Notifications"
              checked={unifiedSettings.notifications.battleNotifications}
              onChange={(c) => updateNotificationSettings({ battleNotifications: c })}
              description="Notify on battle events"
            />
            <SettingCheckbox
              label="System Notifications"
              checked={unifiedSettings.notifications.systemNotifications}
              onChange={(c) => updateNotificationSettings({ systemNotifications: c })}
              description="General system notifications"
            />
            <MaterialMultiSelect
              label="Player Join Notifications"
              value={unifiedSettings.notifications.playerJoinNotifications}
              options={notificationTypeOptions}
              onChange={(vals) => updateNotificationSettings({ playerJoinNotifications: vals as any })}
              description="Notification channels when players join"
            />
            <MaterialMultiSelect
              label="Item Drop Notifications"
              value={unifiedSettings.notifications.itemDropNotifications}
              options={notificationTypeOptions}
              onChange={(vals) => updateNotificationSettings({ itemDropNotifications: vals as any })}
              description="Notification channels for item drops"
            />
            <MaterialMultiSelect
              label="Level Up Notifications"
              value={unifiedSettings.notifications.levelUpNotifications}
              options={notificationTypeOptions}
              onChange={(vals) => updateNotificationSettings({ levelUpNotifications: vals as any })}
              description="Notification channels on level up"
            />
            <MaterialMultiSelect
              label="Cataclysm Notifications"
              value={unifiedSettings.notifications.cataclysmNotifications}
              options={notificationTypeOptions}
              onChange={(vals) => updateNotificationSettings({ cataclysmNotifications: vals as any })}
              description="Notification channels when cataclysm starts"
            />
          </div>
        </MaterialCard>
      </div>
    </div>
  );
};

export default AudioModal;
</file>

<file path="packages/frontend/src/components/settings/GameplayModal.tsx">
import React from 'react';
import { useGameStore } from '../../stores/gameStore';
import { SettingCheckbox, SettingDropdown } from '../shared/settings';
import { DropdownOption } from '../shared/settings/SettingDropdown';
import { MovementStyle } from 'shared';
import { MaterialCard } from '../index';

const GameplayModal: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  const { unifiedSettings, updateGameSettings } = useGameStore();

  const movementStyleOptions: DropdownOption[] = [
    { value: MovementStyle.GRID, label: 'Grid Movement' },
    { value: MovementStyle.FREE, label: 'Free Movement' },
    { value: MovementStyle.HYBRID, label: 'Hybrid Movement' },
  ];

  return (
    <div className="p-6 h-full overflow-auto jetbrains bg-gradient-to-br from-gray-900/95 to-gray-800/90">
      {/* Modal Header */}
      <div className="flex items-center justify-between mb-8 pb-4 border-b-2 border-green-500/30">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-green-500 to-green-600 flex items-center justify-center shadow-lg shadow-green-500/30">
            <span className="text-2xl">ðŸŽ®</span>
          </div>
          <div>
            <h1 className="m-0 text-text-primary text-2xl font-bold shadow-lg shadow-black/30">
              Gameplay
            </h1>
            <p className="mt-1 m-0 text-text-secondary text-sm font-normal">
              Core game mechanics and preferences
            </p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="min-w-[40px] w-10 h-10 rounded-full bg-white/10 border-none text-text-primary cursor-pointer flex items-center justify-center text-xl transition-all duration-200 ease-out hover:bg-white/20 hover:scale-105 active:scale-95"
        >
          âœ•
        </button>
      </div>

      <div className="flex flex-col gap-6">
        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(76, 175, 80, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(76, 175, 80, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(76, 175, 80, 0.15)',
              borderColor: 'rgba(76, 175, 80, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-green-500 to-green-600 flex items-center justify-center">
              <span className="text-lg">ðŸŽ¯</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Core Gameplay
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingCheckbox
              label="Enable Auto-Save"
              checked={unifiedSettings.game.autoSaveEnabled}
              onChange={(c) => updateGameSettings({ autoSaveEnabled: c })}
              description="Automatically save progress periodically"
            />
            <SettingCheckbox
              label="Show Tutorials"
              checked={unifiedSettings.game.tutorialEnabled}
              onChange={(c) => updateGameSettings({ tutorialEnabled: c })}
              description="Display tutorial hints"
            />
            <SettingCheckbox
              label="Show Mini-map"
              checked={unifiedSettings.game.minimapEnabled}
              onChange={(c) => updateGameSettings({ minimapEnabled: c })}
              description="Toggle mini-map display"
            />
            <SettingDropdown
              label="Movement Style"
              value={unifiedSettings.game.movementStyle}
              options={movementStyleOptions}
              onChange={(v) => updateGameSettings({ movementStyle: v as MovementStyle })}
              description="How the player traverses the world"
            />
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(244, 67, 54, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(244, 67, 54, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(244, 67, 54, 0.15)',
              borderColor: 'rgba(244, 67, 54, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-red-500 to-red-600 flex items-center justify-center">
              <span className="text-lg">âš”ï¸</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Combat System
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingCheckbox
              label="Show Damage Numbers"
              checked={unifiedSettings.game.showDamageNumbers}
              onChange={(c) => updateGameSettings({ showDamageNumbers: c })}
              description="Visual floating damage indicators"
            />
            <SettingCheckbox
              label="Enable Auto-Combat"
              checked={unifiedSettings.game.autoCombatEnabled}
              onChange={(c) => updateGameSettings({ autoCombatEnabled: c })}
              description="Auto retaliate when attacked"
            />
          </div>
        </MaterialCard>
      </div>
    </div>
  );
};

export default GameplayModal;
</file>

<file path="packages/frontend/src/components/settings/OverviewModal.tsx">
import React from 'react';
import { useGameStore } from '../../stores/gameStore';
import { MaterialCard } from '../index';

/**
 * OverviewModal - World status and player information
 */
const OverviewModal: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  const { gameWorld, currentPlayer, gameMessage } = useGameStore();

  return (
    <div className="p-6 h-full overflow-auto font-mono bg-gradient-to-br from-background-primary/95 to-surface/90">
      {/* Modal Header */}
      <div className="flex items-center justify-between mb-8 pb-4 border-b-2 border-primary/30">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-blue-400 to-blue-600 flex items-center justify-center shadow-lg shadow-blue-500/30">
            <span className="text-2xl">ðŸ§­</span>
          </div>
          <div>
            <h1 className="m-0 text-text-primary text-2xl font-bold text-shadow">
              Overview
            </h1>
            <p className="mt-1 mb-0 text-text-secondary text-sm font-normal">
              World status and player information
            </p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="w-10 h-10 rounded-full bg-white/10 border-none text-text-primary cursor-pointer flex items-center justify-center text-lg transition-all duration-200 hover:bg-white/20 hover:scale-105"
        >
          âœ•
        </button>
      </div>

      <div className="flex flex-col gap-6">
        {/* World Snapshot */}
        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(33, 150, 243, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(33, 150, 243, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(33, 150, 243, 0.15)',
              borderColor: 'rgba(33, 150, 243, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-blue-400 to-blue-600 flex items-center justify-center">
              <span className="text-lg">ðŸ—ºï¸</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              World Snapshot
            </h3>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <div className="p-3 bg-blue-500/10 border border-blue-500/20 rounded-lg">
              <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                Phase
              </div>
              <div className="text-lg text-text-primary font-semibold">
                {gameWorld?.phase || 'N/A'}
              </div>
            </div>
            <div className="p-3 bg-green-500/10 border border-green-500/20 rounded-lg">
              <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                Players
              </div>
              <div className="text-lg text-text-primary font-semibold">
                {gameWorld ? gameWorld.players.length : 0}
              </div>
            </div>
            <div className="p-3 bg-orange-500/10 border border-orange-500/20 rounded-lg">
              <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                NPCs
              </div>
              <div className="text-lg text-text-primary font-semibold">
                {gameWorld ? gameWorld.npcs.length : 0}
              </div>
            </div>
            <div className="p-3 bg-purple-500/10 border border-purple-500/20 rounded-lg">
              <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                Items
              </div>
              <div className="text-lg text-text-primary font-semibold">
                {gameWorld ? gameWorld.items.length : 0}
              </div>
            </div>
            <div className="p-3 bg-cyan-500/10 border border-cyan-500/20 rounded-lg col-span-full">
              <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                World Age
              </div>
              <div className="text-lg text-text-primary font-semibold">
                {gameWorld?.worldAge || 0} cycles
              </div>
            </div>
          </div>
        </MaterialCard>

        {/* Current Player */}
        {currentPlayer && (
          <MaterialCard
            sx={{
              backgroundColor: 'rgba(25, 23, 36, 0.8)',
              backdropFilter: 'blur(10px)',
              border: '1px solid rgba(76, 175, 80, 0.2)',
              borderRadius: '16px',
              boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(76, 175, 80, 0.1)',
              transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
              '&:hover': {
                transform: 'translateY(-2px)',
                boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(76, 175, 80, 0.15)',
                borderColor: 'rgba(76, 175, 80, 0.3)'
              }
            }}
          >
            <div className="flex items-center gap-3 mb-5">
              <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-green-400 to-green-600 flex items-center justify-center">
                <span className="text-lg">ðŸ§‘</span>
              </div>
              <h3 className="m-0 text-text-primary text-lg font-semibold">
                Current Player
              </h3>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
              <div className="p-3 bg-green-500/10 border border-green-500/20 rounded-lg">
                <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                  Name
                </div>
                <div className="text-base text-text-primary font-semibold">
                  {currentPlayer.name}
                </div>
              </div>
              <div className="p-3 bg-red-500/10 border border-red-500/20 rounded-lg">
                <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                  Health
                </div>
                <div className="text-base text-text-primary font-semibold">
                  {currentPlayer.health}
                </div>
              </div>
              <div className="p-3 bg-orange-500/10 border border-orange-500/20 rounded-lg">
                <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                  Level
                </div>
                <div className="text-base text-text-primary font-semibold">
                  {currentPlayer.level}
                </div>
              </div>
              <div className="p-3 bg-purple-500/10 border border-purple-500/20 rounded-lg col-span-full">
                <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                  Position
                </div>
                <div className="text-base text-text-primary font-semibold font-mono">
                  {currentPlayer.position.x}, {currentPlayer.position.y}
                </div>
              </div>
            </div>
          </MaterialCard>
        )}

        {/* Game Message */}
        {gameMessage && (
          <MaterialCard
            sx={{
              backgroundColor: 'rgba(245, 158, 11, 0.1)',
              backdropFilter: 'blur(10px)',
              border: '1px solid rgba(245, 158, 11, 0.3)',
              borderRadius: '16px',
              boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(245, 158, 11, 0.1)',
              transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
              '&:hover': {
                transform: 'translateY(-2px)',
                boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(245, 158, 11, 0.15)',
                borderColor: 'rgba(245, 158, 11, 0.4)'
              }
            }}
          >
            <div className="flex items-center gap-3">
              <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-yellow-400 to-yellow-600 flex items-center justify-center">
                <span className="text-lg">ðŸ’¬</span>
              </div>
              <div className="flex-1">
                <div className="text-xs text-text-secondary mb-1 uppercase tracking-wider font-medium">
                  Game Message
                </div>
                <div className="text-text-primary text-sm leading-relaxed">
                  {gameMessage}
                </div>
              </div>
            </div>
          </MaterialCard>
        )}
      </div>
    </div>
  );
};

export default OverviewModal;
</file>

<file path="packages/frontend/src/components/settings/VisualModal.tsx">
import React from 'react';
import { useGameStore } from '../../stores/gameStore';
import { SettingDropdown, SettingCheckbox, SettingSlider } from '../shared/settings';
import { DropdownOption } from '../shared/settings/SettingDropdown';
import { Theme } from 'shared';
import { MaterialCard } from '../index';

const VisualModal: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  const { unifiedSettings, updateVisualSettings, updateAnimationSettings } = useGameStore();

  const themeOptions: DropdownOption[] = [
    { value: Theme.DARK, label: 'ðŸŒ™ Dark Theme', icon: 'ðŸŒ™' },
    { value: Theme.LIGHT, label: 'â˜€ï¸ Light Theme', icon: 'â˜€ï¸' },
    { value: Theme.NIGHT, label: 'ðŸŒƒ Night Theme', icon: 'ðŸŒƒ' },
    { value: Theme.AUTO, label: 'ðŸ¤– Auto (System)', icon: 'ðŸ¤–' },
  ];

  const languageOptions: DropdownOption[] = [
    { value: 'en', label: 'ðŸ‡ºðŸ‡¸ English', icon: 'ðŸ‡ºðŸ‡¸' },
    { value: 'es', label: 'ðŸ‡ªðŸ‡¸ EspaÃ±ol', icon: 'ðŸ‡ªðŸ‡¸' },
    { value: 'fr', label: 'ðŸ‡«ðŸ‡· FranÃ§ais', icon: 'ðŸ‡«ðŸ‡·' },
    { value: 'de', label: 'ðŸ‡©ðŸ‡ª Deutsch', icon: 'ðŸ‡©ðŸ‡ª' },
    { value: 'jp', label: 'ðŸ‡¯ðŸ‡µ æ—¥æœ¬èªž', icon: 'ðŸ‡¯ðŸ‡µ' },
  ];

  const fillStyleOptions: DropdownOption[] = [
    { value: 'hachure', label: 'Hachure' },
    { value: 'solid', label: 'Solid' },
    { value: 'zigzag', label: 'Zigzag' },
    { value: 'cross-hatch', label: 'Cross-Hatch' },
    { value: 'dots', label: 'Dots' },
    { value: 'sunburst', label: 'Sunburst' },
    { value: 'dashed', label: 'Dashed' },
    { value: 'scrawl', label: 'Scrawl' },
  ];

  return (
    <div className="p-6 h-full overflow-auto font-mono bg-gradient-to-br from-background-primary/95 to-surface/90">
      {/* Modal Header */}
      <div className="flex items-center justify-between mb-8 pb-4 border-b-2 border-primary/30">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-purple-400 to-purple-600 flex items-center justify-center shadow-lg shadow-purple-500/30">
            <span className="text-2xl">ðŸ‘ï¸</span>
          </div>
          <div>
            <h1 className="m-0 text-text-primary text-2xl font-bold text-shadow">
              Visual
            </h1>
            <p className="mt-1 mb-0 text-text-secondary text-sm font-normal">
              Display and theme preferences
            </p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="w-10 h-10 rounded-full bg-white/10 border-none text-text-primary cursor-pointer flex items-center justify-center text-lg transition-all duration-200 hover:bg-white/20 hover:scale-105"
        >
          âœ•
        </button>
      </div>

      <div className="flex flex-col gap-6">
        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(156, 39, 176, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(156, 39, 176, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(156, 39, 176, 0.15)',
              borderColor: 'rgba(156, 39, 176, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-400 to-purple-600 flex items-center justify-center">
              <span className="text-lg">ðŸŽ¨</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Theme & UI
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingDropdown
              label="Theme"
              value={unifiedSettings.visual.theme}
              options={themeOptions}
              onChange={(v) => updateVisualSettings({ theme: v as Theme })}
              description="Color scheme preference"
            />
            <SettingDropdown
              label="Language"
              value={unifiedSettings.visual.language}
              options={languageOptions}
              onChange={(v) => updateVisualSettings({ language: v as string })}
              description="Interface language"
            />
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(156, 39, 176, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(156, 39, 176, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(156, 39, 176, 0.15)',
              borderColor: 'rgba(156, 39, 176, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-400 to-purple-600 flex items-center justify-center">
              <span className="text-lg">â™¿</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Accessibility
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingCheckbox
              label="High Contrast"
              checked={unifiedSettings.visual.highContrast}
              onChange={(c) => updateVisualSettings({ highContrast: c })}
              description="Increase contrast for readability"
            />
            <SettingCheckbox
              label="Reduce Motion"
              checked={unifiedSettings.visual.reduceMotion}
              onChange={(c) => updateVisualSettings({ reduceMotion: c })}
              description="Minimize non-essential animations"
            />
            <SettingCheckbox
              label="Show Grid"
              checked={unifiedSettings.visual.showGrid}
              onChange={(c) => updateVisualSettings({ showGrid: c })}
              description="Debug/display coordinate grid"
            />
            <SettingCheckbox
              label="Show Particles"
              checked={unifiedSettings.visual.showParticles}
              onChange={(c) => updateVisualSettings({ showParticles: c })}
              description="Enable particle effects"
            />
            <SettingCheckbox
              label="Show Health Bars"
              checked={unifiedSettings.visual.showHealthBars}
              onChange={(c) => updateVisualSettings({ showHealthBars: c })}
              description="Display entity health bars"
            />
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(156, 39, 176, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(156, 39, 176, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(156, 39, 176, 0.15)',
              borderColor: 'rgba(156, 39, 176, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-400 to-purple-600 flex items-center justify-center">
              <span className="text-lg">ðŸŽžï¸</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Animation & Drawing Style
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingSlider
              label="Animation Speed"
              value={unifiedSettings.animations.animationSpeed}
              min={0.1} max={3} step={0.1}
              onChange={(v) => updateAnimationSettings({ animationSpeed: v })}
              unit="x" showReset resetValue={1.0}
              description="Global animation speed multiplier"
            />
            <SettingSlider
              label="Particle Count"
              value={unifiedSettings.animations.particleCount}
              min={0} max={20} step={1}
              onChange={(v) => updateAnimationSettings({ particleCount: v })}
              showReset resetValue={5}
              description="Number of effect particles"
            />
            <SettingSlider
              label="Roughness"
              value={unifiedSettings.animations.roughness}
              min={0} max={5} step={0.1}
              onChange={(v) => updateAnimationSettings({ roughness: v })}
              showReset resetValue={1.5}
              description="Hand-drawn roughness"
            />
            <SettingSlider
              label="Bowing"
              value={unifiedSettings.animations.bowing}
              min={0} max={5} step={0.1}
              onChange={(v) => updateAnimationSettings({ bowing: v })}
              showReset resetValue={1.2}
              description="Curvature of lines"
            />
            <SettingSlider
              label="Fill Weight"
              value={unifiedSettings.animations.fillWeight}
              min={0} max={5} step={0.1}
              onChange={(v) => updateAnimationSettings({ fillWeight: v })}
              showReset resetValue={1.5}
              description="Thickness of fills"
            />
            <SettingSlider
              label="Hachure Angle"
              value={unifiedSettings.animations.hachureAngle}
              min={0} max={180} step={15}
              onChange={(v) => updateAnimationSettings({ hachureAngle: v })}
              unit="Â°" showReset resetValue={45}
              description="Angle for hatching"
            />
            <SettingSlider
              label="Hachure Gap"
              value={unifiedSettings.animations.hachureGap}
              min={1} max={20} step={1}
              onChange={(v) => updateAnimationSettings({ hachureGap: v })}
              showReset resetValue={4}
              description="Spacing of hatch lines"
            />
            <SettingDropdown
              label="Fill Style"
              value={unifiedSettings.animations.fillStyle || 'hachure'}
              options={fillStyleOptions}
              onChange={(v) => updateAnimationSettings({ fillStyle: String(v) })}
              description="Rough.js fill style"
            />
            <SettingSlider
              label="Random Seed"
              value={unifiedSettings.animations.seed || 1}
              min={1} max={10000} step={1}
              onChange={(v) => updateAnimationSettings({ seed: v })}
              showReset resetValue={1}
              description="Seed for deterministic randomness"
            />
          </div>
        </MaterialCard>
      </div>
    </div>
  );
};

export default VisualModal;
</file>

<file path="packages/frontend/src/components/settings/WorldModal.tsx">
import React from 'react';
import { useGameStore } from '../../stores/gameStore';
import { SettingSlider } from '../shared/settings';
import { SettingCheckbox } from '../shared/settings';
import { MaterialCard } from '../index';

const WorldModal: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  const { unifiedSettings, updateWorldSettings, updateAnimationSettings } = useGameStore();

  return (
    <div className="p-6 h-full overflow-auto font-mono bg-gradient-to-br from-background-primary/95 to-surface/90">
      {/* Modal Header */}
      <div className="flex items-center justify-between mb-8 pb-4 border-b-2 border-primary/30">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-cyan-400 to-cyan-600 flex items-center justify-center shadow-lg shadow-cyan-500/30">
            <span className="text-2xl">ðŸŒ</span>
          </div>
          <div>
            <h1 className="m-0 text-text-primary text-2xl font-bold text-shadow">
              World
            </h1>
            <p className="mt-1 mb-0 text-text-secondary text-sm font-normal">
              Environment and world generation
            </p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="w-10 h-10 rounded-full bg-white/10 border-none text-text-primary cursor-pointer flex items-center justify-center text-lg transition-all duration-200 hover:bg-white/20 hover:scale-105"
        >
          âœ•
        </button>
      </div>

      <div className="flex flex-col gap-6">
        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(0, 188, 212, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 188, 212, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 188, 212, 0.15)',
              borderColor: 'rgba(0, 188, 212, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-cyan-400 to-cyan-600 flex items-center justify-center">
              <span className="text-lg">ðŸ“</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              World Dimensions
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingSlider
              label="World Width"
              value={unifiedSettings.world.worldWidth}
              min={20} max={100} step={5}
              onChange={(v) => updateWorldSettings({ worldWidth: v })}
              unit=" tiles" showReset resetValue={40}
              description="Horizontal size"
            />
            <SettingSlider
              label="World Height"
              value={unifiedSettings.world.worldHeight}
              min={15} max={75} step={3}
              onChange={(v) => updateWorldSettings({ worldHeight: v })}
              unit=" tiles" showReset resetValue={30}
              description="Vertical size"
            />
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(0, 188, 212, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 188, 212, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 188, 212, 0.15)',
              borderColor: 'rgba(0, 188, 212, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-cyan-400 to-cyan-600 flex items-center justify-center">
              <span className="text-lg">ðŸŒ¿</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Environment Animation
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingSlider
              label="Grass Wave Speed"
              value={unifiedSettings.world.grassWaveSpeed}
              min={0} max={1} step={0.1}
              onChange={(v) => updateWorldSettings({ grassWaveSpeed: v })}
              showReset resetValue={0.1}
              description="Grass sway speed"
            />
            <SettingSlider
              label="Tree Sway Speed"
              value={unifiedSettings.world.treeSwaySpeed}
              min={0} max={1} step={0.1}
              onChange={(v) => updateWorldSettings({ treeSwaySpeed: v })}
              showReset resetValue={0.03}
              description="Tree movement speed"
            />
            <SettingSlider
              label="Flower Spawn Rate"
              value={unifiedSettings.world.flowerSpawnRate}
              min={0} max={1} step={0.1}
              onChange={(v) => updateWorldSettings({ flowerSpawnRate: v })}
              showReset resetValue={0.01}
              description="Spawn rate of flowers"
            />
            <SettingSlider
              label="Wind Speed"
              value={unifiedSettings.world.windSpeed}
              min={0} max={1} step={0.1}
              onChange={(v) => updateWorldSettings({ windSpeed: v })}
              showReset resetValue={0.02}
              description="Global wind agitation"
            />
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(0, 188, 212, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 188, 212, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 188, 212, 0.15)',
              borderColor: 'rgba(0, 188, 212, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-cyan-400 to-cyan-600 flex items-center justify-center">
              <span className="text-lg">ðŸŒ™</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              World Rendering
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <SettingCheckbox
              label="Night Mode"
              checked={unifiedSettings.world.nightMode}
              onChange={(checked) => updateWorldSettings({ nightMode: checked })}
              description="Enable night time rendering effects in the game world"
            />
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(0, 188, 212, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 188, 212, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 188, 212, 0.15)',
              borderColor: 'rgba(0, 188, 212, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-cyan-400 to-cyan-600 flex items-center justify-center">
              <span className="text-lg">ðŸŽ¨</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Rough.js Styling
            </h3>
          </div>
          <div className="flex flex-col gap-4">
            <div className="text-sm text-text-secondary mb-2">
              Advanced rough.js drawing style controls for hand-drawn aesthetics.
            </div>

            {/* Basic Roughness Controls */}
            <div className="grid grid-cols-2 gap-4">
              <SettingSlider
                label="Roughness"
                value={unifiedSettings.animations.roughness}
                min={0} max={10} step={0.1}
                onChange={(v) => updateAnimationSettings({ roughness: v })}
                showReset resetValue={1.5}
                description="Overall sketchiness"
              />
              <SettingSlider
                label="Bowing"
                value={unifiedSettings.animations.bowing}
                min={0} max={10} step={0.1}
                onChange={(v) => updateAnimationSettings({ bowing: v })}
                showReset resetValue={1.2}
                description="Line curvature"
              />
            </div>

            {/* Stroke and Fill Controls */}
            <div className="grid grid-cols-2 gap-4">
              <SettingSlider
                label="Stroke Width"
                value={unifiedSettings.animations.strokeWidth}
                min={0.1} max={5} step={0.1}
                onChange={(v) => updateAnimationSettings({ strokeWidth: v })}
                showReset resetValue={1.5}
                description="Line thickness"
              />
              <SettingSlider
                label="Fill Weight"
                value={unifiedSettings.animations.fillWeight}
                min={0} max={5} step={0.1}
                onChange={(v) => updateAnimationSettings({ fillWeight: v })}
                showReset resetValue={1.5}
                description="Fill density"
              />
            </div>

            {/* Hachure Controls */}
            <div className="grid grid-cols-2 gap-4">
              <SettingSlider
                label="Hachure Angle"
                value={unifiedSettings.animations.hachureAngle}
                min={-180} max={180} step={5}
                onChange={(v) => updateAnimationSettings({ hachureAngle: v })}
                showReset resetValue={45}
                description="Hatch direction"
              />
              <SettingSlider
                label="Hachure Gap"
                value={unifiedSettings.animations.hachureGap}
                min={1} max={20} step={0.5}
                onChange={(v) => updateAnimationSettings({ hachureGap: v })}
                showReset resetValue={4}
                description="Hatch spacing"
              />
            </div>

            {/* Curve Controls */}
            <div className="grid grid-cols-3 gap-4">
              <SettingSlider
                label="Curve Fitting"
                value={unifiedSettings.animations.curveFitting}
                min={0} max={1} step={0.01}
                onChange={(v) => updateAnimationSettings({ curveFitting: v })}
                showReset resetValue={0.95}
                description="Curve smoothness"
              />
              <SettingSlider
                label="Curve Tightness"
                value={unifiedSettings.animations.curveTightness}
                min={0} max={1} step={0.01}
                onChange={(v) => updateAnimationSettings({ curveTightness: v })}
                showReset resetValue={0}
                description="Curve tension"
              />
              <SettingSlider
                label="Curve Steps"
                value={unifiedSettings.animations.curveStepCount}
                min={3} max={20} step={1}
                onChange={(v) => updateAnimationSettings({ curveStepCount: v })}
                showReset resetValue={9}
                description="Curve resolution"
              />
            </div>

            {/* Advanced Controls */}
            <div className="grid grid-cols-2 gap-4">
              <SettingSlider
                label="Simplification"
                value={unifiedSettings.animations.simplification}
                min={0} max={1} step={0.01}
                onChange={(v) => updateAnimationSettings({ simplification: v })}
                showReset resetValue={0.8}
                description="Shape simplification"
              />
              <SettingSlider
                label="Fill Roughness Gain"
                value={unifiedSettings.animations.fillShapeRoughnessGain}
                min={0} max={2} step={0.01}
                onChange={(v) => updateAnimationSettings({ fillShapeRoughnessGain: v })}
                showReset resetValue={0.8}
                description="Fill roughness boost"
              />
            </div>

            {/* Dash and Zigzag Controls */}
            <div className="grid grid-cols-3 gap-4">
              <SettingSlider
                label="Dash Offset"
                value={unifiedSettings.animations.dashOffset}
                min={0} max={10} step={0.1}
                onChange={(v) => updateAnimationSettings({ dashOffset: v })}
                showReset resetValue={0}
                description="Dash pattern offset"
              />
              <SettingSlider
                label="Dash Gap"
                value={unifiedSettings.animations.dashGap}
                min={0} max={10} step={0.1}
                onChange={(v) => updateAnimationSettings({ dashGap: v })}
                showReset resetValue={0}
                description="Dash gap size"
              />
              <SettingSlider
                label="Zigzag Offset"
                value={unifiedSettings.animations.zigzagOffset}
                min={0} max={10} step={0.1}
                onChange={(v) => updateAnimationSettings({ zigzagOffset: v })}
                showReset resetValue={0}
                description="Zigzag amplitude"
              />
            </div>

            {/* Random Seed */}
            <div className="grid grid-cols-1 gap-4">
              <SettingSlider
                label="Random Seed"
                value={unifiedSettings.animations.seed}
                min={0} max={1000} step={1}
                onChange={(v) => updateAnimationSettings({ seed: v })}
                showReset resetValue={1}
                description="Randomness seed for consistent patterns"
              />
            </div>

            {/* Boolean Toggles */}
            <div className="grid grid-cols-2 gap-4">
              <SettingCheckbox
                label="Disable Multi-Stroke"
                checked={unifiedSettings.animations.disableMultiStroke}
                onChange={(checked) => updateAnimationSettings({ disableMultiStroke: checked })}
                description="Single stroke only"
              />
              <SettingCheckbox
                label="Disable Multi-Stroke Fill"
                checked={unifiedSettings.animations.disableMultiStrokeFill}
                onChange={(checked) => updateAnimationSettings({ disableMultiStrokeFill: checked })}
                description="Single fill stroke"
              />
            </div>

            <div className="grid grid-cols-1 gap-4">
              <SettingCheckbox
                label="Preserve Vertices"
                checked={unifiedSettings.animations.preserveVertices}
                onChange={(checked) => updateAnimationSettings({ preserveVertices: checked })}
                description="Keep original shape points"
              />
            </div>
          </div>
        </MaterialCard>
      </div>
    </div>
  );
};

export default WorldModal;
</file>

<file path="packages/frontend/src/components/shared/settings/index.ts">
// Legacy components
export { default as SettingSlider } from './SettingSlider';
export { default as SettingCheckbox } from './SettingCheckbox';
export { default as SettingDropdown } from './SettingDropdown';
export { default as SettingGroup } from './SettingGroup';

// New Material Design 3 components
export { default as MaterialSlider } from './MaterialSlider';
export { default as MaterialCheckbox } from './MaterialCheckbox';
export { default as MaterialDropdown } from './MaterialDropdown';
export { default as MaterialGroup } from './MaterialGroup';
export { default as MaterialMultiSelect } from './MaterialMultiSelect';

// Export types for easier importing
export type { DropdownOption } from './SettingDropdown';
export type { MaterialDropdownOption } from './MaterialDropdown';
</file>

<file path="packages/frontend/src/components/shared/settings/MaterialCheckbox.tsx">
import React from 'react';
import { FormControlLabel, Checkbox, Typography, Box } from '@mui/material';

interface MaterialCheckboxProps {
  label: string;
  checked: boolean;
  onChange: (checked: boolean) => void;
  description?: string;
  disabled?: boolean;
}

const MaterialCheckbox: React.FC<MaterialCheckboxProps> = ({
  label,
  checked,
  onChange,
  description,
  disabled = false,
}) => {
  return (
    <Box>
      <FormControlLabel
        control={
          <Checkbox
            checked={checked}
            onChange={(event) => onChange(event.target.checked)}
            disabled={disabled}
            sx={{
              '&.Mui-checked': {
                color: 'primary.main',
              },
            }}
          />
        }
        label={
          <Box>
            <Typography variant="body1" gutterBottom={false}>
              {label}
            </Typography>
            {description && (
              <Typography variant="body2" color="text.secondary">
                {description}
              </Typography>
            )}
          </Box>
        }
      />
    </Box>
  );
};

export default MaterialCheckbox;
</file>

<file path="packages/frontend/src/components/shared/settings/MaterialDropdown.tsx">
import React from 'react';
import {
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Typography,
  Box,
  SelectChangeEvent,
} from '@mui/material';

export interface MaterialDropdownOption {
  value: string | number;
  label: string;
  icon?: string;
}

interface MaterialDropdownProps {
  label: string;
  value: string | number;
  options: MaterialDropdownOption[];
  onChange: (value: string | number) => void;
  description?: string;
  disabled?: boolean;
  showIcons?: boolean;
}

const MaterialDropdown: React.FC<MaterialDropdownProps> = ({
  label,
  value,
  options,
  onChange,
  description,
  disabled = false,
  showIcons = true,
}) => {
  const handleChange = (event: SelectChangeEvent<string | number>) => {
    const selectedValue = event.target.value;
    onChange(selectedValue);
  };

  return (
    <Box sx={{ width: '100%' }}>
      <FormControl fullWidth>
        <InputLabel
          sx={{
            fontFamily: 'JetBrains Mono',
            fontWeight: 500,
            color: 'text.secondary',
            '&.Mui-focused': {
              color: 'primary.main',
            },
          }}
        >
          {label}
        </InputLabel>
        <Select
          value={value}
          onChange={handleChange}
          label={label}
          disabled={disabled}
          sx={{
            fontFamily: 'JetBrains Mono',
            borderRadius: '12px',
            backgroundColor: 'rgba(25, 23, 36, 0.6)',
            backdropFilter: 'blur(10px)',
            border: '1px solid',
            borderColor: 'rgba(196, 167, 231, 0.2)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              backgroundColor: 'rgba(25, 23, 36, 0.8)',
              borderColor: 'rgba(196, 167, 231, 0.4)',
              boxShadow: '0 4px 12px rgba(196, 167, 231, 0.15)',
            },
            '&.Mui-focused': {
              backgroundColor: 'rgba(25, 23, 36, 0.9)',
              borderColor: 'primary.main',
              boxShadow: '0 0 0 3px rgba(196, 167, 231, 0.1)',
            },
            '& .MuiSelect-select': {
              display: 'flex',
              alignItems: 'center',
              gap: 1,
              padding: '12px 16px',
            },
            '& .MuiOutlinedInput-notchedOutline': {
              border: 'none',
            },
          }}
          MenuProps={{
            PaperProps: {
              sx: {
                backgroundColor: 'rgba(25, 23, 36, 0.95)',
                backdropFilter: 'blur(20px)',
                border: '1px solid',
                borderColor: 'rgba(196, 167, 231, 0.2)',
                borderRadius: '12px',
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(196, 167, 231, 0.1)',
                marginTop: '8px',
                '& .MuiMenuItem-root': {
                  fontFamily: 'JetBrains Mono',
                  padding: '12px 16px',
                  borderRadius: '8px',
                  margin: '4px 8px',
                  transition: 'all 0.2s cubic-bezier(0.4, 0, 0.2, 1)',
                  '&:hover': {
                    backgroundColor: 'rgba(196, 167, 231, 0.1)',
                    transform: 'translateX(4px)',
                  },
                  '&.Mui-selected': {
                    backgroundColor: 'rgba(196, 167, 231, 0.2)',
                    '&:hover': {
                      backgroundColor: 'rgba(196, 167, 231, 0.25)',
                    },
                  },
                },
              },
            },
          }}
        >
          {options.map((option) => (
            <MenuItem
              key={option.value}
              value={option.value}
              sx={{
                display: 'flex',
                alignItems: 'center',
                gap: 1.5,
                fontFamily: 'JetBrains Mono',
                fontWeight: 500,
                '&:hover .option-icon': {
                  transform: 'scale(1.1)',
                },
              }}
            >
              {showIcons && option.icon && (
                <span
                  className="option-icon"
                  style={{
                    fontSize: '1.2em',
                    transition: 'transform 0.2s cubic-bezier(0.4, 0, 0.2, 1)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >
                  {option.icon}
                </span>
              )}
              <Typography
                variant="body1"
                sx={{
                  fontFamily: 'JetBrains Mono',
                  fontWeight: 500,
                  color: 'text.primary'
                }}
              >
                {option.label}
              </Typography>
            </MenuItem>
          ))}
        </Select>
      </FormControl>

      {description && (
        <Typography
          variant="body2"
          sx={{
            mt: 1.5,
            color: 'text.secondary',
            fontFamily: 'JetBrains Mono',
            fontSize: '0.8rem',
            lineHeight: 1.4,
          }}
        >
          {description}
        </Typography>
      )}
    </Box>
  );
};

export default MaterialDropdown;
</file>

<file path="packages/frontend/src/components/shared/settings/MaterialGroup.tsx">
import React from 'react';
import { Paper, Typography, Box } from '@mui/material';

interface MaterialGroupProps {
  title?: string;
  icon?: string;
  children: React.ReactNode;
  elevation?: number;
}

const MaterialGroup: React.FC<MaterialGroupProps> = ({
  title,
  icon,
  children,
  elevation = 1,
}) => {
  return (
    <Paper
      elevation={elevation}
      sx={{
        p: 3,
        mb: 3,
        backgroundColor: 'background.paper',
        border: '1px solid',
        borderColor: 'divider',
        borderRadius: 2,
      }}
    >
      {title && (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
          {icon && (
            <Box sx={{ fontSize: '1.5em', lineHeight: 1 }}>
              {icon}
            </Box>
          )}
          <Typography
            variant="h6"
            sx={{
              fontFamily: 'JetBrains Mono',
              fontWeight: 600,
              color: 'text.primary',
              mb: 0,
            }}
          >
            {title}
          </Typography>
        </Box>
      )}

      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
        {children}
      </Box>
    </Paper>
  );
};

export default MaterialGroup;
</file>

<file path="packages/frontend/src/components/shared/settings/MaterialMultiSelect.tsx">
import React from 'react';
import { FormControl, InputLabel, Select, MenuItem, Checkbox, ListItemText, Box, Typography } from '@mui/material';

interface MaterialMultiSelectProps {
  label: string;
  value: string[];
  options: { value: string; label: string }[];
  onChange: (values: string[]) => void;
  description?: string;
}

const MaterialMultiSelect: React.FC<MaterialMultiSelectProps> = ({ label, value, options, onChange, description }) => {
  const handleChange = (event: any) => {
    const v = event.target.value as string[];
    onChange(v);
  };

  return (
    <Box sx={{ width: '100%' }} className="mb-3">
      <FormControl fullWidth>
        <InputLabel>{label}</InputLabel>
        <Select
          multiple
          value={value}
          onChange={handleChange}
          renderValue={(selected) => (
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
              {(selected as string[]).map((s) => (
                <Typography key={s} sx={{ fontSize: '0.8rem' }}>{s}</Typography>
              ))}
            </Box>
          )}
        >
          {options.map((opt) => (
            <MenuItem key={opt.value} value={opt.value}>
              <Checkbox checked={value.indexOf(opt.value) > -1} />
              <ListItemText primary={opt.label} />
            </MenuItem>
          ))}
        </Select>
      </FormControl>
      {description && (
        <Typography variant="body2" sx={{ mt: 0.5, color: 'text.secondary' }}>{description}</Typography>
      )}
    </Box>
  );
};

export default MaterialMultiSelect;
</file>

<file path="packages/frontend/src/components/shared/settings/MaterialSlider.tsx">
import React from 'react';
import { Slider, Typography, Box, IconButton } from '@mui/material';
import RefreshIcon from '@mui/icons-material/Refresh';

interface MaterialSliderProps {
  label: string;
  value: number;
  min: number;
  max: number;
  step?: number;
  onChange: (value: number) => void;
  unit?: string;
  description?: string;
  showReset?: boolean;
  resetValue?: number;
  onReset?: () => void;
  disabled?: boolean;
}

const MaterialSlider: React.FC<MaterialSliderProps> = ({
  label,
  value,
  min,
  max,
  step = 1,
  onChange,
  unit = '',
  description,
  showReset = false,
  resetValue,
  onReset,
  disabled = false,
}) => {
  const marks = step >= 1 ? [
    { value: min, label: `${min}${unit}` },
    { value: max, label: `${max}${unit}` },
  ] : undefined;

  return (
    <Box sx={{ width: '100%' }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
        <Typography variant="body1" sx={{ flex: 1 }}>
          {label}: {value}{unit}
        </Typography>
        {showReset && onReset && (
          <IconButton
            size="small"
            onClick={onReset}
            sx={{ color: 'text.secondary' }}
            disabled={disabled}
          >
            <RefreshIcon fontSize="small" />
          </IconButton>
        )}
      </Box>

      <Slider
        value={value}
        min={min}
        max={max}
        step={step}
        onChange={(_, newValue) => onChange(newValue as number)}
        disabled={disabled}
        marks={marks}
        valueLabelDisplay="auto"
        sx={{
          '& .MuiSlider-markLabel': {
            fontSize: '0.75rem',
            fontWeight: 600,
          },
        }}
      />

      {description && (
        <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
          {description}
        </Typography>
      )}
    </Box>
  );
};

export default MaterialSlider;
</file>

<file path="packages/frontend/src/components/shared/settings/SettingCheckbox.tsx">
import React from 'react';
import { FormControlLabel, Checkbox, Typography, Box } from '@mui/material';

interface SettingCheckboxProps {
  label: string;
  checked: boolean;
  onChange: (checked: boolean) => void;
  description?: string;
  className?: string;
}

const SettingCheckbox: React.FC<SettingCheckboxProps> = ({
  label,
  checked,
  onChange,
  description,
  className = ''
}) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(e.target.checked);
  };

  return (
    <Box className={`flex items-start mb-2 ${className}`}>
      <FormControlLabel
        control={
          <Checkbox
            checked={checked}
            onChange={handleChange}
            className="text-primary"
          />
        }
        label={
          <Box className="ml-2">
            <Typography className="text-primary text-sm font-medium mb-0.5">
              {label}
            </Typography>
            {description && (
              <Typography className="text-secondary text-xs italic">
                {description}
              </Typography>
            )}
          </Box>
        }
        sx={{
          alignItems: 'flex-start',
          margin: 0,
          width: '100%',
        }}
      />
    </Box>
  );
};

export default SettingCheckbox;
</file>

<file path="packages/frontend/src/components/shared/settings/SettingDropdown.tsx">
import React from 'react';
import { FormControl, Select, MenuItem, Typography, Box, FormLabel } from '@mui/material';

export interface DropdownOption {
  value: string | number;
  label: string;
  icon?: string;
}

interface SettingDropdownProps {
  label: string;
  value: string | number;
  options: DropdownOption[];
  onChange: (value: string | number) => void;
  description?: string;
  className?: string;
}

const SettingDropdown: React.FC<SettingDropdownProps> = ({
  label,
  value,
  options,
  onChange,
  description,
  className = ''
}) => {
  const handleChange = (event: any) => {
    onChange(event.target.value);
  };

  return (
    <Box className={`control-group dropdown ${className}`} sx={{ mb: 2 }}>
      <FormLabel sx={{
        fontFamily: 'JetBrains Mono',
        fontSize: '0.9rem',
        fontWeight: 500,
        color: 'var(--color-text-primary)',
        mb: 1,
        display: 'block',
      }}>
        {label}
      </FormLabel>

      <FormControl fullWidth>
        <Select
          value={value}
          onChange={handleChange}
          sx={{
            backgroundColor: 'var(--color-surface-variant)',
            color: 'var(--color-text-primary)',
            borderRadius: '8px',
            '& .MuiOutlinedInput-notchedOutline': {
              borderColor: 'var(--color-outline)',
            },
            '&:hover .MuiOutlinedInput-notchedOutline': {
              borderColor: 'var(--color-primary)',
            },
            '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
              borderColor: 'var(--color-primary)',
              borderWidth: '2px',
            },
            '& .MuiSelect-icon': {
              color: 'var(--color-text-secondary)',
            },
          }}
          MenuProps={{
            PaperProps: {
              sx: {
                backgroundColor: 'var(--color-surface)',
                border: '1px solid var(--color-outline)',
                borderRadius: '8px',
                '& .MuiMenuItem-root': {
                  color: 'var(--color-text-primary)',
                  fontFamily: 'JetBrains Mono',
                  fontSize: '0.9rem',
                  '&:hover': {
                    backgroundColor: 'var(--color-primary-container)',
                    color: 'var(--color-on-primary-container)',
                  },
                  '&.Mui-selected': {
                    backgroundColor: 'var(--color-primary)',
                    color: 'var(--color-on-primary)',
                    '&:hover': {
                      backgroundColor: 'var(--color-primary)',
                    },
                  },
                },
              },
            },
          }}
        >
          {options.map((option) => (
            <MenuItem key={option.value} value={option.value}>
              {option.label}
            </MenuItem>
          ))}
        </Select>
      </FormControl>

      {description && (
        <Typography
          sx={{
            fontFamily: 'JetBrains Mono',
            fontSize: '0.8rem',
            color: 'var(--color-text-secondary)',
            fontStyle: 'italic',
            mt: 0.5,
          }}
        >
          {description}
        </Typography>
      )}
    </Box>
  );
};

export default SettingDropdown;
</file>

<file path="packages/frontend/src/components/shared/settings/SettingGroup.tsx">
import React from 'react';

interface SettingGroupProps {
  title: string;
  icon?: string;
  description?: string;
  className?: string;
  children: React.ReactNode;
}

const SettingGroup: React.FC<SettingGroupProps> = ({
  title,
  icon,
  description,
  className = '',
  children
}) => {
  return (
    <div className={`settings-category ${className}`}>
      <h5>
        {icon && <span className="category-icon">{icon}</span>}
        {title}
      </h5>
      {description && (
        <p className="category-description">{description}</p>
      )}
      {children}
    </div>
  );
};

export default SettingGroup;
</file>

<file path="packages/frontend/src/components/shared/settings/SettingSlider.tsx">
import React from 'react';
import { Slider, Typography, Box, Button, FormLabel } from '@mui/material';
import { RestartAlt as ResetIcon } from '@mui/icons-material';

interface SettingSliderProps {
  label: string;
  value: number;
  min: number;
  max: number;
  step: number;
  onChange: (value: number) => void;
  unit?: string;
  showReset?: boolean;
  resetValue?: number;
  description?: string;
  className?: string;
}

const SettingSlider: React.FC<SettingSliderProps> = ({
  label,
  value,
  min,
  max,
  step,
  onChange,
  unit = '',
  showReset = false,
  resetValue,
  description,
  className = ''
}) => {
  const handleSliderChange = (_event: Event, newValue: number | number[]) => {
    onChange(newValue as number);
  };

  const handleReset = () => {
    if (resetValue !== undefined) {
      onChange(resetValue);
    }
  };

  return (
    <Box sx={{ mb: 3 }} className={className}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
        <FormLabel sx={{ fontFamily: 'JetBrains Mono', fontSize: '0.875rem', fontWeight: 500, color: 'text.primary' }}>
          {label}
        </FormLabel>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Typography sx={{ fontFamily: 'JetBrains Mono', fontSize: '0.875rem', fontWeight: 600, color: 'primary', minWidth: '60px', textAlign: 'right' }}>
            {value}{unit}
          </Typography>
          {showReset && resetValue !== undefined && (
            <Button
              size="small"
              onClick={handleReset}
              startIcon={<ResetIcon />}
              sx={{
                minWidth: 'auto',
                px: 1,
                py: 0.5,
                fontSize: '0.75rem',
                fontFamily: 'JetBrains Mono',
                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                color: 'text.secondary',
                border: '1px solid rgba(139, 92, 246, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(139, 92, 246, 0.2)',
                  borderColor: 'rgba(139, 92, 246, 0.4)'
                }
              }}
              title={`Reset to ${resetValue}${unit}`}
            >
              Reset
            </Button>
          )}
        </Box>
      </Box>

      <Slider
        value={value}
        onChange={handleSliderChange}
        min={min}
        max={max}
        step={step}
        sx={{
          color: 'primary.main',
          '& .MuiSlider-thumb': {
            width: 20,
            height: 20,
            backgroundColor: 'primary.main',
            border: '2px solid',
            borderColor: 'primary.contrastText',
            '&:hover, &.Mui-focusVisible': {
              boxShadow: `0 0 0 8px rgba(137, 180, 250, 0.16)`,
            },
          },
          '& .MuiSlider-track': {
            height: 6,
            backgroundColor: 'primary.main',
          },
          '& .MuiSlider-rail': {
            height: 6,
            backgroundColor: 'rgba(255, 255, 255, 0.2)',
          },
        }}
      />

      {description && (
        <Typography sx={{ fontFamily: 'JetBrains Mono', fontSize: '0.75rem', color: 'text.secondary', fontStyle: 'italic', mt: 0.5 }}>
          {description}
        </Typography>
      )}
    </Box>
  );
};

export default SettingSlider;
</file>

<file path="packages/frontend/src/components/shared/CategoryButton.tsx">
import React from 'react';
import { MaterialButton } from '../index';
import { COLORS } from '../../utils/tokens';

type CategoryButtonProps = {
  id: string;
  Icon: React.ComponentType<any>;
  onClick: () => void;
  ariaLabel?: string;
  colorToken?: string; // dot-path into COLORS, e.g. 'primary' or 'health.healthy'
  buttonRef?: (el: HTMLButtonElement | null) => void;
};

function getTokenColor(path?: string): string {
  if (!path) return '#888888';
  const parts = path.split('.');
  let cur: any = COLORS;
  for (const p of parts) {
    if (!cur) return '#888888';
    cur = cur[p];
  }
  return typeof cur === 'string' ? cur : '#888888';
}

function hexToRgb(hex: string) {
  const cleaned = hex.replace('#', '');
  const bigint = parseInt(cleaned.length === 3 ? cleaned.split('').map(c => c + c).join('') : cleaned, 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return `${r}, ${g}, ${b}`;
}

function rgba(hex: string, a: number) {
  const rgb = hexToRgb(hex);
  return `rgba(${rgb}, ${a})`;
}

const CategoryButton: React.FC<CategoryButtonProps> = ({ id, Icon, onClick, ariaLabel, colorToken, buttonRef }) => {
  const base = getTokenColor(colorToken);
  const bg = rgba(base, 0.12);
  const bgHover = rgba(base, 0.18);
  const border = rgba(base, 0.22);
  const shadow = rgba(base, 0.16);

  return (
    <MaterialButton
      key={id}
      ref={buttonRef as any}
      onClick={onClick}
      sx={{
        minWidth: '60px',
        width: '60px',
        height: '60px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        p: 0,
        borderRadius: 1,
        backgroundColor: bg,
        border: `1px solid ${border}`,
        color: 'var(--color-text-primary)',
        transition: 'all 0.2s cubic-bezier(0.4, 0, 0.2, 1)',
        '&:hover': {
          backgroundColor: bgHover,
          borderColor: base,
          transform: 'translateY(-6px) scale(1.05)',
          boxShadow: `0 8px 20px ${shadow}`,
        },
      }}
    >
      <Icon sx={{ fontSize: '2.2rem' }} aria-label={ariaLabel || id} />
    </MaterialButton>
  );
};

export default CategoryButton;
</file>

<file path="packages/frontend/src/components/shared/Panel.tsx">
import React from 'react';
import { MaterialCard } from '../index';

type PanelProps = {
  title?: React.ReactNode;
  children?: React.ReactNode;
  sx?: any;
};

const Panel: React.FC<PanelProps> = ({ title, children, sx }) => {
  const mergedSx = { p: 2, backgroundColor: 'var(--color-surface-variant)', ...(sx || {}) };
  return (
    <MaterialCard sx={mergedSx}>
      {title ? <h4 className="m-0 mb-3 text-text-primary">{title}</h4> : null}
      {children}
    </MaterialCard>
  );
};

export default Panel;
</file>

<file path="packages/frontend/src/components/sidebar/CategoryNavigation.tsx">
import React from 'react';

interface Category {
  id: string;
  label: string;
  icon: string;
}

interface CategoryNavigationProps {
  categories: Category[];
  activeCategory: string;
  onCategoryChange: (categoryId: string) => void;
}

const CategoryNavigation: React.FC<CategoryNavigationProps> = ({
  categories,
  activeCategory,
  onCategoryChange
}) => {
  return (
  <div className="px-5 py-3 flex justify-between items-center gap-1 border-b border-[var(--color-outline)]">
      {categories.map(category => (
        <button
          key={category.id}
          onClick={() => onCategoryChange(category.id)}
          className={`flex-1 rounded-md p-2 flex flex-col items-center gap-0.5 min-h-[50px] transition duration-150 border ${activeCategory === category.id ? 'bg-[var(--color-primary-container)] border-[var(--color-outline)]' : 'bg-transparent hover:bg-[var(--color-primary-container)]/10 border-transparent'}`}
        >
          <span className="text-[1.2em] block mb-0.5">{category.icon}</span>
          <span className={`text-[0.7em] text-center leading-none ${activeCategory === category.id ? 'text-[var(--color-primary)] font-semibold' : 'text-[var(--color-text-secondary)] font-normal'}`}>
            {category.label}
          </span>
        </button>
      ))}
    </div>
  );
};

export default CategoryNavigation;
</file>

<file path="packages/frontend/src/components/ui/MaterialButton.tsx">
import React from 'react';
import { Button, ButtonProps, CircularProgress } from '@mui/material';

interface MaterialButtonProps extends Omit<ButtonProps, 'variant'> {
  variant?: 'text' | 'outlined' | 'contained';
  loading?: boolean;
  children: React.ReactNode;
}

const MaterialButton = React.forwardRef<HTMLButtonElement, MaterialButtonProps>(({
  variant = 'contained',
  loading = false,
  disabled,
  children,
  sx = {},
  ...props
}, ref) => {
  return (
    <Button
      ref={ref}
      variant={variant}
      disabled={disabled || loading}
      sx={{
        fontFamily: 'JetBrains Mono',
        fontWeight: 500,
        textTransform: 'none',
        borderRadius: 2,
        px: 3,
        py: 1,
        minHeight: 40,
        ...sx
      }}
      {...props}
    >
      {loading && (
        <CircularProgress
          size={16}
          sx={{
            mr: 1,
            color: variant === 'contained' ? 'inherit' : 'primary.main'
          }}
        />
      )}
      {children}
    </Button>
  );
});

MaterialButton.displayName = 'MaterialButton';

export default MaterialButton;
</file>

<file path="packages/frontend/src/components/ui/MaterialCard.tsx">
import React from 'react';
import { Card, CardContent, CardHeader, Typography, Box } from '@mui/material';

interface MaterialCardProps {
  title?: string;
  subtitle?: string;
  children: React.ReactNode;
  elevation?: number;
  sx?: any;
}

const MaterialCard: React.FC<MaterialCardProps> = ({
  title,
  subtitle,
  children,
  elevation = 1,
  sx = {}
}) => {
  return (
    <Card
      elevation={elevation}
      sx={{
        backgroundColor: 'background.paper',
        backgroundImage: 'none',
        border: '1px solid',
        borderColor: 'divider',
        borderRadius: '16px',
        transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        ...sx
      }}
    >
      {(title || subtitle) && (
        <CardHeader
          title={title && (
            <Typography
              variant="h6"
              sx={{
                fontFamily: 'JetBrains Mono',
                fontWeight: 600,
                color: 'text.primary'
              }}
            >
              {title}
            </Typography>
          )}
          subheader={subtitle && (
            <Typography
              variant="body2"
              sx={{
                fontFamily: 'JetBrains Mono',
                color: 'text.secondary'
              }}
            >
              {subtitle}
            </Typography>
          )}
          sx={{ pb: 1 }}
        />
      )}
      <CardContent sx={{ pt: title || subtitle ? 0 : 2 }}>
        {children}
      </CardContent>
    </Card>
  );
};

export default MaterialCard;
</file>

<file path="packages/frontend/src/components/ui/MaterialChip.tsx">
import React from 'react';
import { Chip, ChipProps } from '@mui/material';

interface MaterialChipProps extends ChipProps {
  variant?: 'filled' | 'outlined';
}

const MaterialChip: React.FC<MaterialChipProps> = ({
  variant = 'filled',
  sx = {},
  ...props
}) => {
  return (
    <Chip
      variant={variant}
      sx={{
        fontFamily: 'JetBrains Mono',
        fontWeight: 500,
        fontSize: '0.75rem',
        height: 24,
        borderRadius: 1,
        '& .MuiChip-label': {
          px: 1,
        },
        ...sx
      }}
      {...props}
    />
  );
};

export default MaterialChip;
</file>

<file path="packages/frontend/src/components/ui/MaterialDialog.tsx">
import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Typography,
  IconButton,
  Box
} from '@mui/material';
import { Close as CloseIcon } from '@mui/icons-material';

interface MaterialDialogProps {
  open: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  actions?: React.ReactNode;
  maxWidth?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  fullWidth?: boolean;
}

const MaterialDialog: React.FC<MaterialDialogProps> = ({
  open,
  onClose,
  title,
  children,
  actions,
  maxWidth = 'sm',
  fullWidth = true
}) => {
  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth={maxWidth}
      fullWidth={fullWidth}
      sx={{
        '& .MuiDialog-paper': {
          backgroundColor: 'background.paper',
          backgroundImage: 'none',
          border: '1px solid',
          borderColor: 'divider',
          maxHeight: '92vh',
          overflow: 'hidden',
          margin: '8vh auto'
        }
      }}
    >
      {title && (
            <DialogTitle
              sx={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                pb: 1,
                fontWeight: 700,
                color: 'text.primary',
                letterSpacing: '0.08em',
                textTransform: 'uppercase',
                fontSize: '1.25rem',
                lineHeight: 1.6
              }}
            >
              <span className="title-font">{title}</span>
              <IconButton onClick={onClose} size="small">
                <CloseIcon />
              </IconButton>
            </DialogTitle>
      )}
      <DialogContent sx={{ pt: title ? 0 : 2, overflow: 'auto', maxHeight: 'calc(90vh - 120px)' }}>
        {children}
      </DialogContent>
      {actions && (
        <DialogActions sx={{ px: 3, pb: 2 }}>
          {actions}
        </DialogActions>
      )}
    </Dialog>
  );
};

export default MaterialDialog;
</file>

<file path="packages/frontend/src/components/ui/MaterialDrawer.tsx">
import React from 'react';
import {
  Drawer,
  Box,
  Typography,
  Divider,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  IconButton
} from '@mui/material';
import { Close as CloseIcon } from '@mui/icons-material';

interface MaterialDrawerProps {
  open: boolean;
  onClose: () => void;
  title?: string;
  children?: React.ReactNode;
  width?: number;
}

const MaterialDrawer: React.FC<MaterialDrawerProps> = ({
  open,
  onClose,
  title,
  children,
  width = 300
}) => {
  return (
    <Drawer
      anchor="left"
      open={open}
      onClose={onClose}
      sx={{
        '& .MuiDrawer-paper': {
          width: width,
          backgroundColor: 'background.paper',
          backgroundImage: 'none',
          borderRight: '1px solid',
          borderRightColor: 'divider',
        },
      }}
    >
      <Box sx={{ p: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        {title && (
          <Typography
            variant="h6"
            sx={{
              fontFamily: 'JetBrains Mono',
              fontWeight: 600
            }}
          >
            {title}
          </Typography>
        )}
        <IconButton onClick={onClose} size="small">
          <CloseIcon />
        </IconButton>
      </Box>
      <Divider />
      <Box sx={{ p: 2, flexGrow: 1, overflow: 'auto' }}>
        {children}
      </Box>
    </Drawer>
  );
};

export default MaterialDrawer;
</file>

<file path="packages/frontend/src/components/ui/MaterialIcon.tsx">
import React from 'react';
import Icon from '@mui/material/Icon';
import { SxProps, Theme } from '@mui/material/styles';

interface MaterialIconProps {
  children: React.ReactNode;
  sx?: SxProps<Theme>;
}

const MaterialIcon: React.FC<MaterialIconProps> = ({ children, sx }) => {
  return (
    <Icon sx={{ color: 'var(--color-text-primary)', ...sx }}>
      {children}
    </Icon>
  );
};

export default MaterialIcon;
</file>

<file path="packages/frontend/src/components/ui/MaterialPaper.tsx">
import React from 'react';
import { Paper, PaperProps } from '@mui/material';

interface MaterialPaperProps extends PaperProps {
  children: React.ReactNode;
}

const MaterialPaper: React.FC<MaterialPaperProps> = ({
  children,
  sx = {},
  ...props
}) => {
  return (
    <Paper
      sx={{
        backgroundColor: 'background.paper',
        backgroundImage: 'none',
        border: '1px solid',
        borderColor: 'divider',
        borderRadius: 2,
        ...sx
      }}
      {...props}
    >
      {children}
    </Paper>
  );
};

export default MaterialPaper;
</file>

<file path="packages/frontend/src/components/ui/MaterialPopover.tsx">
import React from 'react';
import { Popover, PopoverProps } from '@mui/material';

interface MaterialPopoverProps extends Omit<PopoverProps, 'PaperProps'> {
  children: React.ReactNode;
  fullHeight?: boolean;
}

const MaterialPopover: React.FC<MaterialPopoverProps> = ({
  children,
  fullHeight = false,
  ...props
}) => {
  return (
    <Popover
      PaperProps={{
        sx: {
          backgroundColor: 'rgba(25, 23, 36, 0.95)',
          border: '1px solid rgba(196, 167, 231, 0.2)',
          borderRadius: 3,
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.2)',
          ...(fullHeight && {
            height: 'calc(100vh - 80px)',
            maxHeight: 'calc(100vh - 80px)',
          }),
        }
      }}
      {...props}
    >
      {children}
    </Popover>
  );
};

export default MaterialPopover;
</file>

<file path="packages/frontend/src/components/ui/MaterialTooltip.tsx">
import React from 'react';
import { Tooltip, TooltipProps } from '@mui/material';

interface MaterialTooltipProps extends TooltipProps {
  title: string;
}

const MaterialTooltip: React.FC<MaterialTooltipProps> = ({
  title,
  children,
  sx = {},
  ...props
}) => {
  return (
    <Tooltip
      title={title}
      sx={{
        '& .MuiTooltip-tooltip': {
          backgroundColor: 'rgba(25, 23, 36, 0.95)',
          color: 'text.primary',
          fontSize: '0.75rem',
          fontFamily: 'JetBrains Mono',
          borderRadius: 1,
          padding: '8px 12px',
          boxShadow: '0px 2px 8px rgba(0, 0, 0, 0.15)',
          border: '1px solid',
          borderColor: 'divider',
          backdropFilter: 'blur(10px)',
        },
        '& .MuiTooltip-arrow': {
          color: 'rgba(25, 23, 36, 0.95)',
        },
        ...sx
      }}
      {...props}
    >
      {children}
    </Tooltip>
  );
};

export default MaterialTooltip;
</file>

<file path="packages/frontend/src/components/AnimationDemo.tsx">
import React, { useState, useRef } from 'react';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';
import {
  RoughAnimatedShape,
  ScrollAnimatedElement,
  RoughNotation,
  GameAchievement,
  GameObjective,
  GameHighlight,
  useRoughAnnotation,
  useScrollAnimation
} from './animations';

// Register GSAP plugins
gsap.registerPlugin(ScrollTrigger);

export const AnimationDemo: React.FC = () => {
  const [showAchievement, setShowAchievement] = useState(false);
  const [completedObjective, setCompletedObjective] = useState(false);
  const demoRef = useRef<HTMLDivElement>(null);
  const { annotate } = useRoughAnnotation();
  const { createReveal } = useScrollAnimation();

  const handleAchievementClick = () => {
    setShowAchievement(true);
    setTimeout(() => setShowAchievement(false), 3000);
  };

  const handleObjectiveClick = () => {
    setCompletedObjective(!completedObjective);
  };

  const handleAnnotationDemo = () => {
    const element = demoRef.current?.querySelector('.annotation-target');
    if (element) {
      annotate(element as HTMLElement, 'circle', {
        color: '#ff6b6b',
        strokeWidth: 3,
        animationDuration: 1000
      });
    }
  };

  const handleScrollReveal = () => {
    const elements = demoRef.current?.querySelectorAll('.reveal-target');
    elements?.forEach((el, index) => {
      createReveal(el as HTMLElement, 'up', 30);
    });
  };

  return (
    <div ref={demoRef} className="animation-demo p-8 space-y-8">
      <h1 className="text-3xl font-bold text-center mb-8">GSAP + Rough Animation Demo</h1>

      {/* Rough Animated Shapes */}
      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Rough Animated Shapes</h2>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <RoughAnimatedShape
            shape="rectangle"
            animationType="draw"
            fill="#e0f2fe"
            fillStyle="hachure"
            stroke="#0369a1"
            width={150}
            height={100}
          />
          <RoughAnimatedShape
            shape="circle"
            animationType="bounce"
            fill="#fef3c7"
            fillStyle="cross-hatch"
            stroke="#d97706"
            width={120}
            height={120}
          />
          <RoughAnimatedShape
            shape="ellipse"
            animationType="scale"
            fill="#ecfdf5"
            fillStyle="dots"
            stroke="#059669"
            width={160}
            height={100}
          />
          <RoughAnimatedShape
            shape="line"
            animationType="fade"
            stroke="#dc2626"
            strokeWidth={4}
            width={140}
            height={80}
          />
        </div>
      </section>

      {/* Scroll Animations */}
      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Scroll Animations</h2>
        <div className="space-y-8">
          <ScrollAnimatedElement animation="fadeIn">
            <div className="bg-blue-100 p-6 rounded-lg">
              <h3 className="text-xl font-medium">Fade In Animation</h3>
              <p>This element fades in as you scroll.</p>
            </div>
          </ScrollAnimatedElement>

          <ScrollAnimatedElement animation="slideUp">
            <div className="bg-green-100 p-6 rounded-lg">
              <h3 className="text-xl font-medium">Slide Up Animation</h3>
              <p>This element slides up from below as you scroll.</p>
            </div>
          </ScrollAnimatedElement>

          <ScrollAnimatedElement animation="slideLeft">
            <div className="bg-purple-100 p-6 rounded-lg">
              <h3 className="text-xl font-medium">Slide Left Animation</h3>
              <p>This element slides in from the left as you scroll.</p>
            </div>
          </ScrollAnimatedElement>

          <ScrollAnimatedElement animation="scale">
            <div className="bg-orange-100 p-6 rounded-lg">
              <h3 className="text-xl font-medium">Scale Animation</h3>
              <p>This element scales up as you scroll.</p>
            </div>
          </ScrollAnimatedElement>
        </div>
      </section>

      {/* Rough Notations */}
      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Rough Notations</h2>
        <div className="space-y-4">
          <div>
            <button
              onClick={handleAchievementClick}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Show Achievement
            </button>
            <div className="mt-2">
              <GameAchievement achieved={showAchievement}>
                ðŸŽ‰ Level Up! You reached level 5!
              </GameAchievement>
            </div>
          </div>

          <div>
            <button
              onClick={handleObjectiveClick}
              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
            >
              Toggle Objective
            </button>
            <div className="mt-2">
              <GameObjective completed={completedObjective}>
                {completedObjective ? "âœ… Defeat the dragon" : "âš”ï¸ Defeat the dragon"}
              </GameObjective>
            </div>
          </div>

          <div className="space-y-2">
            <GameHighlight type="important" trigger="hover">
              âš ï¸ Critical Warning: Low Health!
            </GameHighlight>

            <GameHighlight type="success" trigger="hover">
              âœ… Quest Completed Successfully!
            </GameHighlight>

            <GameHighlight type="info" trigger="hover">
              â„¹ï¸ New tutorial available in the menu.
            </GameHighlight>
          </div>
        </div>
      </section>

      {/* Interactive Demos */}
      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Interactive Demos</h2>
        <div className="space-y-4">
          <div>
            <button
              onClick={handleAnnotationDemo}
              className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600"
            >
              Annotate Element
            </button>
            <p className="annotation-target mt-2 p-4 bg-gray-100 rounded">
              This text can be annotated with rough circles!
            </p>
          </div>

          <div>
            <button
              onClick={handleScrollReveal}
              className="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600"
            >
              Reveal Elements
            </button>
            <div className="space-y-4 mt-4">
              <div className="reveal-target p-4 bg-red-100 rounded opacity-0">
                Element 1 - Will slide up
              </div>
              <div className="reveal-target p-4 bg-yellow-100 rounded opacity-0">
                Element 2 - Will slide up
              </div>
              <div className="reveal-target p-4 bg-pink-100 rounded opacity-0">
                Element 3 - Will slide up
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Game UI Elements */}
      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Game UI Integration</h2>
        <div className="bg-gray-900 text-white p-6 rounded-lg">
          <h3 className="text-xl font-medium mb-4">Game HUD</h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div className="game-ui-element bg-red-600 p-3 rounded text-center">
              â¤ï¸ Health: 85/100
            </div>
            <div className="game-ui-element bg-blue-600 p-3 rounded text-center">
              âš¡ Mana: 60/100
            </div>
            <div className="game-ui-element bg-yellow-600 p-3 rounded text-center">
              ðŸª™ Gold: 1,250
            </div>
            <div className="game-ui-element bg-green-600 p-3 rounded text-center">
              â­ XP: 2,340
            </div>
          </div>
        </div>
      </section>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/CataclysmDemo.tsx">
import React, { useState, useEffect } from 'react';
import GameCanvas from './GameCanvas';
import { useGameStore } from '../stores/gameStore';

export const CataclysmDemo: React.FC = () => {
  const { gameWorld } = useGameStore();
  const [cataclysmProgress, setCataclysmProgress] = useState(0);
  const [isCataclysmActive, setIsCataclysmActive] = useState(false);

  // Simulate cataclysm progress for demo
  useEffect(() => {
    if (gameWorld?.phase === 'cataclysm') {
      setIsCataclysmActive(true);
      const initialRadius = Math.max(60, 30); // Approximate grid size
      const currentRadius = gameWorld.cataclysmCircle.radius;
      const progress = 1 - (currentRadius / initialRadius);
      setCataclysmProgress(progress);
    } else if (gameWorld?.phase === 'rebirth') {
      setIsCataclysmActive(false);
      setCataclysmProgress(0);
    } else {
      setIsCataclysmActive(false);
      setCataclysmProgress(0);
    }
  }, [gameWorld?.phase, gameWorld?.cataclysmCircle.radius]);

  const roughnessMultiplier = gameWorld?.cataclysmRoughnessMultiplier ?? 1.0;

  return (
    <div className="cataclysm-demo p-6 space-y-6">
      <h2 className="text-2xl font-bold text-white mb-4">Cataclysm Effects Demo</h2>

      {/* Status Display */}
      <div className="bg-gray-800 p-4 rounded-lg">
        <h3 className="text-lg font-semibold text-white mb-2">World Status</h3>
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div>
            <span className="text-gray-400">Phase:</span>
            <span className={`ml-2 font-medium ${
              gameWorld?.phase === 'cataclysm' ? 'text-red-400' :
              gameWorld?.phase === 'rebirth' ? 'text-green-400' :
              'text-blue-400'
            }`}>
              {gameWorld?.phase || 'exploration'}
            </span>
          </div>
          <div>
            <span className="text-gray-400">Cataclysm Active:</span>
            <span className={`ml-2 font-medium ${isCataclysmActive ? 'text-red-400' : 'text-green-400'}`}>
              {isCataclysmActive ? 'Yes' : 'No'}
            </span>
          </div>
          <div>
            <span className="text-gray-400">Roughness Multiplier:</span>
            <span className="ml-2 font-medium text-yellow-400">
              {roughnessMultiplier.toFixed(2)}x
            </span>
          </div>
          <div>
            <span className="text-gray-400">Cataclysm Progress:</span>
            <span className="ml-2 font-medium text-orange-400">
              {(cataclysmProgress * 100).toFixed(1)}%
            </span>
          </div>
        </div>

        {/* Progress Bar */}
        <div className="mt-4">
          <div className="flex justify-between text-xs text-gray-400 mb-1">
            <span>Normal</span>
            <span>Chaotic</span>
          </div>
          <div className="w-full bg-gray-700 rounded-full h-2">
            <div
              className="bg-gradient-to-r from-green-500 via-yellow-500 to-red-500 h-2 rounded-full transition-all duration-1000"
              style={{ width: `${Math.min(100, cataclysmProgress * 100)}%` }}
            />
          </div>
        </div>
      </div>

      {/* Instructions */}
      <div className="bg-gray-800 p-4 rounded-lg">
        <h3 className="text-lg font-semibold text-white mb-2">How It Works</h3>
        <div className="text-gray-300 text-sm space-y-2">
          <p><strong>During Cataclysm:</strong> Terrain roughness increases progressively from 1.0x to 4.0x as the cataclysm circle shrinks, creating increasingly chaotic and "jumbled" visuals.</p>
          <p><strong>Rebirth Phase:</strong> After cataclysm ends, the world enters a 5-second rebirth phase with animated regeneration effects showing new terrain being created.</p>
          <p><strong>Visual Effects:</strong> Circles, stars, and lightning bolts appear across the map during regeneration, symbolizing the rebirth of the world.</p>
          <p><strong>Player Impact:</strong> Players inside the cataclysm circle are eliminated, and the world resets with fresh terrain and NPCs.</p>
        </div>
      </div>

      {/* Controls */}
      <div className="bg-gray-800 p-4 rounded-lg">
        <button
          onClick={() => useGameStore.getState().startCataclysm()}
          className="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded"
        >
          Start Cataclysm
        </button>
      </div>

      {/* Game Canvas */}
      <div className="border-2 border-gray-600 rounded-lg overflow-hidden">
        <GameCanvas />
      </div>

      {/* Technical Details */}
      <div className="bg-gray-800 p-4 rounded-lg">
        <h3 className="text-lg font-semibold text-white mb-2">Technical Implementation</h3>
        <div className="text-gray-300 text-sm space-y-1">
          <p>â€¢ <code>cataclysmRoughnessMultiplier</code> in GameWorld state</p>
          <p>â€¢ Roughness increases from 1.0 to 4.0 during cataclysm progression</p>
          <p>â€¢ Canvas drawing effects for rebirth animations</p>
          <p>â€¢ Phase transitions: exploration â†’ cataclysm â†’ rebirth â†’ exploration</p>
          <p>â€¢ GSAP-powered smooth transitions between roughness levels</p>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/CataclysmVisualizer.tsx">
import React, { useRef, useEffect } from 'react';
import rough from 'roughjs';
import { RoughCanvas } from 'roughjs/bin/canvas';
import { GameWorld, Position } from 'shared';
import { GAME_CONFIG } from 'shared';

const CELL_SIZE = GAME_CONFIG.tileSize;

export const CataclysmVisualizer: React.FC<{
  gameWorld: GameWorld;
  infectedAreas: Position[];
}> = ({ gameWorld, infectedAreas }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const roughCanvasRef = useRef<RoughCanvas | null>(null);

  useEffect(() => {
    if (!canvasRef.current) return;

    roughCanvasRef.current = rough.canvas(canvasRef.current, {
      options: {
        roughness: 2.5,
        bowing: 3,
        stroke: '#ff0000',
        strokeWidth: 2,
        fill: 'rgba(255, 0, 0, 0.1)',
        fillStyle: 'zigzag-line'
      }
    });

    renderCataclysmEffects();
  }, [infectedAreas, gameWorld]);

  const renderCataclysmEffects = () => {
    const canvas = canvasRef.current;
    const roughCanvas = roughCanvasRef.current;
    if (!canvas || !roughCanvas || !gameWorld || !gameWorld.grid || gameWorld.grid.length === 0) return;

    const ctx = canvas.getContext('2d')!;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    infectedAreas.forEach((area, index) => {
      const chaos = Math.min(index * 0.1 + 1, 5);

      roughCanvas.rectangle(
        area.x * CELL_SIZE,
        area.y * CELL_SIZE,
        CELL_SIZE,
        CELL_SIZE,
        {
          roughness: chaos,
          bowing: chaos * 1.5,
          stroke: `hsl(${Math.random() * 60}, 70%, 40%)`,
          strokeWidth: Math.random() * 3 + 1,
          fill: `hsla(${Math.random() * 60}, 50%, 20%, 0.3)`,
          fillStyle: Math.random() > 0.5 ? 'zigzag-line' : 'cross-hatch'
        }
      );

      for (let i = 0; i < chaos * 2; i++) {
        const startX = area.x * CELL_SIZE + Math.random() * CELL_SIZE;
        const startY = area.y * CELL_SIZE + Math.random() * CELL_SIZE;
        const endX = startX + (Math.random() - 0.5) * CELL_SIZE;
        const endY = startY + (Math.random() - 0.5) * CELL_SIZE;

        roughCanvas.line(startX, startY, endX, endY, {
          roughness: chaos * 2,
          stroke: '#330000',
          strokeWidth: Math.random() * 2
        });
      }
    });
  };

  if (!gameWorld || !gameWorld.grid || gameWorld.grid.length === 0 || !gameWorld.grid[0]) {
      return null;
  }

  return (
    <canvas
      ref={canvasRef}
      className="absolute top-0 left-0 pointer-events-none z-10"
      width={gameWorld.grid[0].length * CELL_SIZE}
      height={gameWorld.grid.length * CELL_SIZE}
    />
  );
};
</file>

<file path="packages/frontend/src/components/DrawingEffectsDemo.tsx">
import React, { useState, useRef } from 'react';
import {
  CanvasDrawEffectComponent,
  createCanvasCirclePath,
  createCanvasLightningPath,
  createCanvasStarPath,
  createCanvasRectanglePath
} from './animations/CanvasDrawEffect';
import { DrawSVGEffect } from './animations/DrawSVGEffect';

export const DrawingEffectsDemo: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [activeEffects, setActiveEffects] = useState<Array<{
    id: string;
    path: Array<{x: number, y: number}>;
    active: boolean;
    duration?: number;
    strokeColor?: string;
  }>>([]);

  const triggerCanvasEffect = (effectType: string) => {
    if (!canvasRef.current) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;

    const effectId = `demo-${Date.now()}-${Math.random()}`;

    let path: Array<{x: number, y: number}>;
    let strokeColor: string;
    let duration: number;

    switch (effectType) {
      case 'circle':
        path = createCanvasCirclePath(centerX, centerY, 50, 32);
        strokeColor = '#00ff88';
        duration = 2;
        break;
      case 'lightning':
        path = createCanvasLightningPath(centerX - 50, centerY - 50, centerX + 50, centerY + 50, 8, 20);
        strokeColor = '#ffff00';
        duration = 1;
        break;
      case 'star':
        path = createCanvasStarPath(centerX, centerY, 40, 20, 6);
        strokeColor = '#ff6b6b';
        duration = 2.5;
        break;
      case 'rectangle':
        path = createCanvasRectanglePath(centerX - 40, centerY - 30, 80, 60);
        strokeColor = '#4ecdc4';
        duration = 1.5;
        break;
      default:
        path = createCanvasCirclePath(centerX, centerY, 30);
        strokeColor = '#ffffff';
        duration = 1;
    }

    setActiveEffects(prev => [...prev, {
      id: effectId,
      path,
      active: true,
      duration,
      strokeColor
    }]);

    // Remove effect after animation completes
    setTimeout(() => {
      setActiveEffects(prev => prev.filter(effect => effect.id !== effectId));
    }, duration * 1000 + 100);
  };

  return (
    <div className="drawing-effects-demo p-6 space-y-6">
      <h2 className="text-2xl font-bold text-white mb-4">Drawing Effects Demo</h2>

      {/* Canvas for drawing effects */}
      <div className="relative border-2 border-gray-600 rounded-lg overflow-hidden">
        <canvas
          ref={canvasRef}
          width={600}
          height={400}
          className="bg-gray-900 block"
          style={{ width: '600px', height: '400px' }}
        />
        {activeEffects.map(effect => (
          <CanvasDrawEffectComponent
            key={effect.id}
            canvasRef={canvasRef}
            path={effect.path}
            active={effect.active}
            duration={effect.duration}
            strokeColor={effect.strokeColor}
            strokeWidth={4}
            clearBeforeDraw={false}
          />
        ))}
      </div>

      {/* Control buttons */}
      <div className="flex flex-wrap gap-4">
        <button
          onClick={() => triggerCanvasEffect('circle')}
          className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors"
        >
          Draw Circle
        </button>
        <button
          onClick={() => triggerCanvasEffect('lightning')}
          className="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-lg transition-colors"
        >
          Draw Lightning
        </button>
        <button
          onClick={() => triggerCanvasEffect('star')}
          className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors"
        >
          Draw Star
        </button>
        <button
          onClick={() => triggerCanvasEffect('rectangle')}
          className="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-lg transition-colors"
        >
          Draw Rectangle
        </button>
      </div>

      {/* SVG Drawing Effects */}
      <div className="space-y-4">
        <h3 className="text-xl font-semibold text-white">SVG Drawing Effects</h3>
        <div className="relative bg-gray-800 p-4 rounded-lg" style={{ height: '200px' }}>
          <DrawSVGEffect
            id="svg-circle"
            pathData="M 100 100 A 50 50 0 1 1 99.9 100"
            duration={2}
            strokeColor="#00ff88"
            strokeWidth={3}
            position={{ x: 0, y: 0 }}
            size={{ width: 200, height: 200 }}
          />
          <DrawSVGEffect
            id="svg-lightning"
            pathData="M 250 50 L 260 70 L 245 75 L 265 95 L 250 100 L 270 130 L 255 135 L 275 165"
            duration={1.5}
            strokeColor="#ffff00"
            strokeWidth={3}
            position={{ x: 0, y: 0 }}
            size={{ width: 200, height: 200 }}
            delay={0.5}
          />
        </div>
      </div>

      {/* Usage Examples */}
      <div className="bg-gray-800 p-4 rounded-lg">
        <h3 className="text-lg font-semibold text-white mb-2">Usage Examples</h3>
        <div className="text-gray-300 text-sm space-y-2">
          <p><strong>Canvas Effects:</strong> Perfect for dynamic game effects that draw directly on the game canvas</p>
          <p><strong>SVG Effects:</strong> Great for UI overlays, skill effects, and decorative animations</p>
          <p><strong>Integration:</strong> Effects are triggered by game events like player movement, attacks, or achievements</p>
          <p><strong>Customization:</strong> Easily customize colors, timing, and paths for different game scenarios</p>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="packages/frontend/src/components/EmojiPicker.tsx">
import React, { useState, useMemo } from 'react';
import { MaterialCard, MaterialButton, MaterialDialog } from './index';

interface EmojiPickerProps {
  selectedEmoji: string;
  onEmojiSelect: (emoji: string) => void;
  className?: string;
  compact?: boolean;
}

const EMOJI_CATEGORIES = {
  fantasy: {
    name: 'Fantasy',
    emojis: [
      'ðŸ§™â€â™‚ï¸', 'ðŸ§™â€â™€ï¸', 'ðŸ§šâ€â™‚ï¸', 'ðŸ§šâ€â™€ï¸', 'ðŸ§›â€â™‚ï¸', 'ðŸ§›â€â™€ï¸', 'ðŸ§Ÿâ€â™‚ï¸', 'ðŸ§Ÿâ€â™€ï¸', 'ðŸ§žâ€â™‚ï¸', 'ðŸ§žâ€â™€ï¸',
      'ðŸ§œâ€â™‚ï¸', 'ðŸ§œâ€â™€ï¸', 'ðŸ§â€â™‚ï¸', 'ðŸ§â€â™€ï¸', 'ðŸ§Œ', 'ðŸ‰', 'ðŸ¦„', 'ðŸº', 'ðŸ¦Š', 'ðŸ¦', 'ðŸ¯', 'ðŸ¦“',
      'ðŸ¦Œ', 'ðŸ˜', 'ðŸ¦', 'ðŸ¦›', 'ðŸ»', 'ðŸ¨', 'ðŸ¼', 'ðŸ¦¥', 'ðŸ¦¦', 'ðŸ¦¨', 'ðŸ¦˜', 'ðŸ¦¡', 'ðŸ¾'
    ]
  },
  warriors: {
    name: 'Warriors',
    emojis: [
      'âš”ï¸', 'ðŸ—¡ï¸', 'ðŸ”ª', 'ðŸ¹', 'ðŸ›¡ï¸', 'ðŸ‘‘', 'ðŸ…', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸ¦¸â€â™‚ï¸', 'ðŸ¦¸â€â™€ï¸', 'ðŸ¦¹â€â™‚ï¸', 'ðŸ¦¹â€â™€ï¸',
      'ðŸ‘®â€â™‚ï¸', 'ðŸ‘®â€â™€ï¸', 'ðŸ’‚â€â™‚ï¸', 'ðŸ’‚â€â™€ï¸', 'ðŸ•µï¸â€â™‚ï¸', 'ðŸ•µï¸â€â™€ï¸', 'ðŸ‘©â€âš•ï¸', 'ðŸ‘¨â€âš•ï¸', 'ðŸ‘©â€ðŸŒ¾', 'ðŸ‘¨â€ðŸŒ¾',
      'ðŸ‘©â€ðŸ³', 'ðŸ‘¨â€ðŸ³', 'ðŸ‘©â€ðŸŽ“', 'ðŸ‘¨â€ðŸŽ“', 'ðŸ‘©â€ðŸŽ¤', 'ðŸ‘¨â€ðŸŽ¤', 'ðŸ‘©â€ðŸŽ¨', 'ðŸ‘¨â€ðŸŽ¨', 'ðŸ‘©â€ðŸš€', 'ðŸ‘¨â€ðŸš€'
    ]
  },
  animals: {
    name: 'Animals',
    emojis: [
      'ðŸ¶', 'ðŸ±', 'ðŸ­', 'ðŸ¹', 'ðŸ°', 'ðŸ¦Š', 'ðŸ»', 'ðŸ¼', 'ðŸ¨', 'ðŸ¯', 'ðŸ¦', 'ðŸ®', 'ðŸ·', 'ðŸ½',
      'ðŸ¸', 'ðŸµ', 'ðŸ™ˆ', 'ðŸ™‰', 'ðŸ™Š', 'ðŸ’', 'ðŸ”', 'ðŸ§', 'ðŸ¦', 'ðŸ¤', 'ðŸ£', 'ðŸ¥', 'ðŸ¦†', 'ðŸ¦…',
      'ðŸ¦‰', 'ðŸ¦‡', 'ðŸº', 'ðŸ—', 'ðŸ´', 'ðŸ¦„', 'ðŸ', 'ðŸ›', 'ðŸ¦‹', 'ðŸŒ', 'ðŸž', 'ðŸœ', 'ðŸ¦—', 'ðŸ•·ï¸'
    ]
  },
  nature: {
    name: 'Nature',
    emojis: [
      'ðŸŒŸ', 'â­', 'ðŸŒ™', 'â˜€ï¸', 'ðŸŒˆ', 'â˜ï¸', 'ðŸŒŠ', 'ðŸ”¥', 'â„ï¸', 'âš¡', 'ðŸŒªï¸', 'ðŸŒ«ï¸', 'ðŸŒ¬ï¸',
      'ðŸŒ¡ï¸', 'ðŸ’§', 'ðŸŒ±', 'ðŸŒ¿', 'â˜˜ï¸', 'ðŸ€', 'ðŸŽ‹', 'ðŸŽ', 'ðŸŒ¾', 'ðŸŒµ', 'ðŸŽ„', 'ðŸŒ²', 'ðŸŒ³',
      'ðŸŒ´', 'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸ¥€', 'ðŸŒ¼', 'ðŸŒ»', 'ðŸŒº', 'ðŸŒ¸', 'ðŸŒ·', 'ðŸŒ¹'
    ]
  },
  objects: {
    name: 'Objects',
    emojis: [
      'ðŸ’Ž', 'ðŸ”®', 'ðŸª„', 'âš±ï¸', 'ðŸ—¿', 'ðŸ°', 'ðŸ¯', 'ðŸŽ¡', 'ðŸŽ¢', 'ðŸŽ ', 'â›²', 'ðŸª', 'ðŸ«',
      'ðŸ¢', 'ðŸ¬', 'ðŸ­', 'ðŸ¥', 'ðŸ¦', 'ðŸ¨', 'ðŸ’’', 'â›ª', 'ðŸ•Œ', 'ðŸ•', 'â›©ï¸', 'ðŸ•‹', 'ðŸ—ï¸',
      'ðŸª“', 'â›ï¸', 'âš’ï¸', 'ðŸ› ï¸', 'ðŸ—¡ï¸', 'ðŸ¹', 'ðŸŽ£', 'ðŸ§¶', 'ðŸ§µ', 'ðŸª¡', 'ðŸ§¥', 'ðŸ‘š', 'ðŸ‘•',
      'ðŸ‘–', 'ðŸ§£', 'ðŸ§¤', 'ðŸ§¦', 'ðŸ‘—', 'ðŸ‘˜', 'ðŸ¥»', 'ðŸ©±', 'ðŸ©²', 'ðŸ©³', 'ðŸ‘™', 'ðŸ‘›', 'ðŸ‘œ'
    ]
  },
  food: {
    name: 'Food',
    emojis: [
      'ðŸŽ', 'ðŸŠ', 'ðŸ‹', 'ðŸŒ', 'ðŸ‰', 'ðŸ‡', 'ðŸ“', 'ðŸ«', 'ðŸˆ', 'ðŸ’', 'ðŸ‘', 'ðŸ¥­', 'ðŸ',
      'ðŸ¥¥', 'ðŸ¥', 'ðŸ…', 'ðŸ†', 'ðŸ¥‘', 'ðŸ¥¦', 'ðŸ¥¬', 'ðŸ¥’', 'ðŸŒ¶ï¸', 'ðŸ«‘', 'ðŸŒ½', 'ðŸ¥•', 'ðŸ«’',
      'ðŸ§„', 'ðŸ§…', 'ðŸ¥”', 'ðŸ ', 'ðŸ¥', 'ðŸ¥–', 'ðŸž', 'ðŸ¥¨', 'ðŸ¥¯', 'ðŸ§€', 'ðŸ¥š', 'ðŸ³', 'ðŸ§ˆ',
      'ðŸ¥ž', 'ðŸ§‡', 'ðŸ¥“', 'ðŸ¥©', 'ðŸ—', 'ðŸ–', 'ðŸ¦´', 'ðŸŒ­', 'ðŸ”', 'ðŸŸ', 'ðŸ•', 'ðŸ«“', 'ðŸ¥™'
    ]
  },
  activities: {
    name: 'Activities',
    emojis: [
      'âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸ¥Ž', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸ¥', 'ðŸŽ±', 'ðŸª€', 'ðŸ“', 'ðŸ¸',
      'ðŸ’', 'ðŸ‘', 'ðŸ¥', 'ðŸ', 'ðŸªƒ', 'ðŸ¥…', 'â›³', 'ðŸª', 'ðŸ¹', 'ðŸŽ£', 'ðŸ¤¿', 'ðŸ¥Š', 'ðŸ¥‹',
      'ðŸŽ½', 'ðŸ›¹', 'ðŸ›·', 'â›¸ï¸', 'ðŸ¥Œ', 'ðŸŽ¿', 'â›·ï¸', 'ðŸ‚', 'ðŸª‚', 'ðŸ‹ï¸â€â™‚ï¸', 'ðŸ‹ï¸â€â™€ï¸', 'ðŸ¤¸â€â™‚ï¸',
      'ðŸ¤¸â€â™€ï¸', 'â›¹ï¸â€â™‚ï¸', 'â›¹ï¸â€â™€ï¸', 'ðŸŒï¸â€â™‚ï¸', 'ðŸŒï¸â€â™€ï¸', 'ðŸ‡', 'ðŸ§˜â€â™‚ï¸', 'ðŸ§˜â€â™€ï¸', 'ðŸƒâ€â™‚ï¸', 'ðŸƒâ€â™€ï¸'
    ]
  }
};

const EmojiPicker: React.FC<EmojiPickerProps> = ({
  selectedEmoji,
  onEmojiSelect,
  className = '',
  compact = false
}) => {
  const [activeCategory, setActiveCategory] = useState('fantasy');
  const [searchQuery, setSearchQuery] = useState('');

  const filteredEmojis = useMemo(() => {
    if (!searchQuery) {
      return EMOJI_CATEGORIES[activeCategory as keyof typeof EMOJI_CATEGORIES]?.emojis || [];
    }

    // Search across all categories
    const allEmojis: Array<{ emoji: string; category: string }> = [];
    Object.entries(EMOJI_CATEGORIES).forEach(([categoryKey, category]) => {
      category.emojis.forEach(emoji => {
        allEmojis.push({ emoji, category: categoryKey });
      });
    });

    return allEmojis
      .filter(({ emoji }) =>
        emoji.toLowerCase().includes(searchQuery.toLowerCase())
      )
      .map(({ emoji }) => emoji);
  }, [activeCategory, searchQuery]);

  return (
  <div className={`${compact ? 'space-y-2' : 'space-y-4'} ${className}`}>
      {/* Search */}
      <div className="relative">
        <input
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          placeholder="Search emojis..."
          className={`w-full px-3 ${compact ? 'py-2' : 'py-3'} bg-gray-700/50 border border-purple-400/30 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent`}
        />
        {searchQuery && (
          <button
            onClick={() => setSearchQuery('')}
            className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white"
          >
            âœ•
          </button>
        )}
      </div>

      {/* Category Tabs */}
      {!searchQuery && (
        <div className={`${compact ? 'flex gap-1' : 'flex flex-wrap gap-2'}`}>
          {Object.entries(EMOJI_CATEGORIES).map(([key, category]) => (
            <button
              key={key}
              onClick={() => setActiveCategory(key)}
              className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                activeCategory === key
                  ? 'bg-purple-500/20 text-purple-300 border border-purple-400/50'
                  : 'bg-gray-700/30 text-gray-300 border border-gray-600 hover:bg-purple-500/10 hover:border-purple-400/30'
              }`}
            >
              {category.name}
            </button>
          ))}
        </div>
      )}

      {/* Emoji Grid */}
      <div className={`${compact ? 'max-h-48' : 'max-h-64'} overflow-y-auto`}>
        <div className={`${compact ? 'grid grid-cols-10 gap-1' : 'grid grid-cols-8 gap-2'}`}>
          {filteredEmojis.map((emoji) => (
            <button
              key={emoji}
              onClick={() => onEmojiSelect(emoji)}
              className={`aspect-square rounded-md border-2 transition-all duration-150 hover:scale-105 emoji-font ${compact ? 'text-lg p-1' : 'text-2xl'} ${
                selectedEmoji === emoji
                  ? 'border-purple-400 bg-purple-500/20 shadow-lg shadow-purple-500/30'
                  : 'border-gray-600 bg-gray-700/30 hover:border-purple-400/50 hover:bg-purple-500/10'
              }`}
              title={emoji}
            >
              {emoji}
            </button>
          ))}
        </div>

        {filteredEmojis.length === 0 && (
          <div className="text-center py-8 text-gray-400">
            No emojis found
          </div>
        )}
      </div>
    </div>
  );
};

export default EmojiPicker;
</file>

<file path="packages/frontend/src/hooks/useCharacterClasses.ts">
import { CHARACTER_CLASSES, ResourceType } from "shared";

export const useCharacterClasses = () => {
  return {
    characterClasses: CHARACTER_CLASSES,
    getClassById: (id: string) => CHARACTER_CLASSES.find(c => c.id === id),
    getClassesByResource: (resource: ResourceType) =>
      CHARACTER_CLASSES.filter(c => c.primaryResource === resource)
  };
};
</file>

<file path="packages/frontend/src/hooks/useGameWorld.ts">
import { useEffect } from 'react';
import { useGameStore } from '../stores/gameStore';
import { webSocketClient } from '../services/webSocketClient';
import { createMockGameWorld } from '../services/worldGeneration/WorldGenerator';
import type { GameWorld, Player, UnifiedSettings } from 'shared';

interface GameWorldHook {
  gameWorld: GameWorld | null;
  currentPlayer: Player | null;
  selectedTab: string;
  gameMessage: string;
  unifiedSettings: UnifiedSettings;
  setGameWorld: (world: GameWorld) => void;
  setCurrentPlayer: (player: Player | null) => void;
  setSelectedTab: (tab: string) => void;
  setGameMessage: (message: string) => void;
  updateUnifiedSettings: (settings: Partial<UnifiedSettings>) => void;
  movePlayer: (direction: 'up' | 'down' | 'left' | 'right') => void;
  handleRegenerateWorld: () => void;
  handleMove: (direction: 'up' | 'down' | 'left' | 'right') => void;
  handleJoinGame: (characterData?: { displayName: string; class: any; avatar: string }) => void;
  handleCreateCharacter: (characterData: any) => Promise<void>;
  handleStartCataclysm: () => void;
  handlePickUpItem: () => void;
}

export const useGameWorld = (): GameWorldHook => {
  const {
    gameWorld,
    currentPlayer,
    selectedTab,
    gameMessage,
    unifiedSettings,
    setGameWorld,
    setCurrentPlayer,
    setSelectedTab,
    setGameMessage: setGameMessageInStore, // Renamed to avoid conflict
    updateUnifiedSettings,
    movePlayer
  } = useGameStore();

  useEffect(() => {
    // Remove automatic join logic - WebSocketClient now handles this automatically
    // The WebSocketClient will automatically join the game when connected
  }, [gameWorld, currentPlayer]);

  const handleRegenerateWorld = () => {
    const newWorld = createMockGameWorld();
    setGameWorld(newWorld);
    setCurrentPlayer(newWorld.players[0]);
    setGameMessageInStore('ðŸŒ New world generated! Explore the fresh terrain!');

    setTimeout(() => setGameMessageInStore(''), 5000);
  };

  const handleMove = (direction: 'up' | 'down' | 'left' | 'right') => {
    movePlayer(direction);
  };

  const handleJoinGame = (characterData?: { displayName: string; class: any; avatar: string }) => {
    const playerData = characterData ? {
      id: 'player_' + Date.now(),
      displayName: characterData.displayName,
      class: characterData.class,
      avatar: characterData.avatar
    } : {
      id: 'player_' + Date.now(),
      displayName: 'TestPlayer',
      class: 'knight' as any,
      avatar: 'ðŸ¤ '
    };
    webSocketClient.joinGame(playerData);
  };

  const handleCreateCharacter = async (characterData: any) => {
    try {
      const newPlayer = await webSocketClient.createNewCharacter(characterData);
      setCurrentPlayer(newPlayer);
      setGameMessageInStore(`Character ${newPlayer.name} created! Welcome!`);
    } catch (error: any) {
      console.error("Failed to create character:", error);
      setGameMessageInStore(`Error creating character: ${error.message || 'Unknown error'}`);
      // Re-throw the error so the UI can also react to it
      throw error;
    }
  };

  const handleStartCataclysm = () => {
    setGameMessageInStore('Cataclysm started!');
  };

  const handlePickUpItem = () => {
    setGameMessageInStore('Looking for items...');
  };

  return {
    gameWorld,
    currentPlayer,
    selectedTab,
    gameMessage,
    unifiedSettings,
    setGameWorld,
    setCurrentPlayer,
    setSelectedTab,
    setGameMessage: setGameMessageInStore,
    updateUnifiedSettings,
    movePlayer,
    handleRegenerateWorld,
    handleMove,
    handleJoinGame,
    handleCreateCharacter,
    handleStartCataclysm,
    handlePickUpItem,
  };
};
</file>

<file path="packages/frontend/src/hooks/useNotifications.ts">
import { useGameStore } from '../stores/gameStore';
import { NotificationData } from '../types/notification';

/**
 * Custom hook for accessing notification state and actions from the global game store.
 *
 * This hook provides access to the current notifications list and functions to manage
 * notifications (add, remove). It automatically limits the number of notifications
 * displayed if maxNotifications is specified.
 *
 * @param maxNotifications - Optional maximum number of notifications to display
 * @returns Object containing notifications array and management functions
 *
 * @example
 * ```tsx
 * const { notifications, addNotification, removeNotification } = useNotifications(5);
 *
 * // Add a new notification
 * addNotification({
 *   type: 'success',
 *   title: 'Item Found!',
 *   message: 'You found a health potion'
 * });
 *
 * // Remove a notification
 * removeNotification(notificationId);
 * ```
 */
export const useNotifications = (maxNotifications?: number) => {
  const { notifications, addNotification, removeNotification } = useGameStore();

  // If maxNotifications is specified, limit the notifications
  const limitedNotifications = maxNotifications
    ? notifications.slice(-maxNotifications)
    : notifications;

  return {
    notifications: limitedNotifications,
    addNotification,
    removeNotification
  };
};
</file>

<file path="packages/frontend/src/hooks/usePlayerStatus.ts">
import { useEffect, useState } from 'react';
import { Player } from 'shared';
import { calculatePlayerStats, applyEffectsToStats } from '../services/player/StatusCalculator';
import { getActiveEffects } from '../services/player/EffectManager';
import { PlayerStats, PlayerEffect } from '../types/playerStatus';

/**
 * Custom hook for calculating and managing player status information.
 *
 * This hook computes derived player statistics and active effects based on the
 * current player state. It automatically updates when the player data changes.
 *
 * @param player - The player object to calculate stats for
 * @returns Object containing calculated player stats and active effects
 *
 * @example
 * ```tsx
 * const { stats, effects } = usePlayerStatus(currentPlayer);
 *
 * console.log('Player health:', stats.health);
 * console.log('Active effects:', effects.length);
 * ```
 */
export const usePlayerStatus = (player: Player) => {
  const [stats, setStats] = useState<PlayerStats>(calculatePlayerStats(player));
  const [effects, setEffects] = useState<PlayerEffect[]>(getActiveEffects(player));

  useEffect(() => {
    let currentStats = calculatePlayerStats(player);
    const currentEffects = getActiveEffects(player);
    currentStats = applyEffectsToStats(currentStats, currentEffects);
    setStats(currentStats);
    setEffects(currentEffects);
  }, [player]);

  return { stats, effects };
};
</file>

<file path="packages/frontend/src/hooks/useResponsive.ts">
import { useState, useEffect } from 'react';
import { BREAKPOINTS } from '../utils/designSystem';

const useResponsive = () => {
  const [isMobile, setIsMobile] = useState(false);
  const [isTablet, setIsTablet] = useState(false);
  const [isDesktop, setIsDesktop] = useState(false);

  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      setIsMobile(width < BREAKPOINTS.tablet);
      setIsTablet(width >= BREAKPOINTS.tablet && width < BREAKPOINTS.desktop);
      setIsDesktop(width >= BREAKPOINTS.desktop);
    };

    handleResize(); // Set initial values
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return { isMobile, isTablet, isDesktop };
};

export default useResponsive;
</file>

<file path="packages/frontend/src/hooks/useSound.ts">
import { useCallback, useEffect } from 'react';
import { soundService, initializeSounds } from '../services/soundService';
import { useGameStore } from '../stores/gameStore';

/**
 * Custom hook for managing game sound effects
 */
export const useSound = () => {
  const soundEnabled = useGameStore(state => state.unifiedSettings?.audio?.soundEnabled ?? true);
  const audioMasterVolume = useGameStore(state => state.unifiedSettings?.audio?.audioMasterVolume ?? 80);
  const sfxVolume = useGameStore(state => state.unifiedSettings?.audio?.sfxVolume ?? 70);
  const musicVolume = useGameStore(state => state.unifiedSettings?.audio?.musicVolume ?? 60);

  // Update sound service settings when they change
  useEffect(() => {
    soundService.updateSettings();
  }, [soundEnabled, audioMasterVolume, sfxVolume, musicVolume]);

  // Initialize sounds (user interaction required)
  const initSounds = useCallback(() => {
    initializeSounds();
  }, []);

  // Sound trigger functions
  const playClick = useCallback(() => {
    if (soundEnabled) soundService.playClick();
  }, [soundEnabled]);

  const playMove = useCallback(() => {
    if (soundEnabled) soundService.playMove();
  }, [soundEnabled]);

  const playPickup = useCallback(() => {
    if (soundEnabled) soundService.playPickup();
  }, [soundEnabled]);

  const playSuccess = useCallback(() => {
    if (soundEnabled) soundService.playSuccess();
  }, [soundEnabled]);

  const playError = useCallback(() => {
    if (soundEnabled) soundService.playError();
  }, [soundEnabled]);

  const playNotification = useCallback(() => {
    if (soundEnabled) soundService.playNotification();
  }, [soundEnabled]);

  const playAttack = useCallback(() => {
    if (soundEnabled) soundService.playAttack();
  }, [soundEnabled]);

  const playHeal = useCallback(() => {
    if (soundEnabled) soundService.playHeal();
  }, [soundEnabled]);

  const playLevelUp = useCallback(() => {
    if (soundEnabled) soundService.playLevelUp();
  }, [soundEnabled]);

  const playDamage = useCallback(() => {
    if (soundEnabled) soundService.playDamage();
  }, [soundEnabled]);

  const playNavigation = useCallback(() => {
    if (soundEnabled) soundService.playNavigation();
  }, [soundEnabled]);

  const playAmbient = useCallback(() => {
    if (soundEnabled) soundService.playAmbient();
  }, [soundEnabled]);

  return {
    // Settings
    soundEnabled,
    audioMasterVolume,
    sfxVolume,
    musicVolume,

    // Actions
    initSounds,
    playClick,
    playMove,
    playPickup,
    playSuccess,
    playError,
    playNotification,
    playAttack,
    playHeal,
    playLevelUp,
    playDamage,
    playNavigation,
    playAmbient,
  };
};

export default useSound;
</file>

<file path="packages/frontend/src/hooks/useTheme.ts">
import { useEffect } from 'react';
import { useGameStore } from '../stores/gameStore';
import { Theme } from 'shared';
import { COLORS } from '../utils/tokens';

// Build theme color objects from centralized Tailwind tokens (COLORS).
// This keeps a single source of truth for palette values and ensures
// components using CSS variables stay in sync with Tailwind tokens.
const getNightThemeColors = () => ({
  '--color-background-primary': COLORS.backgroundDark || COLORS.background || '#0a0a14',
  '--color-background-secondary': COLORS.backgroundMedium || '#111122',
  '--color-background-tertiary': COLORS.backgroundDark || '#0f0f1a',
  '--color-surface': COLORS.surface || '#141428',
  '--color-surface-variant': COLORS['surface-variant'] || '#1a1a2e',

  '--color-text-primary': (COLORS.text && COLORS.text.primary) || '#e2e8f0',
  '--color-text-secondary': (COLORS.text && COLORS.text.secondary) || '#cbd5e1',
  '--color-text-tertiary': (COLORS.text && COLORS.text.tertiary) || '#94a3b8',
  '--color-text-on-surface': (COLORS.text && COLORS.text.primary) || '#e2e8f0',

  '--color-primary': COLORS.primaryBlue || COLORS.primary || '#60a5fa',
  '--color-primary-container': COLORS['primary-container'] || COLORS['primary-container'] || '#1e3a8a',
  '--color-on-primary': COLORS['on-primary'] || '#0f172a',
  '--color-on-primary-container': COLORS['on-primary'] || '#dbeafe',

  '--color-secondary': COLORS.secondaryBlue || COLORS.secondary || '#64748b',
  '--color-secondary-container': COLORS['secondary-container'] || '#334155',
  '--color-on-secondary': COLORS['on-secondary'] || '#0f172a',
  '--color-on-secondary-container': COLORS['on-secondary'] || '#f1f5f9',

  '--color-tertiary': COLORS.accentPurple || COLORS['accentPurple'] || '#a78bfa',
  '--color-tertiary-container': COLORS['tertiary-container'] || '#3730a3',
  '--color-on-tertiary': COLORS['on-tertiary'] || '#0f172a',
  '--color-on-tertiary-container': COLORS['on-tertiary-container'] || '#e9d5ff',

  '--color-error': COLORS.error || '#f87171',
  '--color-error-container': COLORS['error-container'] || '#7f1d1d',
  '--color-on-error': COLORS['on-error'] || '#0f172a',
  '--color-on-error-container': COLORS['on-error-container'] || '#fef2f2',

  '--color-success': COLORS.health && COLORS.health.healthy ? COLORS.health.healthy : COLORS['success'] || '#4ade80',
  '--color-success-container': COLORS['success-container'] || '#166534',
  '--color-on-success': COLORS['on-success'] || '#0f172a',
  '--color-on-success-container': COLORS['on-success-container'] || '#f0fdf4',

  '--color-warning': COLORS['health'] && COLORS.health.wounded ? COLORS.health.wounded : COLORS['warning'] || '#fbbf24',
  '--color-warning-container': COLORS['warning-container'] || '#92400e',
  '--color-on-warning': COLORS['on-warning'] || '#0f172a',
  '--color-on-warning-container': COLORS['on-warning-container'] || '#fffbeb',

  '--color-outline': COLORS.outline || '#475569',
  '--color-outline-variant': COLORS['outline-variant'] || '#64748b',

  '--color-legend-knight': COLORS.legendKnight || '#3b82f6',
  '--color-legend-rogue': COLORS.legendRogue || '#ef4444',
  '--color-legend-mage': COLORS.legendMage || '#8b5cf6',
  '--color-legend-npc': COLORS.legendNPC || '#f97316',
  '--color-legend-item': COLORS.legendItem || '#22c55e',

  '--color-health-healthy': (COLORS.health && COLORS.health.healthy) || '#22c55e',
  '--color-health-wounded': (COLORS.health && COLORS.health.wounded) || '#eab308',
  '--color-health-critical': (COLORS.health && COLORS.health.critical) || '#f97316',
  '--color-health-dying': (COLORS.health && COLORS.health.dying) || '#ef4444',
  '--color-health-fill-healthy-start': COLORS.health && COLORS.health.healthy || '#22c55e',
  '--color-health-fill-healthy-end': COLORS.healthFillHealthyEnd || '#16a34a',
  '--color-health-fill-wounded-start': COLORS.healthFillWoundedStart || '#eab308',
  '--color-health-fill-wounded-end': COLORS.healthFillWoundedEnd || '#ca8a04',
  '--color-health-fill-critical-start': COLORS.healthFillCriticalStart || '#f97316',
  '--color-health-fill-critical-end': COLORS.healthFillCriticalEnd || '#ea580c',
  '--color-health-fill-dying-start': COLORS.healthFillDyingStart || '#ef4444',
  '--color-health-fill-dying-end': COLORS.healthFillDyingEnd || '#dc2626',

  '--color-exp-fill-start': COLORS.expFillStart || '#8b5cf6',
  '--color-exp-fill-end': COLORS.expFillEnd || '#7c3aed',
  '--color-exp-value': COLORS.expValue || '#8b5cf6',

  '--color-status-active-bg': (COLORS.status && COLORS.status.active && COLORS.status.active.bg) || '#f0fdf4',
  '--color-status-active-text': (COLORS.status && COLORS.status.active && COLORS.status.active.text) || '#166534',
  '--color-status-active-border': (COLORS.status && COLORS.status.active && COLORS.status.active.border) || '#bbf7d0',
  '--color-status-negative-bg': (COLORS.status && COLORS.status.negative && COLORS.status.negative.bg) || '#fef2f2',
  '--color-status-negative-text': (COLORS.status && COLORS.status.negative && COLORS.status.negative.text) || '#991b1b',
  '--color-status-negative-border': (COLORS.status && COLORS.status.negative && COLORS.status.negative.border) || '#fecaca',
});

const getLightThemeColors = () => ({
  '--color-background-primary': COLORS.background || '#ffffff',
  '--color-background-secondary': COLORS['backgroundMedium'] || '#f8fafc',
  '--color-background-tertiary': COLORS['background'] || '#f1f5f9',
  '--color-surface': COLORS.surface || '#ffffff',
  '--color-surface-variant': COLORS['surface-variant'] || '#f8fafc',

  '--color-text-primary': (COLORS.text && COLORS.text.primary) || '#1e293b',
  '--color-text-secondary': (COLORS.text && COLORS.text.secondary) || '#475569',
  '--color-text-tertiary': (COLORS.text && COLORS.text.tertiary) || '#64748b',
  '--color-text-on-surface': (COLORS.text && COLORS.text.primary) || '#1e293b',

  '--color-primary': COLORS.primaryBlue || COLORS.primary || '#2563eb',
  '--color-primary-container': COLORS['primary-container'] || '#dbeafe',
  '--color-on-primary': COLORS['on-primary'] || '#ffffff',
  '--color-on-primary-container': COLORS['on-primary-container'] || '#1e40af',

  '--color-secondary': COLORS.secondaryBlue || COLORS.secondary || '#64748b',
  '--color-secondary-container': COLORS['secondary-container'] || '#f1f5f9',
  '--color-on-secondary': COLORS['on-secondary'] || '#ffffff',
  '--color-on-secondary-container': COLORS['on-secondary-container'] || '#334155',

  '--color-tertiary': COLORS.accentPurple || '#7c3aed',
  '--color-tertiary-container': COLORS['tertiary-container'] || '#f3e8ff',
  '--color-on-tertiary': COLORS['on-tertiary'] || '#ffffff',
  '--color-on-tertiary-container': COLORS['on-tertiary-container'] || '#581c87',

  '--color-error': COLORS.error || '#dc2626',
  '--color-error-container': COLORS['error-container'] || '#fef2f2',
  '--color-on-error': COLORS['on-error'] || '#ffffff',
  '--color-on-error-container': COLORS['on-error-container'] || '#7f1d1d',

  '--color-success': COLORS.health && COLORS.health.healthy || '#16a34a',
  '--color-success-container': COLORS['success-container'] || '#f0fdf4',
  '--color-on-success': COLORS['on-success'] || '#ffffff',
  '--color-on-success-container': COLORS['on-success-container'] || '#166534',

  '--color-warning': COLORS['health'] && COLORS.health.wounded || '#ca8a04',
  '--color-warning-container': COLORS['warning-container'] || '#fffbeb',
  '--color-on-warning': COLORS['on-warning'] || '#ffffff',
  '--color-on-warning-container': COLORS['on-warning-container'] || '#92400e',

  '--color-outline': COLORS.outline || '#cbd5e1',
  '--color-outline-variant': COLORS['outline-variant'] || '#e2e8f0',

  '--color-legend-knight': COLORS.legendKnight || '#2563eb',
  '--color-legend-rogue': COLORS.legendRogue || '#dc2626',
  '--color-legend-mage': COLORS.legendMage || '#7c3aed',
  '--color-legend-npc': COLORS.legendNPC || '#ea580c',
  '--color-legend-item': COLORS.legendItem || '#16a34a',

  '--color-health-healthy': (COLORS.health && COLORS.health.healthy) || '#16a34a',
  '--color-health-wounded': (COLORS.health && COLORS.health.wounded) || '#ca8a04',
  '--color-health-critical': (COLORS.health && COLORS.health.critical) || '#ea580c',
  '--color-health-dying': (COLORS.health && COLORS.health.dying) || '#dc2626',
  '--color-health-fill-healthy-start': COLORS.healthFillHealthyStart || '#16a34a',
  '--color-health-fill-healthy-end': COLORS.healthFillHealthyEnd || '#15803d',
  '--color-health-fill-wounded-start': COLORS.healthFillWoundedStart || '#ca8a04',
  '--color-health-fill-wounded-end': COLORS.healthFillWoundedEnd || '#a16207',
  '--color-health-fill-critical-start': COLORS.healthFillCriticalStart || '#ea580c',
  '--color-health-fill-critical-end': COLORS.healthFillCriticalEnd || '#c2410c',
  '--color-health-fill-dying-start': COLORS.healthFillDyingStart || '#dc2626',
  '--color-health-fill-dying-end': COLORS.healthFillDyingEnd || '#b91c1c',

  '--color-exp-fill-start': COLORS.expFillStart || '#7c3aed',
  '--color-exp-fill-end': COLORS.expFillEnd || '#581c87',
  '--color-exp-value': COLORS.expValue || '#7c3aed',

  '--color-status-active-bg': (COLORS.status && COLORS.status.active && COLORS.status.active.bg) || '#f0fdf4',
  '--color-status-active-text': (COLORS.status && COLORS.status.active && COLORS.status.active.text) || '#166534',
  '--color-status-active-border': (COLORS.status && COLORS.status.active && COLORS.status.active.border) || '#bbf7d0',
  '--color-status-negative-bg': (COLORS.status && COLORS.status.negative && COLORS.status.negative.bg) || '#fef2f2',
  '--color-status-negative-text': (COLORS.status && COLORS.status.negative && COLORS.status.negative.text) || '#991b1b',
  '--color-status-negative-border': (COLORS.status && COLORS.status.negative && COLORS.status.negative.border) || '#fecaca',
});

const getDarkThemeColors = () => ({
  '--color-background-primary': COLORS.background || '#0f0f23',
  '--color-background-secondary': COLORS.backgroundMedium || '#1a1a2e',
  '--color-background-tertiary': COLORS.background || '#16213e',
  '--color-surface': COLORS.surface || '#1e1e2e',
  '--color-surface-variant': COLORS['surface-variant'] || '#2a2a3e',

  '--color-text-primary': (COLORS.text && COLORS.text.primary) || '#cdd6f4',
  '--color-text-secondary': (COLORS.text && COLORS.text.secondary) || '#bac2de',
  '--color-text-tertiary': (COLORS.text && COLORS.text.tertiary) || '#a6adc8',
  '--color-text-on-surface': (COLORS.text && COLORS.text.primary) || '#cdd6f4',

  '--color-primary': COLORS.primaryBlue || COLORS.primary || '#89b4fa',
  '--color-primary-container': COLORS['primary-container'] || '#1e40af',
  '--color-on-primary': COLORS['on-primary'] || '#1e1e2e',
  '--color-on-primary-container': COLORS['on-primary-container'] || '#dbeafe',

  '--color-secondary': COLORS.secondaryBlue || COLORS.secondary || '#94a3b8',
  '--color-secondary-container': COLORS['secondary-container'] || '#334155',
  '--color-on-secondary': COLORS['on-secondary'] || '#1e1e2e',
  '--color-on-secondary-container': COLORS['on-secondary-container'] || '#f1f5f9',

  '--color-tertiary': COLORS.accentPurple || COLORS['accentPurple'] || '#c4a7e7',
  '--color-tertiary-container': COLORS['tertiary-container'] || '#581c87',
  '--color-on-tertiary': COLORS['on-tertiary'] || '#1e1e2e',
  '--color-on-tertiary-container': COLORS['on-tertiary-container'] || '#f3e8ff',

  '--color-error': COLORS.error || '#f38ba8',
  '--color-error-container': COLORS['error-container'] || '#7f1d1d',
  '--color-on-error': COLORS['on-error'] || '#1e1e2e',
  '--color-on-error-container': COLORS['on-error-container'] || '#fef2f2',

  '--color-success': (COLORS.health && COLORS.health.healthy) || '#a6e3a1',
  '--color-success-container': COLORS['success-container'] || '#166534',
  '--color-on-success': COLORS['on-success'] || '#1e1e2e',
  '--color-on-success-container': COLORS['on-success-container'] || '#f0fdf4',

  '--color-warning': COLORS['warning'] || '#f9e2af',
  '--color-warning-container': COLORS['warning-container'] || '#92400e',
  '--color-on-warning': COLORS['on-warning'] || '#1e1e2e',
  '--color-on-warning-container': COLORS['on-warning-container'] || '#fffbeb',

  '--color-outline': COLORS.outline || '#6c7086',
  '--color-outline-variant': COLORS['outline-variant'] || '#9399b2',

  '--color-legend-knight': COLORS.legendKnight || '#2563eb',
  '--color-legend-rogue': COLORS.legendRogue || '#dc2626',
  '--color-legend-mage': COLORS.legendMage || '#7c3aed',
  '--color-legend-npc': COLORS.legendNPC || '#ea580c',
  '--color-legend-item': COLORS.legendItem || '#16a34a',

  '--color-health-healthy': (COLORS.health && COLORS.health.healthy) || '#16a34a',
  '--color-health-wounded': (COLORS.health && COLORS.health.wounded) || '#ca8a04',
  '--color-health-critical': (COLORS.health && COLORS.health.critical) || '#ea580c',
  '--color-health-dying': (COLORS.health && COLORS.health.dying) || '#dc2626',
  '--color-health-fill-healthy-start': COLORS.healthFillHealthyStart || '#16a34a',
  '--color-health-fill-healthy-end': COLORS.healthFillHealthyEnd || '#15803d',
  '--color-health-fill-wounded-start': COLORS.healthFillWoundedStart || '#ca8a04',
  '--color-health-fill-wounded-end': COLORS.healthFillWoundedEnd || '#a16207',
  '--color-health-fill-critical-start': COLORS.healthFillCriticalStart || '#ea580c',
  '--color-health-fill-critical-end': COLORS.healthFillCriticalEnd || '#c2410c',
  '--color-health-fill-dying-start': COLORS.healthFillDyingStart || '#dc2626',
  '--color-health-fill-dying-end': COLORS.healthFillDyingEnd || '#b91c1c',

  '--color-exp-fill-start': COLORS.expFillStart || '#7c3aed',
  '--color-exp-fill-end': COLORS.expFillEnd || '#581c87',
  '--color-exp-value': COLORS.expValue || '#7c3aed',

  '--color-status-active-bg': (COLORS.status && COLORS.status.active && COLORS.status.active.bg) || '#f0fdf4',
  '--color-status-active-text': (COLORS.status && COLORS.status.active && COLORS.status.active.text) || '#166534',
  '--color-status-active-border': (COLORS.status && COLORS.status.active && COLORS.status.active.border) || '#bbf7d0',
  '--color-status-negative-bg': (COLORS.status && COLORS.status.negative && COLORS.status.negative.bg) || '#fef2f2',
  '--color-status-negative-text': (COLORS.status && COLORS.status.negative && COLORS.status.negative.text) || '#991b1b',
  '--color-status-negative-border': (COLORS.status && COLORS.status.negative && COLORS.status.negative.border) || '#fecaca',
});

const themeColorMap = {
  [Theme.LIGHT]: getLightThemeColors,
  [Theme.DARK]: getDarkThemeColors,
  [Theme.NIGHT]: getNightThemeColors,
  [Theme.AUTO]: getDarkThemeColors, // Default to dark for auto until we implement system preference detection
};

export const useTheme = () => {
  const { unifiedSettings } = useGameStore();
  const currentTheme = unifiedSettings.visual.theme;

  useEffect(() => {
    const root = document.documentElement;
    const colorsGetter = themeColorMap[currentTheme] || getDarkThemeColors;
    const colors = colorsGetter();

    // Apply all theme colors to CSS custom properties
    Object.entries(colors).forEach(([property, value]) => {
      // ensure the value is a string before setting
      root.style.setProperty(property, String(value));
    });

    // Store current theme in localStorage for persistence
    localStorage.setItem('chatte-realm-theme', currentTheme);
  }, [currentTheme]);

  const currentColorsGetter = themeColorMap[currentTheme] || getDarkThemeColors;

  return {
    currentTheme,
    availableThemes: Object.values(Theme),
    themeColors: currentColorsGetter(),
  };
};
</file>

<file path="packages/frontend/src/services/__tests__/BiomeTextureService.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { BiomeTextureService } from '../BiomeTextureService';
import { Biome, BiomeType, Position } from 'shared';
import { RoughCanvas } from 'roughjs/bin/canvas';

// Mocking PoissonDiskSampling
vi.mock('poisson-disk-sampling', () => ({
  default: vi.fn(() => ({
    fill: vi.fn().mockReturnValue([[5, 5], [8, 8]]),
  })),
}));

const mockRoughCanvas = {
  line: vi.fn(),
  circle: vi.fn(),
  polygon: vi.fn(),
  rectangle: vi.fn(),
};

describe('BiomeTextureService', () => {
  let service: BiomeTextureService;
  const mockBiome: Biome = {
    id: 'biome-1',
    type: BiomeType.FOREST,
    cells: [{x: 0, y: 0}, {x: 5, y: 5}, {x: 8, y: 8}],
    bounds: { minX: 0, minY: 0, maxX: 10, maxY: 10 },
  };

  beforeEach(() => {
    service = new BiomeTextureService();
    vi.clearAllMocks();
  });

  it('should add texture overlay for trees', () => {
    service.addTextureOverlay(mockBiome, { type: 'trees', density: 0.1, size: 10 }, mockRoughCanvas as any, 0);
    expect(mockRoughCanvas.line).toHaveBeenCalled();
    expect(mockRoughCanvas.circle).toHaveBeenCalled();
  });

  it('should add texture overlay for rocks', () => {
    service.addTextureOverlay(mockBiome, { type: 'rocks', density: 0.1, size: 8 }, mockRoughCanvas as any, 0);
    expect(mockRoughCanvas.polygon).toHaveBeenCalled();
  });

  it('should add texture overlay for crystals', () => {
    service.addTextureOverlay(mockBiome, { type: 'crystals', density: 0.1, size: 12 }, mockRoughCanvas as any, 0);
    expect(mockRoughCanvas.polygon).toHaveBeenCalled();
  });

  it('should add texture overlay for ruins', () => {
    service.addTextureOverlay(mockBiome, { type: 'ruins', density: 0.1, size: 15 }, mockRoughCanvas as any, 0);
    expect(mockRoughCanvas.rectangle).toHaveBeenCalled();
  });

  it('should add texture overlay for corruption', () => {
    service.addTextureOverlay(mockBiome, { type: 'corruption', density: 0.1, size: 5 }, mockRoughCanvas as any, 0);
    expect(mockRoughCanvas.circle).toHaveBeenCalled();
  });
});
</file>

<file path="packages/frontend/src/services/__tests__/BiomeTransitionService.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { BiomeTransitionService } from '../BiomeTransitionService';
import { Biome, BiomeType } from 'shared';
import { RoughCanvas } from 'roughjs/bin/canvas';

const mockRoughCanvas = {
  linearPath: vi.fn(),
};

describe('BiomeTransitionService', () => {
  let service: BiomeTransitionService;
  const biomeA: Biome = {
    id: 'A',
    type: BiomeType.GRASSLAND,
    cells: [{x: 1, y: 1}],
    bounds: { minX: 1, minY: 1, maxX: 1, maxY: 1 },
  };
  const biomeB: Biome = {
    id: 'B',
    type: BiomeType.FOREST,
    cells: [{x: 2, y: 1}],
    bounds: { minX: 2, minY: 1, maxX: 2, maxY: 1 },
  };

  beforeEach(() => {
    service = new BiomeTransitionService();
    vi.clearAllMocks();
  });

  it('should identify and render transitions between adjacent biomes', () => {
    const biomes = [biomeA, biomeB];
    service.renderBiomeTransitions(biomes, mockRoughCanvas as any, 10);

    expect(mockRoughCanvas.linearPath).toHaveBeenCalled();
    const call = mockRoughCanvas.linearPath.mock.calls[0];
    const options = call[1];

    // Check if the blended color is applied
    expect(options.stroke).toContain('rgba');
    expect(options.strokeWidth).toBeGreaterThan(1);
  });
});
</file>

<file path="packages/frontend/src/services/__tests__/BoundaryTracer.test.ts">
import { describe, it, expect } from 'vitest';
import { BoundaryTracer } from '../../utils/boundaryTracing';
import { Position } from 'shared';

describe('BoundaryTracer', () => {
  const tracer = new BoundaryTracer();

  it('should return an empty array for empty cells', () => {
    const cells: Position[] = [];
    const boundary = tracer.march(cells, 16);
    expect(boundary).toEqual([]);
  });

  it('should create a simple square boundary', () => {
    const cells: Position[] = [
      { x: 1, y: 1 }, { x: 2, y: 1 },
      { x: 1, y: 2 }, { x: 2, y: 2 },
    ];
    const boundary = tracer.march(cells, 10);

    // The exact output depends on the marching squares implementation and simplification.
    // A reasonable expectation is a simplified polygon representing the outer boundary.
    expect(boundary.length).toBeGreaterThan(3);
    // Further checks could validate the coordinates of the bounding box.
  });

  it('should handle a more complex shape', () => {
    const cells: Position[] = [
      { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 3, y: 1 },
      { x: 1, y: 2 }, { x: 3, y: 2 },
      { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 3, y: 3 },
    ];
    const boundary = tracer.march(cells, 10);
    expect(boundary.length).toBeGreaterThan(3);
  });
});
</file>

<file path="packages/frontend/src/services/__tests__/CorruptionOverlayService.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { CorruptionOverlayService } from '../CorruptionOverlayService';
import { Biome, BiomeType } from 'shared';
import { RoughCanvas } from 'roughjs/bin/canvas';

vi.mock('poisson-disk-sampling', () => ({
  default: vi.fn(() => ({
    fill: vi.fn().mockReturnValue([[5, 5]]),
  })),
}));

const mockRoughCanvas = {
  circle: vi.fn(),
};

describe('CorruptionOverlayService', () => {
  let service: CorruptionOverlayService;
  const mockBiome: Biome = {
    id: 'biome-1',
    type: BiomeType.GRASSLAND,
    cells: [{x: 5, y: 5}],
    bounds: { minX: 0, minY: 0, maxX: 10, maxY: 10 },
  };

  beforeEach(() => {
    service = new CorruptionOverlayService();
    vi.clearAllMocks();
  });

  it('should not apply effects for low corruption levels', () => {
    service.applyCorruptionEffects(mockBiome, 0.05, mockRoughCanvas as any, 0);
    expect(mockRoughCanvas.circle).not.toHaveBeenCalled();
  });

  it('should apply corruption growths for high corruption levels', () => {
    service.applyCorruptionEffects(mockBiome, 0.8, mockRoughCanvas as any, 0);
    expect(mockRoughCanvas.circle).toHaveBeenCalled();
    const call = mockRoughCanvas.circle.mock.calls[0];
    const options = call[3];
    expect(options.fill).toContain('rgba(148, 0, 211');
  });
});
</file>

<file path="packages/frontend/src/services/__tests__/UnifiedRoughFillService.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { UnifiedRoughFillService } from '../UnifiedRoughFillService';
import { Biome, BiomeType } from 'shared';
import { RoughCanvas } from 'roughjs/bin/canvas';

// Mocking BoundaryTracer dependency
vi.mock('../../utils/boundaryTracing', () => ({
  BoundaryTracer: vi.fn(() => ({
    march: vi.fn().mockReturnValue([
      [10, 10], [100, 10], [100, 100], [10, 100]
    ]),
  })),
}));

// Mocking RoughCanvas
const mockRoughCanvas = {
  polygon: vi.fn(),
};

describe('UnifiedRoughFillService', () => {
  let service: UnifiedRoughFillService;
  const mockBiome: Biome = {
    id: 'biome-1',
    type: BiomeType.GRASSLAND,
    cells: [{x: 0, y: 0}],
    bounds: { minX: 0, minY: 0, maxX: 10, maxY: 10 },
  };

  beforeEach(() => {
    service = new UnifiedRoughFillService(mockRoughCanvas as unknown as RoughCanvas);
    vi.clearAllMocks();
  });

  it('should call boundary tracer and draw a polygon', () => {
    service.applyUnifiedBiomeFill(mockBiome, 16, 0);
    expect(mockRoughCanvas.polygon).toHaveBeenCalledOnce();
  });

  it('should apply animation properties to the render config', () => {
    const animatedBiome: Biome = { ...mockBiome, type: BiomeType.TOXIC_ZONE };
    service.applyUnifiedBiomeFill(animatedBiome, 16, 100);

    const call = mockRoughCanvas.polygon.mock.calls[0];
    const options = call[1];

    expect(options.roughness).not.toBe(3);
    expect(options.bowing).not.toBe(2.5);
    expect(options.fill).not.toBe('#7FFF00');
  });
});
</file>

<file path="packages/frontend/src/services/chat/CommandProcessor.ts">
class CommandProcessor {
  public isCommand(message: string): boolean {
    return message.startsWith('!');
  }

  public getPresetCommands(): string[] {
    return [
      '!help',
      '!spawn knight',
      '!spawn rogue',
      '!spawn mage',
      '!move up',
      '!move down',
      '!move left',
      '!move right',
      '!status'
    ];
  }

  // Future command parsing and execution logic could go here.
  // For now, it simply identifies commands and provides preset ones.
}

export const commandProcessor = new CommandProcessor();
</file>

<file path="packages/frontend/src/services/notification/NotificationFactory.ts">
import { NotificationData } from '../../types/notification';

export const createNotification = (data: Omit<NotificationData, 'id'>): NotificationData => {
  return {
    id: `notification-${Date.now()}-${Math.random()}`,
    ...data,
  };
};
</file>

<file path="packages/frontend/src/services/notification/NotificationManager.ts">
import { NotificationData, NotificationType } from '../../types/notification';

// Utility function to show notifications from anywhere in the app
export const showNotification = (data: Omit<NotificationData, 'id'>) => {
  const notification: NotificationData = {
    id: `notification-${Date.now()}-${Math.random()}`,
    ...data
  };

  const event = new CustomEvent('game-notification', { detail: notification });
  window.dispatchEvent(event);
};

// Preset notification helpers
export const notificationHelpers = {
  success: (title: string, message: string, options?: Partial<NotificationData>) => {
    showNotification({ type: 'success', title, message, ...options });
  },
  error: (title: string, message: string, options?: Partial<NotificationData>) => {
    showNotification({ type: 'error', title, message, ...options });
  },
  warning: (title: string, message: string, options?: Partial<NotificationData>) => {
    showNotification({ type: 'warning', title, message, ...options });
  },
  info: (title: string, message: string, options?: Partial<NotificationData>) => {
    showNotification({ type: 'info', title, message, ...options });
  },
  combat: (title: string, message: string, damage?: number, options?: Partial<NotificationData>) => {
    const icon = damage ? (damage > 0 ? 'âš¡' : 'ðŸ›¡ï¸') : 'âš”ï¸';
    showNotification({ type: 'combat', title, message, icon, ...options });
  },
  loot: (title: string, message: string, rarity?: string, options?: Partial<NotificationData>) => {
    const rarityIcons: Record<string, string> = {
      common: 'ðŸ“¦',
      uncommon: 'ðŸ’š', 
      rare: 'ðŸ’™',
      epic: 'ðŸ’œ',
      legendary: 'ðŸŸ '
    };
    const icon = rarity ? rarityIcons[rarity.toLowerCase()] || 'ðŸ’Ž' : 'ðŸ’Ž';
    showNotification({ type: 'loot', title, message, icon, ...options });
  },
  social: (title: string, message: string, options?: Partial<NotificationData>) => {
    showNotification({ type: 'social', title, message, ...options });
  },
  system: (title: string, message: string, options?: Partial<NotificationData>) => {
    showNotification({ type: 'system', title, message, ...options });
  },
  levelUp: (level: number, className?: string) => {
    showNotification({
      type: 'success',
      title: 'ðŸŽ‰ Level Up!',
      message: `You reached level ${level}${className ? ` as a ${className}` : ''}!`,
      icon: 'â­',
      duration: 6000,
      persistent: false
    });
  },
  lowHealth: (currentHp: number, maxHp: number) => {
    showNotification({
      type: 'warning',
      title: 'âš¡ Low Health!',
      message: `Health critical: ${currentHp}/${maxHp} HP remaining`,
      icon: 'ðŸ’”',
      persistent: true,
      actions: [
        {
          label: 'Heal',
          action: () => {
            // This would trigger healing action in the game
            console.log('Healing action triggered');
          },
          style: 'primary'
        }
      ]
    });
  }
};
</file>

<file path="packages/frontend/src/services/notification/NotificationQueue.ts">
import { NotificationData } from '../../types/notification';
import { useGameStore } from '../../stores/gameStore';

class NotificationQueue {
  private maxNotifications: number;

  constructor(maxNotifications: number = 5) {
    this.maxNotifications = maxNotifications;
  }

  addNotification(notification: Omit<NotificationData, 'id'>) {
    const store = useGameStore.getState();
    const currentNotifications = store.notifications;

    // Create notification with ID
    const newNotification: NotificationData = {
      ...notification,
      id: `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    };

    // Add to beginning and limit
    const updatedNotifications = [newNotification, ...currentNotifications].slice(0, this.maxNotifications);

    // Update store
    store.notifications = updatedNotifications;

    // Auto-remove after duration if specified
    if (newNotification.duration && !newNotification.persistent) {
      setTimeout(() => {
        this.removeNotification(newNotification.id);
      }, newNotification.duration);
    }
  }

  removeNotification(id: string) {
    const store = useGameStore.getState();
    store.removeNotification(id);
  }

  getNotifications(): NotificationData[] {
    return useGameStore.getState().notifications;
  }

  // Legacy subscribe method for backward compatibility - returns empty unsubscribe
  subscribe(callback: (notifications: NotificationData[]) => void) {
    // Since we're using Zustand now, we don't need subscribers
    // Components should use useGameStore directly
    callback(this.getNotifications());
    return () => {}; // No-op unsubscribe
  }
}

export const notificationQueue = new NotificationQueue();
</file>

<file path="packages/frontend/src/services/player/EffectManager.ts">
import { PlayerEffect, PlayerStats } from '../../types/playerStatus';

export const getActiveEffects = (player: any): PlayerEffect[] => {
  // Mock active effects, replace with actual game logic
  return player.buffs?.map((buff: any) => ({
    type: buff.type,
    duration: buff.duration,
    strength: buff.strength,
  })) || [];
};
</file>

<file path="packages/frontend/src/services/player/HealthManager.ts">
import { PlayerStats } from '../../types/playerStatus';

export const calculateHealth = (stats: PlayerStats): number => {
  return stats.health;
};
</file>

<file path="packages/frontend/src/services/player/StatusCalculator.ts">
import { PlayerStats, PlayerEffect } from '../../types/playerStatus';
import { Player } from 'shared';

export const calculatePlayerStats = (player: Player): PlayerStats => {
  // Mock data for now, replace with actual game logic later
  return {
    health: player.health,
    maxHealth: 100,
    mana: player.mana,
    maxMana: 50,
    stamina: player.stamina,
    maxStamina: 75,
    experience: player.experience,
    level: player.level,
    hunger: player.hunger,
    thirst: player.thirst,
  };
};

export const applyEffectsToStats = (stats: PlayerStats, effects: PlayerEffect[]): PlayerStats => {
  // Apply effects to stats, this is a placeholder
  return { ...stats };
};
</file>

<file path="packages/frontend/src/services/worldGeneration/BiomeGenerator.ts">
import { perlinNoise } from './NoiseGenerator';

// Biome generation - create distinct regions with much less ocean
export const getBiome = (x: number, y: number) => {
  const continentNoise = perlinNoise(x, y, 2) * 0.9 + 0.05;
  const temperature = perlinNoise(x * 0.3, y * 0.3, 3) * 0.9 + 0.05;
  const humidity = perlinNoise(x * 0.4, y * 0.4, 4) * 0.9 + 0.05;

  // Continental plates - significantly reduced ocean for maximum land
  if (continentNoise > 0.85) return 'mountain_range';
  if (continentNoise < 0.08) return 'ocean'; // Reduced to 8% ocean coverage

  // Climate-based biomes with better distribution
  if (temperature < 0.2) return 'tundra';
  if (temperature > 0.8 && humidity > 0.7) return 'jungle';
  if (temperature > 0.7 && humidity < 0.3) return 'desert';
  if (humidity > 0.8) return 'swamp';
  if (temperature > 0.6) return 'grassland';

  return 'temperate_forest';
};
</file>

<file path="packages/frontend/src/services/worldGeneration/LootSpawnSystem.ts">
import { Item, ItemType, ItemRarity, Position } from 'shared';
import { BiomeType } from 'shared';
import { perlinNoise } from './NoiseGenerator';

// Terrain-based loot configuration
const TERRAIN_LOOT_CONFIG: Record<BiomeType, {
  spawnChance: number;
  preferredTypes: ItemType[];
  rarityWeights: { common: number; uncommon: number; rare: number; epic?: number; legendary?: number };
  maxItemsPerTile: number;
  lootDensityMultiplier: number;
}> = {
  [BiomeType.ANCIENT_RUINS]: {
    spawnChance: 0.35,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR, ItemType.CONSUMABLE],
    rarityWeights: { common: 20, uncommon: 30, rare: 35, epic: 12, legendary: 3 },
    maxItemsPerTile: 3,
    lootDensityMultiplier: 2.5
  },
  [BiomeType.FOREST]: {
    spawnChance: 0.12,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.WEAPON],
    rarityWeights: { common: 65, uncommon: 25, rare: 10 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.0
  },
  [BiomeType.DENSE_FOREST]: {
    spawnChance: 0.18,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.ARMOR],
    rarityWeights: { common: 55, uncommon: 30, rare: 15 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.3
  },
  [BiomeType.MOUNTAIN]: {
    spawnChance: 0.15,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 50, uncommon: 35, rare: 15 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.2
  },
  [BiomeType.MOUNTAIN_PEAK]: {
    spawnChance: 0.25,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 30, uncommon: 40, rare: 25, epic: 5 },
    maxItemsPerTile: 3,
    lootDensityMultiplier: 1.8
  },
  [BiomeType.SWAMP]: {
    spawnChance: 0.08,
    preferredTypes: [ItemType.CONSUMABLE],
    rarityWeights: { common: 70, uncommon: 20, rare: 10 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.8
  },
  [BiomeType.SAND]: {
    spawnChance: 0.06,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.ARMOR],
    rarityWeights: { common: 75, uncommon: 20, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.6
  },
  [BiomeType.DUNES]: {
    spawnChance: 0.04,
    preferredTypes: [ItemType.ARMOR, ItemType.WEAPON],
    rarityWeights: { common: 60, uncommon: 30, rare: 10 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.7
  },
  [BiomeType.OASIS]: {
    spawnChance: 0.45,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.ARMOR],
    rarityWeights: { common: 40, uncommon: 40, rare: 15, epic: 5 },
    maxItemsPerTile: 3,
    lootDensityMultiplier: 2.0
  },
  [BiomeType.JUNGLE]: {
    spawnChance: 0.20,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.WEAPON],
    rarityWeights: { common: 50, uncommon: 35, rare: 15 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.4
  },
  [BiomeType.DENSE_JUNGLE]: {
    spawnChance: 0.25,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.ARMOR],
    rarityWeights: { common: 45, uncommon: 35, rare: 18, epic: 2 },
    maxItemsPerTile: 3,
    lootDensityMultiplier: 1.6
  },
  [BiomeType.RIVER]: {
    spawnChance: 0.10,
    preferredTypes: [ItemType.CONSUMABLE],
    rarityWeights: { common: 70, uncommon: 25, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.9
  },
  [BiomeType.DEEP_WATER]: {
    spawnChance: 0.03,
    preferredTypes: [ItemType.ARMOR],
    rarityWeights: { common: 80, uncommon: 18, rare: 2 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.5
  },
  [BiomeType.OCEAN]: {
    spawnChance: 0.02,
    preferredTypes: [ItemType.ARMOR],
    rarityWeights: { common: 85, uncommon: 13, rare: 2 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.3
  },
  [BiomeType.ICE]: {
    spawnChance: 0.05,
    preferredTypes: [ItemType.ARMOR, ItemType.CONSUMABLE],
    rarityWeights: { common: 70, uncommon: 25, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.7
  },
  [BiomeType.SNOW]: {
    spawnChance: 0.07,
    preferredTypes: [ItemType.ARMOR, ItemType.CONSUMABLE],
    rarityWeights: { common: 65, uncommon: 30, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.8
  },
  [BiomeType.SNOWY_HILLS]: {
    spawnChance: 0.12,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 55, uncommon: 35, rare: 10 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.1
  },
  // Default for other terrain types
  [BiomeType.PLAIN]: {
    spawnChance: 0.05,
    preferredTypes: [ItemType.CONSUMABLE],
    rarityWeights: { common: 80, uncommon: 18, rare: 2 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.6
  },
  [BiomeType.GRASSLAND]: {
    spawnChance: 0.04,
    preferredTypes: [ItemType.CONSUMABLE],
    rarityWeights: { common: 85, uncommon: 14, rare: 1 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.5
  },
  [BiomeType.HILLS]: {
    spawnChance: 0.08,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 65, uncommon: 30, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.9
  },
  [BiomeType.ROLLING_HILLS]: {
    spawnChance: 0.06,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.ARMOR],
    rarityWeights: { common: 70, uncommon: 25, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.8
  },
  [BiomeType.WATER]: {
    spawnChance: 0.03,
    preferredTypes: [ItemType.CONSUMABLE],
    rarityWeights: { common: 85, uncommon: 14, rare: 1 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.4
  },
  [BiomeType.MARSH]: {
    spawnChance: 0.10,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.ARMOR],
    rarityWeights: { common: 60, uncommon: 30, rare: 10 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.0
  },
  [BiomeType.CLEARING]: {
    spawnChance: 0.15,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.WEAPON],
    rarityWeights: { common: 55, uncommon: 35, rare: 10 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.2
  },
  [BiomeType.ROUGH_TERRAIN]: {
    spawnChance: 0.12,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 60, uncommon: 30, rare: 10 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.1
  },
  [BiomeType.FLOWER_FIELD]: {
    spawnChance: 0.08,
    preferredTypes: [ItemType.CONSUMABLE],
    rarityWeights: { common: 70, uncommon: 25, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.9
  },
  [BiomeType.DESERT]: {
    spawnChance: 0.06,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.ARMOR],
    rarityWeights: { common: 75, uncommon: 20, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.6
  },
  [BiomeType.WASTELAND]: {
    spawnChance: 0.08,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 65, uncommon: 30, rare: 5 },
    maxItemsPerTile: 1,
    lootDensityMultiplier: 0.9
  },
  [BiomeType.TOXIC_ZONE]: {
    spawnChance: 0.10,
    preferredTypes: [ItemType.CONSUMABLE],
    rarityWeights: { common: 60, uncommon: 30, rare: 10 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.0
  },
  [BiomeType.RADIATION_FIELD]: {
    spawnChance: 0.12,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 60, uncommon: 30, rare: 10 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.1
  },
  [BiomeType.CRYSTAL_GARDEN]: {
    spawnChance: 0.15,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.WEAPON],
    rarityWeights: { common: 55, uncommon: 35, rare: 10 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.2
  },
  [BiomeType.URBAN_RUINS]: {
    spawnChance: 0.18,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 50, uncommon: 35, rare: 15 },
    maxItemsPerTile: 2,
    lootDensityMultiplier: 1.3
  },
  [BiomeType.INFECTED_NORMAL]: {
    spawnChance: 0.20,
    preferredTypes: [ItemType.CONSUMABLE, ItemType.ARMOR],
    rarityWeights: { common: 45, uncommon: 35, rare: 20 },
    maxItemsPerTile: 3,
    lootDensityMultiplier: 1.4
  },
  [BiomeType.INFECTED_HEAVY]: {
    spawnChance: 0.25,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 40, uncommon: 35, rare: 25 },
    maxItemsPerTile: 3,
    lootDensityMultiplier: 1.5
  },
  [BiomeType.INFECTED_CORE]: {
    spawnChance: 0.30,
    preferredTypes: [ItemType.WEAPON, ItemType.ARMOR],
    rarityWeights: { common: 30, uncommon: 40, rare: 30 },
    maxItemsPerTile: 4,
    lootDensityMultiplier: 1.6
  }
};

// Loot hotspot configuration for high-value areas
interface LootHotspot {
  center: Position;
  radius: number;
  bonusMultiplier: number;
  rarityBonus: number; // Shifts rarity distribution toward higher tiers
}

// Generate terrain-based loot for the world
export const generateTerrainLoot = (
  terrainGrid: any[][],
  worldWidth: number,
  worldHeight: number,
  lootHotspots: LootHotspot[] = []
): Item[] => {
  const items: Item[] = [];

  for (let y = 0; y < worldHeight; y++) {
    for (let x = 0; x < worldWidth; x++) {
      const terrain = terrainGrid[y]?.[x];
      if (!terrain) continue;

      const config = TERRAIN_LOOT_CONFIG[terrain.type as BiomeType];
      if (!config) continue;

      // Calculate loot density based on noise patterns
      const densityNoise = perlinNoise(x * 0.1, y * 0.1, 1);
      const rarityNoise = perlinNoise(x * 0.05, y * 0.05, 2);
      
      // Check if we're in a loot hotspot
      const hotspot = lootHotspots.find(h => 
        Math.sqrt(Math.pow(x - h.center.x, 2) + Math.pow(y - h.center.y, 2)) <= h.radius
      );

      let spawnChance = config.spawnChance;
      let rarityWeights = { ...config.rarityWeights };
      
      // Apply hotspot bonuses
      if (hotspot) {
        spawnChance *= hotspot.bonusMultiplier;
        // Shift rarity weights toward higher tiers
        Object.keys(rarityWeights).forEach(rarity => {
          if (rarity !== 'common') {
            const key = rarity as keyof typeof rarityWeights;
            rarityWeights[key] = (rarityWeights[key] || 0) * (1 + hotspot.rarityBonus);
          }
        });
      }

      // Apply density multiplier based on noise
      if (densityNoise > 0.6) {
        spawnChance *= config.lootDensityMultiplier;
      }

      // Check if loot spawns at this location
      if (Math.random() < spawnChance) {
        const numItems = Math.min(
          Math.floor(Math.random() * config.maxItemsPerTile) + 1,
          config.maxItemsPerTile
        );

        for (let i = 0; i < numItems; i++) {
          const item = generateTerrainItem(x, y, terrain.type as BiomeType, config, rarityWeights, rarityNoise);
          if (item) {
            items.push(item);
          }
        }
      }
    }
  }

  return items;
};

// Generate a single item for terrain-based loot
const generateTerrainItem = (
  x: number,
  y: number,
  terrainType: BiomeType,
  config: any,
  rarityWeights: any,
  rarityNoise: number
): Item | null => {
  // Select item type
  const itemType = config.preferredTypes[Math.floor(Math.random() * config.preferredTypes.length)];
  
  // Select rarity with noise influence
  let adjustedWeights = { ...rarityWeights };
  if (rarityNoise > 0.8) {
    // High noise areas have better loot
    Object.keys(adjustedWeights).forEach(rarity => {
      if (rarity !== 'common') {
        adjustedWeights[rarity] *= 1.5;
      }
    });
  }
  
  const rarity = selectItemRarity(adjustedWeights);

  const item: Item = {
    id: `terrain_loot_${x}_${y}_${Date.now()}_${Math.random()}`,
    name: generateTerrainItemName(itemType, rarity, terrainType),
    type: itemType,
    rarity,
    description: generateTerrainItemDescription(itemType, rarity, terrainType),
    position: { x, y },
    stats: generateTerrainItemStats(itemType, rarity, terrainType),
    isHidden: true,
    revealDuration: getRevealDuration(rarity),
    revealProgress: 0.0,
    canBeLooted: false
  };

  return item;
};

// Generate terrain-specific item names
const generateTerrainItemName = (type: ItemType, rarity: ItemRarity, terrainType: BiomeType): string => {
  const terrainModifiers = {
    [BiomeType.ANCIENT_RUINS]: ['Ancient', 'Ruined', 'Lost', 'Forgotten'],
    [BiomeType.FOREST]: ['Wooden', 'Natural', 'Forest', 'Wild'],
    [BiomeType.MOUNTAIN]: ['Stone', 'Mountain', 'Rocky', 'Dwarven'],
    [BiomeType.SAND]: ['Desert', 'Sand', 'Sun-bleached', 'Nomad'],
    [BiomeType.SWAMP]: ['Murky', 'Bog', 'Swamp', 'Poisonous'],
    [BiomeType.ICE]: ['Frozen', 'Ice', 'Crystal', 'Arctic']
  };

  const rarityPrefixes = {
    [ItemRarity.COMMON]: ['Worn', 'Simple', 'Basic'],
    [ItemRarity.UNCOMMON]: ['Quality', 'Fine', 'Enhanced'],
    [ItemRarity.RARE]: ['Superior', 'Excellent', 'Masterwork'],
    [ItemRarity.EPIC]: ['Legendary', 'Mythical', 'Ancient'],
    [ItemRarity.LEGENDARY]: ['Divine', 'Immortal', 'Godly']
  };

  const typeNames = {
    [ItemType.WEAPON]: ['Blade', 'Sword', 'Axe', 'Staff', 'Bow', 'Dagger'],
    [ItemType.ARMOR]: ['Shield', 'Helm', 'Armor', 'Boots', 'Gauntlets'],
    [ItemType.CONSUMABLE]: ['Potion', 'Elixir', 'Herb', 'Essence', 'Extract']
  };

  const terrainMod = terrainModifiers[terrainType]?.[Math.floor(Math.random() * terrainModifiers[terrainType].length)] || '';
  const rarityPrefix = rarityPrefixes[rarity][Math.floor(Math.random() * rarityPrefixes[rarity].length)];
  const typeName = typeNames[type][Math.floor(Math.random() * typeNames[type].length)];

  return terrainMod ? `${rarityPrefix} ${terrainMod} ${typeName}` : `${rarityPrefix} ${typeName}`;
};

// Generate terrain-specific item descriptions
const generateTerrainItemDescription = (type: ItemType, rarity: ItemRarity, terrainType: BiomeType): string => {
  const terrainContext = {
    [BiomeType.ANCIENT_RUINS]: 'discovered among ancient ruins',
    [BiomeType.FOREST]: 'found deep in the forest',
    [BiomeType.MOUNTAIN]: 'carved from mountain stone',
    [BiomeType.SAND]: 'buried in desert sands',
    [BiomeType.SWAMP]: 'recovered from murky swamplands',
    [BiomeType.ICE]: 'preserved in eternal ice'
  };

  const context = terrainContext[terrainType] || 'found in the wilderness';
  return `A ${rarity} ${type} ${context}.`;
};

// Generate terrain-specific item stats with environmental bonuses
const generateTerrainItemStats = (type: ItemType, rarity: ItemRarity, terrainType: BiomeType): any => {
  const rarityMultipliers = {
    [ItemRarity.COMMON]: 1,
    [ItemRarity.UNCOMMON]: 1.5,
    [ItemRarity.RARE]: 2.5,
    [ItemRarity.EPIC]: 4,
    [ItemRarity.LEGENDARY]: 6
  };

  const multiplier = rarityMultipliers[rarity];
  
  // Terrain-specific bonuses
  const terrainBonuses = {
    [BiomeType.ANCIENT_RUINS]: 1.3,
    [BiomeType.MOUNTAIN]: 1.1,
    [BiomeType.MOUNTAIN_PEAK]: 1.15
  };

  const terrainMultiplier = terrainBonuses[terrainType] || 1.0;
  const finalMultiplier = multiplier * terrainMultiplier;

  switch (type) {
    case ItemType.WEAPON:
      return { 
        attack: Math.floor(5 * finalMultiplier + Math.random() * 3)
      };
    case ItemType.ARMOR:
      return { 
        defense: Math.floor(3 * finalMultiplier + Math.random() * 2),
        ...(terrainType === BiomeType.ICE && { coldResistance: Math.floor(2 * multiplier) })
      };
    case ItemType.CONSUMABLE:
      return { 
        hp: Math.floor(20 * finalMultiplier + Math.random() * 10),
        ...(terrainType === BiomeType.FOREST && { naturalHealing: true })
      };
    default:
      return {};
  }
};

// Helper functions from BuildingGenerator (shared functionality)
const selectItemRarity = (weights: Record<string, number>): ItemRarity => {
  if (!weights) return ItemRarity.COMMON;
  
  const totalWeight: number = Object.values(weights).reduce((sum: number, weight: number) => {
    return sum + weight;
  }, 0);
  
  let random = Math.random() * totalWeight;
  
  for (const [rarity, weight] of Object.entries(weights)) {
    random -= weight;
    if (random <= 0) {
      return rarity as ItemRarity;
    }
  }
  
  return ItemRarity.COMMON;
};

const getRevealDuration = (rarity: ItemRarity): number => {
  const durations = {
    [ItemRarity.COMMON]: 2000,
    [ItemRarity.UNCOMMON]: 4000,
    [ItemRarity.RARE]: 8000,
    [ItemRarity.EPIC]: 15000,
    [ItemRarity.LEGENDARY]: 30000
  };
  
  return durations[rarity] || 2000;
};

// Generate loot hotspots for high-value areas
export const generateLootHotspots = (worldWidth: number, worldHeight: number): LootHotspot[] => {
  const hotspots: LootHotspot[] = [];
  const numHotspots = Math.floor((worldWidth * worldHeight) / 200); // One hotspot per ~200 tiles

  for (let i = 0; i < numHotspots; i++) {
    const center = {
      x: Math.floor(Math.random() * worldWidth),
      y: Math.floor(Math.random() * worldHeight)
    };

    const hotspot: LootHotspot = {
      center,
      radius: 3 + Math.floor(Math.random() * 4), // 3-6 tile radius
      bonusMultiplier: 2 + Math.random() * 2, // 2x to 4x spawn rate
      rarityBonus: 0.5 + Math.random() * 0.5 // 50% to 100% rarity boost
    };

    hotspots.push(hotspot);
  }

  return hotspots;
};

export type { LootHotspot };
</file>

<file path="packages/frontend/src/services/worldGeneration/NoiseGenerator.ts">
// Simple noise function for natural terrain generation
export const noise = (x: number, y: number, seed: number = 0) => {
  const n = Math.sin(x * 0.01 + seed) * Math.cos(y * 0.01 + seed) * 0.5 + 0.5;
  return n;
};

// Perlin-like noise for smoother transitions
export const perlinNoise = (x: number, y: number, octaves: number = 4) => {
  let value = 0;
  let amplitude = 1;
  let frequency = 0.05;

  for (let i = 0; i < octaves; i++) {
    value += noise(x * frequency, y * frequency, i) * amplitude;
    amplitude *= 0.5;
    frequency *= 2;
  }

  return value;
};
</file>

<file path="packages/frontend/src/services/worldGeneration/TerrainGenerator.ts">
import { perlinNoise } from './NoiseGenerator';
import { getBiome } from './BiomeGenerator';
import { WORLD_WIDTH, WORLD_HEIGHT } from './WorldTypes';
import type { GameWorld, Terrain } from 'shared';

export const generateTerrain = (x: number, y: number): Terrain => {
  const biome = getBiome(x, y);
  const elevation = perlinNoise(x * 0.8, y * 0.8, 1);
  const roughness = perlinNoise(x * 1.5, y * 1.5, 2);
  const moisture = perlinNoise(x * 0.6, y * 0.6, 3);

  let terrainType = 'plain';
  let movementCost = 1;
  let defenseBonus = 0;
  let visibilityModifier = 1;
  let resources: string[] = [];
  let specialFeatures: string[] = [];

  // Biome-specific terrain generation
  switch (biome) {
    case 'ocean':
      terrainType = 'water';
      movementCost = 999; // Impassable
      visibilityModifier = 0.9;
      break;

    case 'mountain_range':
      if (elevation > 0.8) {
        terrainType = 'mountain_peak';
        movementCost = 4;
        defenseBonus = 3;
        visibilityModifier = 1.2;
        resources = ['ore', 'gems'];
      } else if (elevation > 0.6) {
        terrainType = 'mountain';
        movementCost = 3;
        defenseBonus = 2;
        visibilityModifier = 1.1;
        resources = ['stone'];
      } else {
        terrainType = 'hills';
        movementCost = 1.5;
        defenseBonus = 1;
        resources = ['stone'];
      }
      break;

    case 'tundra':
      if (roughness > 0.7) {
        terrainType = 'ice';
        movementCost = 2;
        visibilityModifier = 0.9;
      } else if (elevation > 0.5) {
        terrainType = 'snowy_hills';
        movementCost = 1.8;
        defenseBonus = 1;
      } else {
        terrainType = 'snow';
        movementCost = 1.2;
        resources = ['fur'];
      }
      break;

    case 'desert':
      if (roughness > 0.8) {
        terrainType = 'dunes';
        movementCost = 2;
        visibilityModifier = 0.8;
        resources = ['sand'];
      } else if (perlinNoise(x * 2, y * 2, 5) > 0.85) {
        terrainType = 'oasis';
        movementCost = 0.8;
        visibilityModifier = 1.0;
        resources = ['water'];
        specialFeatures = ['healing'];
      } else {
        terrainType = 'sand';
        movementCost = 1.3;
        resources = ['sand'];
      }
      break;

    case 'jungle':
      if (roughness > 0.75) {
        terrainType = 'dense_jungle';
        movementCost = 2.5;
        defenseBonus = 2;
        visibilityModifier = 0.5;
        resources = ['exotic_wood', 'rare_herbs'];
      } else {
        terrainType = 'jungle';
        movementCost = 1.8;
        defenseBonus = 1;
        visibilityModifier = 0.7;
        resources = ['wood', 'herbs'];
      }
      break;

    case 'swamp':
      if (moisture > 0.8) {
        terrainType = 'deep_water';
        movementCost = 999;
        visibilityModifier = 0.8;
      } else if (roughness > 0.6) {
        terrainType = 'marsh';
        movementCost = 2;
        defenseBonus = 1;
        visibilityModifier = 0.8;
        resources = ['reeds'];
      } else {
        terrainType = 'swamp';
        movementCost = 1.5;
        resources = ['reeds', 'herbs'];
      }
      break;

    case 'temperate_forest':
      if (roughness > 0.7) {
        terrainType = 'dense_forest';
        movementCost = 2;
        defenseBonus = 2;
        visibilityModifier = 0.6;
        resources = ['wood', 'mushrooms'];
      } else if (perlinNoise(x * 1.5, y * 1.5, 6) > 0.8) {
        terrainType = 'clearing';
        movementCost = 0.9;
        visibilityModifier = 1.1;
        specialFeatures = ['camp'];
      } else {
        terrainType = 'forest';
        movementCost = 1.5;
        defenseBonus = 1;
        visibilityModifier = 0.8;
        resources = ['wood'];
      }
      break;

    case 'grassland':
      if (roughness > 0.65) {
        terrainType = 'rolling_hills';
        movementCost = 1.3;
        defenseBonus = 1;
        resources = ['grass'];
      } else if (perlinNoise(x * 2.5, y * 2.5, 7) > 0.9) {
        terrainType = 'flower_field';
        movementCost = 1.0;
        visibilityModifier = 1.0;
        resources = ['flowers', 'herbs'];
        specialFeatures = ['beautiful'];
      } else {
        terrainType = 'grassland';
        movementCost = 1.0;
        resources = ['grass', 'herbs'];
      }
      break;

    default: // plain
      if (roughness > 0.6) {
        terrainType = 'rough_terrain';
        movementCost = 1.2;
        resources = ['stones'];
      } else if (perlinNoise(x * 1.8, y * 1.8, 8) > 0.85) {
        terrainType = 'ancient_ruins';
        movementCost = 1.1;
        visibilityModifier = 1.0;
        resources = ['ancient_artifacts'];
        specialFeatures = ['mysterious'];
      } else {
        terrainType = 'plain';
        resources = ['grass'];
      }
  }

  // Add rivers with some probability
  const riverNoise = perlinNoise(x * 0.2, y * 0.2, 9);
  const riverBranch = perlinNoise(x * 0.15, y * 0.15, 10);

  if ((riverNoise > 0.75 && riverBranch > 0.6) || (riverNoise > 0.85)) {
    if (terrainType !== 'ocean' && terrainType !== 'water' && terrainType !== 'mountain_peak') {
      terrainType = 'river';
      movementCost = 2;
      visibilityModifier = 0.9;
      resources = ['water', 'fish'];
      specialFeatures = ['water_source'];
    }
  }

  // Add roads occasionally
  const roadNoise = perlinNoise(x * 0.1, y * 0.1, 11);
  if (roadNoise > 0.92 && movementCost < 3) {
    movementCost = Math.max(0.7, movementCost * 0.8);
    specialFeatures.push('road');
  }

  return {
    type: terrainType,
    position: { x, y },
    biome,
    elevation,
    roughness,
    moisture,
    movementCost,
    defenseBonus,
    visibilityModifier,
    resources,
    specialFeatures,
    // Additional gameplay properties
    fertility: moisture * (1 - roughness),
    strategicValue: defenseBonus + (resources.length * 0.5),
    explorationBonus: specialFeatures.length * 0.2,
  } as Terrain; // Type assertion
};
</file>

<file path="packages/frontend/src/services/worldGeneration/WorldGenerator.ts">
import { GameWorld, ItemType, ItemRarity } from '../../../../shared/src/types/game';
import { WORLD_WIDTH, WORLD_HEIGHT } from './WorldTypes';
import { generateTerrain } from './TerrainGenerator';
import { generateBuildings } from './BuildingGenerator';
import { generateTerrainLoot, generateLootHotspots } from './LootSpawnSystem';

export const createMockGameWorld = (): GameWorld => {
  const grid: any[][] = [];

  for (let y = 0; y < WORLD_HEIGHT; y++) {
    grid[y] = [];
    for (let x = 0; x < WORLD_WIDTH; x++) {
      grid[y][x] = generateTerrain(x, y);
    }
  }

  const { buildings, items: buildingItems } = generateBuildings(grid, WORLD_WIDTH, WORLD_HEIGHT);

  // Generate loot hotspots for enhanced loot areas
  const lootHotspots = generateLootHotspots(WORLD_WIDTH, WORLD_HEIGHT);
  
  // Generate terrain-based loot
  const terrainItems = generateTerrainLoot(grid, WORLD_WIDTH, WORLD_HEIGHT, lootHotspots);

  return {
    id: 'mock_world_1',
    grid,
    players: [{
      id: 'player1',
      twitchUsername: 'testuser',
      displayName: 'Test User',
      avatar: 'ðŸ¤ ',
      position: { x: 5, y: 5 },
      class: 'knight' as any,
      health: 100,
      mana: 50,
      stamina: 100,
      hunger: 100,
      thirst: 100,
      stats: { hp: 100, maxHp: 120, attack: 15, defense: 20, speed: 8 },
      level: 1,
      experience: 0,
      inventory: [],
      equipment: {},
      achievements: [],
      titles: [],
      isAlive: true,
      lastMoveTime: Date.now(),
      spawnTime: Date.now(),
      connected: true,
      lastActive: Date.now()
    }],
    npcs: [{
      id: 'goblin1',
      name: 'Goblin Scout',
      type: 'goblin',
      position: { x: 12, y: 8 },
      stats: { hp: 60, maxHp: 60, attack: 10, defense: 6, speed: 14 },
      behavior: 'wandering',
      lootTable: [],
      isAlive: true,
      lastMoveTime: Date.now()
    }],
    items: [{
      id: 'sword1',
      name: 'Iron Sword',
      type: ItemType.WEAPON,
      rarity: ItemRarity.UNCOMMON,
      description: 'A well-balanced iron sword',
      stats: { attack: 5 },
      position: { x: 8, y: 6 },
      isHidden: false,
      revealDuration: 0,
      revealProgress: 1.0,
      canBeLooted: true
    }, ...buildingItems, ...terrainItems], // Merge all loot sources
    buildings,
    cataclysmCircle: {
  center: { x: 20, y: 15 },
  radius: 40,
      isActive: false,
      shrinkRate: 1,
      nextShrinkTime: Date.now() + 300000
    },
    cataclysmRoughnessMultiplier: 1.0,
    worldAge: 0,
    lastResetTime: Date.now(),
    phase: 'exploration'
  };
};
</file>

<file path="packages/frontend/src/services/worldGeneration/WorldTypes.ts">
export const WORLD_WIDTH = 40;
export const WORLD_HEIGHT = 30;
</file>

<file path="packages/frontend/src/services/BiomeIdentificationService.ts">
import { Biome, BoundingBox, Position, BiomeType } from 'shared';

export class BiomeIdentificationService {
  public identifyBiomeRegions(grid: { type: BiomeType }[][]): Biome[] {
    if (!grid || grid.length === 0) {
      return [];
    }

    const visited = new Set<string>();
    const regions: Biome[] = [];
    const height = grid.length;
    const width = grid[0].length;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const key = `${x},${y}`;
        if (visited.has(key)) {
          continue;
        }

        const biomeType = grid[y][x].type;
        const cells = this.floodFill(grid, x, y, biomeType, visited);

        if (cells.length > 0) {
          regions.push({
            type: biomeType,
            cells: cells,
            bounds: this.calculateBoundingBox(cells),
          });
        }
      }
    }

    return regions;
  }

  private floodFill(
    grid: { type: BiomeType }[][],
    startX: number,
    startY: number,
    targetType: BiomeType,
    visited: Set<string>
  ): Position[] {
    const cells: Position[] = [];
    const queue: Position[] = [{ x: startX, y: startY }];
    const height = grid.length;
    const width = grid[0].length;

    const startKey = `${startX},${startY}`;
    if (visited.has(startKey)) {
      return [];
    }
    visited.add(startKey);

    while (queue.length > 0) {
      const { x, y } = queue.shift()!;
      cells.push({ x, y });

      const neighbors = [
        { x: x + 1, y },
        { x: x - 1, y },
        { x, y: y + 1 },
        { x, y: y - 1 },
      ];

      for (const neighbor of neighbors) {
        const { x: nx, y: ny } = neighbor;
        const key = `${nx},${ny}`;

        if (
          nx >= 0 &&
          nx < width &&
          ny >= 0 &&
          ny < height &&
          !visited.has(key) &&
          grid[ny][nx].type === targetType
        ) {
          visited.add(key);
          queue.push({ x: nx, y: ny });
        }
      }
    }

    return cells;
  }

  private calculateBoundingBox(cells: Position[]): BoundingBox {
    if (cells.length === 0) {
      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    }

    let minX = cells[0].x;
    let minY = cells[0].y;
    let maxX = cells[0].x;
    let maxY = cells[0].y;

    for (const cell of cells) {
      minX = Math.min(minX, cell.x);
      minY = Math.min(minY, cell.y);
      maxX = Math.max(maxX, cell.x);
      maxY = Math.max(maxY, cell.y);
    }

    return { minX, minY, maxX, maxY };
  }
}
</file>

<file path="packages/frontend/src/services/BiomeTextureService.ts">
import { RoughCanvas } from 'roughjs/bin/canvas';
import { Biome, Position } from 'shared';
import PoissonDiskSampling from 'poisson-disk-sampling';

// Define a new interface for texture configuration to avoid circular dependencies
interface TextureOverlayConfig {
  type: 'trees' | 'rocks' | 'crystals' | 'ruins' | 'corruption';
  density: number;
  size: number;
}

export class BiomeTextureService {
  public addTextureOverlay(
    biome: Biome,
    textureConfig: TextureOverlayConfig,
    roughCanvas: RoughCanvas,
    animationFrame: number
  ): void {
    const { minX, minY, maxX, maxY } = biome.bounds;
    const pds = new PoissonDiskSampling({
      shape: [maxX - minX, maxY - minY],
      minDistance: 1 / textureConfig.density,
      maxDistance: 2 / textureConfig.density,
      tries: 10
    });

    const points = pds.fill();

    points.forEach(point => {
      const worldPoint = { x: point[0] + minX, y: point[1] + minY };

      if (this.isPointInBiome(worldPoint, biome.cells)) {
        const animatedSize = this.animateTextureSize(
          textureConfig.size,
          animationFrame,
          worldPoint
        );

        switch (textureConfig.type) {
          case 'trees':
            this.drawRoughTree(roughCanvas, worldPoint, animatedSize);
            break;
          case 'rocks':
            this.drawRoughRock(roughCanvas, worldPoint, animatedSize);
            break;
          case 'crystals':
            this.drawRoughCrystal(roughCanvas, worldPoint, animatedSize);
            break;
          case 'ruins':
            this.drawRoughRuins(roughCanvas, worldPoint, animatedSize);
            break;
          case 'corruption':
            this.drawCorruptionEffect(roughCanvas, worldPoint, animatedSize);
            break;
        }
      }
    });
  }

  private isPointInBiome(point: Position, cells: Position[]): boolean {
    return cells.some(cell => cell.x === Math.floor(point.x) && cell.y === Math.floor(point.y));
  }

  private animateTextureSize(baseSize: number, animationFrame: number, point: Position): number {
    const animationSpeed = 0.05;
    const sizeVariation = 0.1;
    return baseSize * (1 + Math.sin(animationFrame * animationSpeed + point.x + point.y) * sizeVariation);
  }

  private drawRoughTree(rc: RoughCanvas, p: Position, s: number) {
    const trunkHeight = s * 1.5;
    const foliageRadius = s * 1.2;
    rc.line(p.x, p.y, p.x, p.y - trunkHeight, { stroke: '#8B4513', strokeWidth: s / 4 });
    rc.circle(p.x, p.y - trunkHeight, foliageRadius, {
      fill: '#228B22',
      fillStyle: 'hachure',
      hachureAngle: 60,
      hachureGap: s / 4,
      roughness: 1.5,
      stroke: 'darkgreen',
    });
  }

  private drawRoughRock(rc: RoughCanvas, p: Position, s: number) {
    const rockShape: [number, number][] = [
      [p.x - s * 0.8, p.y + s * 0.3],
      [p.x - s * 0.2, p.y - s * 0.7],
      [p.x + s * 0.7, p.y - s * 0.1],
      [p.x + s * 0.6, p.y + s * 0.6],
      [p.x - s * 0.5, p.y + s * 0.8]
    ];
    rc.polygon(rockShape, {
      fill: '#808080',
      fillStyle: 'solid',
      roughness: 2.5,
      stroke: '#696969',
      strokeWidth: 1.5,
    });
  }

  private drawRoughCrystal(rc: RoughCanvas, p: Position, s: number) {
    const crystalHeight = s * 1.8;
    const crystalBase = s * 0.8;
    const crystalShape: [number, number][] = [
      [p.x, p.y - crystalHeight],
      [p.x + crystalBase / 2, p.y],
      [p.x - crystalBase / 2, p.y]
    ];
    rc.polygon(crystalShape, {
      fill: 'rgba(0, 255, 255, 0.6)',
      fillStyle: 'solid',
      stroke: '#00FFFF',
      strokeWidth: 2,
      roughness: 1,
    });
  }

  private drawRoughRuins(rc: RoughCanvas, p: Position, s: number) {
    rc.rectangle(p.x - s / 2, p.y - s, s, s, {
      roughness: 2.8,
      fill: '#696969',
      fillStyle: 'cross-hatch',
      hachureGap: s / 3,
      hachureAngle: 45,
      stroke: 'black',
      strokeWidth: 2,
    });
    rc.rectangle(p.x, p.y - s/2, s/3, s/2, {
        roughness: 2,
        stroke: 'black',
        strokeWidth: 1,
    });
  }

  private drawCorruptionEffect(rc: RoughCanvas, p: Position, s: number) {
    rc.circle(p.x, p.y, s, {
      fill: '#9400D3',
      fillStyle: 'zigzag-line',
      hachureGap: s / 4,
      hachureAngle: Math.random() * 180,
      roughness: 3,
      stroke: '#4B0082',
      strokeWidth: 2,
    });
  }
}
</file>

<file path="packages/frontend/src/services/BiomeTransitionService.ts">
import { RoughCanvas } from 'roughjs/bin/canvas';
import { Biome, BIOME_RENDER_CONFIGS, BiomeRenderConfig, Position } from 'shared';

interface BiomeTransition {
  boundary: [number, number][][]; // Array of boundary paths
  config: Partial<BiomeRenderConfig>;
}

export class BiomeTransitionService {
  public renderBiomeTransitions(
    biomes: Biome[],
    rc: RoughCanvas,
    tileSize: number,
  ): void {
    const transitions = this.identifyBiomeTransitions(biomes, tileSize);

    transitions.forEach(transition => {
      this.renderTransitionZone(transition.boundary, transition.config, rc);
    });
  }

  private identifyBiomeTransitions(biomes: Biome[], tileSize: number): BiomeTransition[] {
    const transitions: BiomeTransition[] = [];
    const biomeGrid: (Biome | null)[][] = [];

    // Create a grid of biomes for easier lookup
    biomes.forEach(biome => {
      biome.cells.forEach(cell => {
        if (!biomeGrid[cell.y]) biomeGrid[cell.y] = [];
        biomeGrid[cell.y][cell.x] = biome;
      });
    });

    biomes.forEach(biomeA => {
      biomeA.cells.forEach(cell => {
        const neighbors = [
          {x: cell.x + 1, y: cell.y},
          {x: cell.x - 1, y: cell.y},
          {x: cell.x, y: cell.y + 1},
          {x: cell.x, y: cell.y - 1},
        ];

        neighbors.forEach(n => {
          const biomeB = biomeGrid[n.y]?.[n.x];
          if (biomeB && biomeB !== biomeA) {
            const boundary = this.getSharedBoundary(cell, n, tileSize);
            const blendedConfig = this.blendBiomeConfigs(
              BIOME_RENDER_CONFIGS[biomeA.type],
              BIOME_RENDER_CONFIGS[biomeB.type],
              0.5 // simple 50/50 blend
            );
            transitions.push({ boundary: [boundary], config: blendedConfig });
          }
        });
      });
    });

    return transitions;
  }

  private getSharedBoundary(cellA: Position, cellB: Position, tileSize: number): [number, number][] {
    const ax = cellA.x * tileSize;
    const ay = cellA.y * tileSize;

    if (cellA.x < cellB.x) { // B is to the right of A
      return [[ax + tileSize, ay], [ax + tileSize, ay + tileSize]];
    }
    if (cellA.x > cellB.x) { // B is to the left of A
      return [[ax, ay], [ax, ay + tileSize]];
    }
    if (cellA.y < cellB.y) { // B is below A
      return [[ax, ay + tileSize], [ax + tileSize, ay + tileSize]];
    }
    // B is above A
    return [[ax, ay], [ax + tileSize, ay]];
  }


  private blendBiomeConfigs(configA: BiomeRenderConfig, configB: BiomeRenderConfig, ratio: number): Partial<BiomeRenderConfig> {
    const lerp = (a: number, b: number, t: number) => a * (1 - t) + b * t;

    return {
      colors: {
        primary: this.lerpColor(configA.colors.primary, configB.colors.primary, ratio),
        secondary: this.lerpColor(configA.colors.secondary, configB.colors.secondary, ratio),
        border: this.lerpColor(configA.colors.border, configB.colors.border, ratio),
      },
      roughnessBase: lerp(configA.roughnessBase, configB.roughnessBase, ratio),
      strokeWidth: lerp(configA.strokeWidth, configB.strokeWidth, ratio),
    };
  }

  private lerpColor(a: string, b: string, amount: number): string {
    const ah = parseInt(a.replace(/#/g, ''), 16),
          ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,
          bh = parseInt(b.replace(/#/g, ''), 16),
          br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,
          rr = Math.round(ar + amount * (br - ar)),
          rg = Math.round(ag + amount * (bg - ag)),
          rb = Math.round(ab + amount * (bb - ab));

    return `rgba(${rr}, ${rg}, ${rb}, 0.5)`; // Use RGBA for smooth blending
  }

  private renderTransitionZone(boundaryPaths: [number, number][][], config: Partial<BiomeRenderConfig>, rc: RoughCanvas): void {
    boundaryPaths.forEach(path => {
        if (path.length < 2) return;
        rc.linearPath(path, {
            stroke: config.colors?.primary || 'transparent',
            strokeWidth: (config.strokeWidth || 1) * 10, // Make transition wider
            roughness: 0, // Smooth line for blending
        });
    });
  }
}
</file>

<file path="packages/frontend/src/services/CorruptionOverlayService.ts">
import { RoughCanvas } from 'roughjs/bin/canvas';
import { Biome, Position } from 'shared';
import PoissonDiskSampling from 'poisson-disk-sampling';

export class CorruptionOverlayService {
  public applyCorruptionEffects(
    biome: Biome,
    corruptionLevel: number,
    rc: RoughCanvas,
    animationFrame: number
  ): void {
    if (corruptionLevel < 0.1) return;

    const chaosMultiplier = Math.min(corruptionLevel * 5, 8);

    this.addCorruptionGrowths(biome, chaosMultiplier, corruptionLevel, rc, animationFrame);

    // The color shifting and overlay will be handled by the BiomeRenderer's
    // existing animation and configuration system, which can be influenced
    // by the cataclysm level in the game state. This service will focus on
    // additive effects like growths.
  }

  private addCorruptionGrowths(
    biome: Biome,
    chaosMultiplier: number,
    corruptionLevel: number,
    rc: RoughCanvas,
    animationFrame: number
  ): void {
    const { minX, minY, maxX, maxY } = biome.bounds;
    const pds = new PoissonDiskSampling({
      shape: [maxX - minX, maxY - minY],
      minDistance: 30 - chaosMultiplier * 2,
      maxDistance: 100 - chaosMultiplier * 5,
      tries: 10,
    });

    const points = pds.fill();

    points.forEach(point => {
      const worldPoint = { x: point[0] + minX, y: point[1] + minY };

      if (this.isPointInBiome(worldPoint, biome.cells)) {
        const size = (5 + Math.random() * 10) * corruptionLevel;
        const animatedSize = this.animateGrowthSize(size, animationFrame, worldPoint);
        this.drawCorruptionGrowth(rc, worldPoint, animatedSize, chaosMultiplier);
      }
    });
  }

  private isPointInBiome(point: Position, cells: Position[]): boolean {
    return cells.some(cell => cell.x === Math.floor(point.x) && cell.y === Math.floor(point.y));
  }

  private animateGrowthSize(baseSize: number, animationFrame: number, point: Position): number {
    const animationSpeed = 0.1;
    const sizeVariation = 0.2;
    return baseSize * (1 + Math.sin(animationFrame * animationSpeed + point.x) * sizeVariation);
  }

  private drawCorruptionGrowth(rc: RoughCanvas, p: Position, s: number, chaos: number) {
    rc.circle(p.x, p.y, s, {
      fill: `rgba(148, 0, 211, ${0.3 + chaos / 10})`,
      fillStyle: 'zigzag-line',
      hachureAngle: Math.random() * 180,
      hachureGap: (s / 4) * (1 / (chaos/4 + 1)),
      roughness: 2 + chaos,
      stroke: `rgba(75, 0, 130, ${0.5 + chaos/10})`,
      strokeWidth: 1 + chaos / 4,
    });
  }
}
</file>

<file path="packages/frontend/src/services/EmojiCharacterService.ts">
import rough from 'roughjs';
import { RoughCanvas } from 'roughjs/bin/canvas';
import { createNoise2D } from 'simplex-noise';
import { CharacterClass, CharacterVisual } from 'shared';

export class EmojiCharacterService {
  private canvas: HTMLCanvasElement;
  private roughCanvas: RoughCanvas;
  private animationFrames: Map<string, SVGElement[]> = new Map();
  private noise2D = createNoise2D();
  private roughGenerator = rough.generator();

  constructor() {
    this.canvas = document.createElement('canvas');
    this.canvas.width = 64;
    this.canvas.height = 64;
    this.roughCanvas = rough.canvas(this.canvas);
  }

  async createCharacterFromEmoji(emoji: string, characterClass: CharacterClass): Promise<CharacterVisual> {
    const baseSvg = await this.emojiToSvg(emoji);
    const classModifiedSvg = this.applyClassVisuals(baseSvg, characterClass);
    const animationFrames = this.generateRoughAnimationFrames(classModifiedSvg, characterClass);

    return {
      id: `char_${Date.now()}`,
      baseEmoji: emoji,
      baseSvg: classModifiedSvg,
      animationFrames: animationFrames.map(frame => frame.outerHTML),
      characterClass,
      animationSpeed: this.getClassAnimationSpeed(characterClass),
      roughnessVariation: this.getClassRoughnessVariation(characterClass)
    };
  }

  private async emojiToSvg(emoji: string): Promise<string> {
    const ctx = this.canvas.getContext('2d')!;
    ctx.clearRect(0, 0, 64, 64);
    ctx.font = '48px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, 32, 32);
    const imageData = ctx.getImageData(0, 0, 64, 64);
    return this.traceToSvgPath(imageData);
  }

  private traceToSvgPath(imageData: ImageData): string {
    const paths: string[] = [];
    const { data, width, height } = imageData;
    const visited = new Set<string>();

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const alpha = data[(y * width + x) * 4 + 3];
        if (alpha > 128 && !visited.has(`${x},${y}`)) {
          const path = this.traceContour(data, width, height, x, y, visited);
          if (path.length > 10) {
            paths.push(path);
          }
        }
      }
    }

    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">`;
    paths.forEach((path, index) => {
      const color = this.getPathColor(index);
      svg += `<path d="${path}" fill="${color}" stroke="none"/>`;
    });
    svg += `</svg>`;
    return svg;
  }

  private generateRoughAnimationFrames(baseSvg: string, characterClass: CharacterClass): SVGElement[] {
    const frames: SVGElement[] = [];
    const frameCount = 8;
    const baseRoughness = this.getClassBaseRoughness(characterClass);

    for (let frame = 0; frame < frameCount; frame++) {
      const frameElement = this.createRoughFrame(
        baseSvg,
        baseRoughness,
        frame,
        characterClass
      );
      frames.push(frameElement);
    }
    return frames;
  }

  private createRoughFrame(baseSvg: string, baseRoughness: number, frameIndex: number, characterClass: CharacterClass): SVGElement {
    const timeOffset = frameIndex * 0.1;
    const roughnessNoise = this.noise2D(timeOffset, 0) * 0.3;
    const bowingNoise = this.noise2D(0, timeOffset) * 0.2;

    const organicRoughness = baseRoughness + roughnessNoise;
    const organicBowing = 1 + bowingNoise;

    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(baseSvg, 'image/svg+xml');
    const svgElement = svgDoc.documentElement.cloneNode(true) as SVGElement;
    const paths = svgElement.querySelectorAll('path');

    paths.forEach((path, index) => {
      const roughPathData = this.pathToRoughPath(path.getAttribute('d') || '', {
        roughness: organicRoughness,
        bowing: organicBowing,
        strokeWidth: this.getClassStrokeWidth(characterClass),
        stroke: this.getClassStrokeColor(characterClass, frameIndex),
        fill: this.getClassFillColor(characterClass, frameIndex, index),
        fillStyle: this.getClassFillStyle(characterClass)
      });
      path.setAttribute('d', roughPathData);
      path.setAttribute('stroke', this.getClassStrokeColor(characterClass, frameIndex));
      path.setAttribute('fill', this.getClassFillColor(characterClass, frameIndex, index));
      path.setAttribute('stroke-width', this.getClassStrokeWidth(characterClass).toString());
    });

    this.addClassEffects(svgElement, characterClass, frameIndex);
    return svgElement;
  }

  private addClassEffects(svgElement: SVGElement, characterClass: CharacterClass, frameIndex: number): void {
    switch (characterClass.id) {
      case 'quantum-drifter': this.addQuantumShimmer(svgElement, frameIndex); break;
      // Add other class effects here...
    }
  }

  private addQuantumShimmer(svgElement: SVGElement, frameIndex: number): void {
    const shimmerIntensity = Math.sin((frameIndex / 8) * Math.PI * 2) * 0.3 + 0.7;
    const filter = `
      <defs>
        <filter id="quantum-shimmer-${frameIndex}">
          <feGaussianBlur stdDeviation="${shimmerIntensity}" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
    `;
    svgElement.insertAdjacentHTML('afterbegin', filter);
    svgElement.setAttribute('filter', `url(#quantum-shimmer-${frameIndex})`);
  }

  private applyClassVisuals(baseSvg: string, characterClass: CharacterClass): string {
    return baseSvg
      .replace(/fill="[^"]*"/g, `fill="${characterClass.primaryColor}"`)
      .replace(/stroke="[^"]*"/g, `stroke="${characterClass.secondaryColor}"`);
  }

  private getClassBaseRoughness(characterClass: CharacterClass): number {
    return characterClass.roughnessBase;
  }

  private getClassAnimationSpeed(characterClass: CharacterClass): number {
    return characterClass.animationSpeed;
  }

  private getClassRoughnessVariation(characterClass: CharacterClass): number {
    switch (characterClass.id) {
      case 'quantum-drifter': return 0.8;
      case 'void-walker': return 1.2;
      case 'bio-hacker': return 1.0;
      default: return 0.9;
    }
  }

  private getClassStrokeWidth(characterClass: CharacterClass): number {
    return characterClass.roughnessBase * 0.8;
  }

  private getClassStrokeColor(characterClass: CharacterClass, frameIndex: number): string {
    const opacity = 0.7 + Math.sin((frameIndex / 8) * Math.PI * 2) * 0.3;
    return `${characterClass.secondaryColor}${Math.floor(opacity * 255).toString(16)}`;
  }

  private getClassFillColor(characterClass: CharacterClass, frameIndex: number, pathIndex: number): string {
    return characterClass.primaryColor;
  }

  private getClassFillStyle(characterClass: CharacterClass): string {
    switch (characterClass.id) {
      case 'tech-shaman': return 'zigzag-line';
      case 'bio-hacker': return 'dots';
      case 'void-walker': return 'cross-hatch';
      default: return 'solid';
    }
  }

  private traceContour(data: Uint8ClampedArray, width: number, height: number, startX: number, startY: number, visited: Set<string>): string {
    const path = [`M ${startX} ${startY}`];
    let x = startX, y = startY;
    const directions = [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
    let dir = 0;

    for (let i = 0; i < 2000; i++) { // Limit steps to prevent infinite loops
      visited.add(`${x},${y}`);
      let foundNext = false;
      for (let j = 0; j < 8; j++) {
        const checkDir = (dir + j + 5) % 8; // Start searching from a different direction
        const [dx, dy] = directions[checkDir];
        const newX = x + dx;
        const newY = y + dy;

        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
          const alpha = data[(newY * width + newX) * 4 + 3];
          if (alpha > 128) {
            if (!visited.has(`${newX},${newY}`)) {
              path.push(`L ${newX} ${newY}`);
              x = newX;
              y = newY;
              dir = checkDir;
              foundNext = true;
              break;
            }
          }
        }
      }
      if (!foundNext || (x === startX && y === startY)) {
        break;
      }
    }
    path.push('Z');
    return path.join(' ');
  }

  private getPathColor(pathIndex: number): string {
    const colors = ['#333333', '#666666', '#999999', '#CCCCCC'];
    return colors[pathIndex % colors.length];
  }

  private pathToRoughPath(pathData: string, options: any): string {
    try {
      const drawable = this.roughGenerator.path(pathData, {
        ...options,
        curveStepCount: 9,
        curveTightness: 0,
        disableMultiStroke: false,
        disableMultiStrokeFill: false,
      });
      return this.drawableToPath(drawable);
    } catch (error) {
      console.warn('Failed to roughen path:', error);
      return pathData;
    }
  }

  private drawableToPath(drawable: any): string {
    let pathString = '';
    if (drawable && drawable.sets) {
      drawable.sets.forEach((set: any) => {
        if (set.ops) {
          set.ops.forEach((op: any) => {
            switch (op.op) {
              case 'move': pathString += `M${op.data[0]},${op.data[1]} `; break;
              case 'bcurveTo': pathString += `C${op.data[0]},${op.data[1]} ${op.data[2]},${op.data[3]} ${op.data[4]},${op.data[5]} `; break;
              case 'lineTo': pathString += `L${op.data[0]},${op.data[1]} `; break;
              case 'closePath': pathString += 'Z '; break;
            }
          });
        }
      });
    }
    return pathString.trim();
  }
}
</file>

<file path="packages/frontend/src/services/soundService.ts">
// @ts-ignore - Tone.js will be loaded via CDN script tag in index.html
declare const Tone: any;

import { useGameStore } from '../stores/gameStore';

/**
 * Simple and pleasant sound service using Tone.js for game audio
 */
export class SoundService {
  private static instance: SoundService;

  // Audio state
  private isInitialized = false;
  private enabled = true;
  private masterVolume = 0.4; // Pleasant default volume
  private sfxVolume = 0.5;
  private musicVolume = 0.3;

  // Sound generators with pleasant profiles
  private clickSynth: any = null;
  private moveSynth: any = null;
  private successSynth: any = null;
  private errorSynth: any = null;
  private pickupSynth: any = null;
  private notificationSynth: any = null;
  private ambientSynth: any = null;

  // Audio context
  private masterMeter: any = null;

  // Ambient interval id so we can clear it on dispose
  private ambientIntervalId: number | null = null;

  constructor() {
    // Do NOT initialize Tone nodes here (must be created after user gesture / Tone.start()).
    // Constructor intentionally lightweight to avoid creating AudioNodes before user gesture.
  }

  /**
   * Create synths and connect them to master. Idempotent.
   */
  private initializeSynths(): void {
    if (typeof Tone === 'undefined') {
      console.warn('âš ï¸ Tone.js not loaded - sounds will be disabled');
      return;
    }

    // If synths already created, don't recreate
    if (this.clickSynth) return;

    try {
      // Initialize synths with pleasant, musical settings
      this.clickSynth = new Tone.Synth({
        oscillator: { type: 'triangle' },
        envelope: {
          attack: 0.01,
          decay: 0.1,
          sustain: 0.2,
          release: 0.3
        }
      });

      this.moveSynth = new Tone.MonoSynth({
        oscillator: { type: 'sine' },
        filter: { Q: 2, frequency: 300 },
        envelope: {
          attack: 0.02,
          decay: 0.3,
          sustain: 0.1,
          release: 0.4
        },
        filterEnvelope: {
          attack: 0.02,
          decay: 0.3,
          sustain: 0.2,
          release: 0.3,
          baseFrequency: 200,
          octaves: 3
        }
      });

      this.successSynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'sawtooth' },
        envelope: {
          attack: 0.02,
          decay: 0.2,
          sustain: 0.3,
          release: 0.8
        }
      });

      this.errorSynth = new Tone.AMSynth({
        harmonicity: 2,
        oscillator: { type: 'sawtooth' },
        envelope: {
          attack: 0.01,
          decay: 0.2,
          sustain: 0.2,
          release: 0.3
        },
        modulation: { type: 'square' },
        modulationEnvelope: {
          attack: 0.5,
          decay: 0.01,
          sustain: 0.1,
          release: 0.3
        }
      });

      this.pickupSynth = new Tone.FMSynth({
        harmonicity: 1.5,
        modulationIndex: 2,
        envelope: {
          attack: 0.01,
          decay: 0.2,
          sustain: 0.2,
          release: 0.4
        },
        modulationEnvelope: {
          attack: 0.01,
          decay: 0.2,
          sustain: 0.1,
          release: 0.4
        }
      });

      this.notificationSynth = new Tone.Synth({
        oscillator: { type: 'triangle' },
        envelope: {
          attack: 0.05,
          decay: 0.2,
          sustain: 0.4,
          release: 0.8
        }
      });

      this.ambientSynth = new Tone.PluckSynth({
        attackNoise: 1,
        dampening: 4000,
        resonance: 0.7
      });

      // Volume meter for monitoring
      this.masterMeter = new Tone.Meter();

      // Connect all synths to master output via meter
      this.connectToMaster();
    } catch (err) {
      console.error('âŒ Error initializing synths:', err);
      // If synth creation fails, ensure we don't leave partially-initialized nodes
      try {
        this.dispose();
      } catch (e) {
        // swallow
      }
    }
  }

  private connectToMaster(): void {
    if (typeof Tone === 'undefined') return;

    try {
      const masterGain = new Tone.Gain(this.masterVolume);
      const compressor = new Tone.Compressor({
        ratio: 3,
        threshold: -24,
        release: 0.25,
        attack: 0.003,
        knee: 30
      });

      // Connect all synths to master chain
      [this.clickSynth, this.moveSynth, this.successSynth, this.errorSynth,
        this.pickupSynth, this.notificationSynth, this.ambientSynth].forEach(synth => {
        if (synth && typeof synth.connect === 'function') {
          try { synth.connect(masterGain); } catch (e) { /* ignore */ }
        }
      });

      // Connect to destination with compression
      try { masterGain.connect(compressor); } catch (e) { /* ignore */ }
      try { compressor.connect(this.masterMeter); } catch (e) { /* ignore */ }
      // Some Tone builds allow Meter.connect(Destination) or meter.toDestination()
      try {
        if (this.masterMeter && typeof this.masterMeter.connect === 'function') {
          this.masterMeter.connect(Tone.Destination);
        } else if (typeof (Tone.Destination as any)?.volume !== 'undefined') {
          // fallback no-op
        }
      } catch (e) {
        // ignore
      }
    } catch (err) {
      console.error('âŒ Error connecting to master:', err);
    }
  }

  /**
   * Initialize audio system â€” must be called from a user gesture (button click).
   * This calls Tone.start() and then creates synths and connections.
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      if (typeof Tone !== 'undefined') {
        await Tone.start();
        // Only after Tone.start resolves do we create AudioNodes
        this.initializeSynths();
        this.isInitialized = true;
        console.log('ðŸŽµ SoundService initialized');
      } else {
        console.warn('âš ï¸ Tone.js not loaded - sounds disabled');
        this.enabled = false;
      }
    } catch (error) {
      console.error('âŒ Failed to initialize sound:', error);
      this.enabled = false;
    }
  }

  /**
   * Update volume settings from game store
   */
  updateSettings(): void {
    const settings = useGameStore.getState().unifiedSettings?.audio;
    if (!settings) return;

    this.masterVolume = (settings.audioMasterVolume ?? 80) / 100;
    this.sfxVolume = (settings.sfxVolume ?? 70) / 100;
    this.musicVolume = (settings.musicVolume ?? 60) / 100;
    this.enabled = (settings.soundEnabled ?? true);

    // If master gain exists in chain, try to set volume - best effort only
    try {
      // Tone APIs vary; this is a soft attempt so we don't crash if chain missing
      // (We intentionally don't store masterGain on the instance to avoid complex lifecycle coupling)
    } catch (e) {
      // ignore
    }
  }

  // ðŸŽµ SIMPLE BUT PLEASANT SOUND EFFECTS

  /**
   * Pleasant button/menu click sound
   */
  playClick(): void {
    if (!this.enabled || !this.isInitialized) return;

    if (!this.clickSynth || typeof this.clickSynth.triggerAttackRelease !== 'function') return;

    // Gentle ascending triangle wave
    this.clickSynth.triggerAttackRelease('C4', '16n');

    // Create a pleasant modulation after
    setTimeout(() => {
      try { this.clickSynth.triggerAttackRelease('E4', '32n'); } catch (e) { /* ignore */ }
    }, 60);
  }

  /**
   * Smooth player movement sound
   */
  playMove(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.moveSynth || typeof this.moveSynth.triggerAttackRelease !== 'function') return;

    // Gentle sine wave glide
    this.moveSynth.triggerAttackRelease('A3', '8n');
  }

  /**
   * Pleasant item pickup sound
   */
  playPickup(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.pickupSynth || typeof this.pickupSynth.triggerAttackRelease !== 'function') return;

    // Bright FM synthesis "bling"
    this.pickupSynth.triggerAttackRelease('C5', '16n');

    // Add harmonic
    setTimeout(() => {
      try { this.pickupSynth.triggerAttackRelease('G5', '16n'); } catch (e) { /* ignore */ }
    }, 40);
  }

  /**
   * Successful action completion
   */
  playSuccess(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.successSynth || typeof this.successSynth.triggerAttackRelease !== 'function') return;

    // Pleasant chord progression
    const notes = ['C4', 'E4', 'G4'];

    this.successSynth.triggerAttackRelease(notes, '8n');

    // Add a secondary chord
    setTimeout(() => {
      try {
        const highNotes = ['G5', 'B5', 'D6'];
        this.successSynth.triggerAttackRelease(highNotes, '4n');
      } catch (e) { /* ignore */ }
    }, 150);
  }

  /**
   * Level up or achievement sound
   */
  playLevelUp(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.successSynth || typeof this.successSynth.triggerAttackRelease !== 'function') return;

    // Majestic rising sequence
    const sequence = ['G3', 'C4', 'E4', 'G4', 'C5'];

    sequence.forEach((note, index) => {
      setTimeout(() => {
        try { this.successSynth.triggerAttackRelease(note, '16n'); } catch (e) { /* ignore */ }
      }, index * 80);
    });
  }

  /**
   * Player attack action
   */
  playAttack(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.errorSynth || typeof this.errorSynth.triggerAttackRelease !== 'function') return;

    // Aggressive but pleasant attack sound
    this.errorSynth.triggerAttackRelease('D3', '8n');
  }

  /**
   * Player damage taken
   */
  playDamage(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.errorSynth || typeof this.errorSynth.triggerAttackRelease !== 'function') return;

    // Tense but pleasant hurt sound
    this.errorSynth.triggerAttackRelease('F2', '8n');
  }

  /**
   * Error or invalid action
   */
  playError(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.errorSynth || typeof this.errorSynth.triggerAttackRelease !== 'function') return;

    // Gentle error sound - not harsh
    this.errorSynth.triggerAttackRelease('D2', '4n');
  }

  /**
   * Menu navigation
   */
  playNavigation(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.notificationSynth || typeof this.notificationSynth.triggerAttackRelease !== 'function') return;

    // Smooth navigation blip
    this.notificationSynth.triggerAttackRelease('A4', '32n');
  }

  /**
   * Ambient background melody (if enabled)
   *
   * Creates a single interval that is tracked and cleared on dispose.
   */
  playAmbient(): void {
    if (!this.enabled || !this.isInitialized || this.musicVolume < 0.1) return;
    if (!this.ambientSynth || typeof this.ambientSynth.triggerAttack !== 'function') return;

    // If an ambient interval already exists, don't create another
    if (this.ambientIntervalId !== null) return;

    // Gentle ambient pluck
    const notes = ['C4', 'F4', 'A4', 'D5'];

    this.ambientIntervalId = window.setInterval(() => {
      if (!this.enabled) return;
      const randomNote = notes[Math.floor(Math.random() * notes.length)];
      try {
        this.ambientSynth.triggerAttack(randomNote, '+0', this.musicVolume);
      } catch (e) {
        // ignore
      }
    }, 4000); // Every 4 seconds
  }

  /**
   * New notification
   */
  playNotification(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.notificationSynth || typeof this.notificationSynth.triggerAttackRelease !== 'function') return;

    // Pleasant notification ping
    this.notificationSynth.triggerAttackRelease('E5', '8n');
  }

  /**
   * Healing or positive effect
   */
  playHeal(): void {
    if (!this.enabled || !this.isInitialized) return;
    if (!this.pickupSynth || typeof this.pickupSynth.triggerAttackRelease !== 'function') return;

    // Soothing healing sound
    const notes = ['C4', 'F4', 'A4'];
    this.pickupSynth.triggerAttackRelease(notes, '4n');
  }

  /**
   * Get current audio levels for debugging
   */
  getLevels(): { master: number; enabled: boolean } {
    try {
      const masterValue = this.masterMeter && typeof this.masterMeter.getValue === 'function'
        ? (this.masterMeter.getValue() as number)
        : 0;
      return {
        master: masterValue,
        enabled: this.enabled
      };
    } catch (e) {
      return { master: 0, enabled: this.enabled };
    }
  }

  // Singleton pattern
  public static getInstance(): SoundService {
    if (!SoundService.instance) {
      SoundService.instance = new SoundService();
    }
    return SoundService.instance;
  }

  // Cleanup
  dispose(): void {
    // Clear ambient interval
    if (this.ambientIntervalId !== null) {
      try { clearInterval(this.ambientIntervalId); } catch (e) { /* ignore */ }
      this.ambientIntervalId = null;
    }

    // Dispose of all synths and meter defensively
    try {
      if (this.clickSynth && typeof this.clickSynth.dispose === 'function') {
        try { this.clickSynth.dispose(); } catch (e) { /* ignore */ }
      }
      if (this.moveSynth && typeof this.moveSynth.dispose === 'function') {
        try { this.moveSynth.dispose(); } catch (e) { /* ignore */ }
      }
      if (this.successSynth && typeof this.successSynth.dispose === 'function') {
        try { this.successSynth.dispose(); } catch (e) { /* ignore */ }
      }
      if (this.errorSynth && typeof this.errorSynth.dispose === 'function') {
        try { this.errorSynth.dispose(); } catch (e) { /* ignore */ }
      }
      if (this.pickupSynth && typeof this.pickupSynth.dispose === 'function') {
        try { this.pickupSynth.dispose(); } catch (e) { /* ignore */ }
      }
      if (this.notificationSynth && typeof this.notificationSynth.dispose === 'function') {
        try { this.notificationSynth.dispose(); } catch (e) { /* ignore */ }
      }
      if (this.ambientSynth && typeof this.ambientSynth.dispose === 'function') {
        try { this.ambientSynth.dispose(); } catch (e) { /* ignore */ }
      }
      if (this.masterMeter && typeof this.masterMeter.dispose === 'function') {
        try { this.masterMeter.dispose(); } catch (e) { /* ignore */ }
      }
    } finally {
      // Null out references
      this.clickSynth = null;
      this.moveSynth = null;
      this.successSynth = null;
      this.errorSynth = null;
      this.pickupSynth = null;
      this.notificationSynth = null;
      this.ambientSynth = null;
      this.masterMeter = null;
      this.isInitialized = false;
    }
  }
}

// Export singleton instance
export const soundService = SoundService.getInstance();

// Convenience functions for easy access
export const initializeSounds = () => soundService.initialize();
export const playClick = () => soundService.playClick();
export const playMove = () => soundService.playMove();
export const playPickup = () => soundService.playPickup();
export const playSuccess = () => soundService.playSuccess();
export const playLevelUp = () => soundService.playLevelUp();
export const playAttack = () => soundService.playAttack();
export const playDamage = () => soundService.playDamage();
export const playError = () => soundService.playError();
export const playNavigation = () => soundService.playNavigation();
export const playAmbient = () => soundService.playAmbient();
export const playNotification = () => soundService.playNotification();
export const playHeal = () => soundService.playHeal();
</file>

<file path="packages/frontend/src/services/UnifiedRoughFillService.ts">
import { RoughCanvas } from 'roughjs/bin/canvas';
import { createNoise2D } from 'simplex-noise';
import { Biome, BIOME_RENDER_CONFIGS, BiomeRenderConfig } from 'shared';
import { BoundaryTracer } from '../utils/boundaryTracing';

export class UnifiedRoughFillService {
  private roughCanvas: RoughCanvas;
  private noiseGenerator = createNoise2D();
  private boundaryTracer: BoundaryTracer;

  constructor(roughCanvas: RoughCanvas) {
    this.roughCanvas = roughCanvas;
    this.boundaryTracer = new BoundaryTracer();
  }

  public applyUnifiedBiomeFill(
    biome: Biome,
    tileSize: number,
    animationFrame: number = 0
  ): void {
    const boundary = this.boundaryTracer.march(biome.cells, tileSize);
    if (boundary.length < 3) {
      return; // Not a valid polygon to draw
    }

    const config = BIOME_RENDER_CONFIGS[biome.type];

    const biomeId = biome.cells.length > 0 ? `${biome.cells[0].x},${biome.cells[0].y}` : '0';
    const animatedConfig = this.animateBiomeConfig(config, animationFrame, biomeId);

    // Convert boundary points to the format roughjs expects if necessary
    const polygon = boundary.map(p => [p[0], p[1]]) as [number, number][];

    this.roughCanvas.polygon(polygon, {
      fill: animatedConfig.colors.primary,
      fillStyle: animatedConfig.fillPattern,
      roughness: animatedConfig.roughnessBase,
      bowing: animatedConfig.bowingBase,
      stroke: animatedConfig.colors.border,
      strokeWidth: animatedConfig.strokeWidth,
      hachureAngle: animatedConfig.hachureAngle,
      hachureGap: animatedConfig.hachureGap
    });

    // Texture overlay logic will be called from BiomeRenderer after this
  }

  private animateBiomeConfig(config: BiomeRenderConfig, animationFrame: number, biomeId: string): BiomeRenderConfig {
    if (!config.animationProperties) {
      return config;
    }

    const animatedConfig = JSON.parse(JSON.stringify(config)); // Deep copy to avoid side effects
    const { breathingIntensity, colorPulse, roughnessVariation } = config.animationProperties;

    // Use a hash of the biomeId to seed the noise, making it deterministic per biome
    const biomeSeed = this.hashString(biomeId);
    const time = (animationFrame / 100);

    if (roughnessVariation) {
      const roughnessNoise = this.noiseGenerator(biomeSeed, time);
      animatedConfig.roughnessBase += roughnessNoise * roughnessVariation;
    }

    if (breathingIntensity) {
        const breathingNoise = Math.sin(time + biomeSeed);
        animatedConfig.bowingBase += breathingNoise * breathingIntensity;
    }

    if (colorPulse) {
        const pulse = (Math.sin(time * 2 + biomeSeed) + 1) / 2; // 0 to 1
        const primaryColor = this.lerpColor(config.colors.primary, config.colors.secondary, pulse * colorPulse);
        animatedConfig.colors.primary = primaryColor;
    }

    return animatedConfig;
  }

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0; // Convert to 32bit integer
    }
    return hash / 2147483647; // Normalize to ~ -1 to 1
  }

  private lerpColor(a: string, b: string, amount: number): string {
    const ah = parseInt(a.replace(/#/g, ''), 16),
          ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,
          bh = parseInt(b.replace(/#/g, ''), 16),
          br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,
          rr = Math.round(ar + amount * (br - ar)),
          rg = Math.round(ag + amount * (bg - ag)),
          rb = Math.round(ab + amount * (bb - ab));

    return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1);
  }
}
</file>

<file path="packages/frontend/src/types/notification.ts">
export type NotificationType = 
  | 'success'    // Level ups, achievements, successful actions
  | 'error'      // Failed actions, system errors
  | 'warning'    // Low health, resource warnings
  | 'info'       // General information, tips
  | 'combat'     // Combat results, damage dealt/taken
  | 'loot'       // Item pickups, treasure found
  | 'social'     // Player interactions, chat mentions
  | 'system';    // System messages, connection status

export interface NotificationData {
  id: string;
  type: NotificationType;
  title: string;
  message: string;
  duration?: number; // Duration in milliseconds (default: 4000)
  icon?: string;     // Optional custom icon
  persistent?: boolean; // If true, won't auto-dismiss
  actions?: NotificationAction[];
}

export interface NotificationAction {
  label: string;
  action: () => void;
  style?: 'primary' | 'secondary';
}
</file>

<file path="packages/frontend/src/types/playerStatus.ts">
import { Player, Buff } from 'shared';

export interface PlayerStats {
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;
  stamina: number;
  maxStamina: number;
  experience: number;
  level: number;
  hunger: number;
  thirst: number;
}

export interface PlayerEffect {
  type: Buff;
  duration: number;
  strength: number;
  description?: string;
}

export interface EnhancedPlayerStatusProps {
  player: Player;
}

export interface PlayerStatusComponentProps {
  stats: PlayerStats;
  effects: PlayerEffect[];
  player: Player;
}

export interface HealthBarProps {
  currentHealth: number;
  maxHealth: number;
}

export interface ExperienceBarProps {
  currentExperience: number;
  level: number;
}
</file>

<file path="packages/frontend/src/utils/chat/ChatUtils.ts">
export const getCurrentTimestamp = (): number => {
  return Date.now();
};

export const capitalizeFirstLetter = (str: string): string => {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
};
</file>

<file path="packages/frontend/src/utils/chat/MessageUtils.ts">
import { ChatMessage } from '../../types/chat';

export const formatMessage = (message: ChatMessage): string => {
  const sender = message.isResponse ? 'Bot' : message.displayName || message.username;
  const time = new Date(message.timestamp).toLocaleTimeString();
  return `[${time}] ${sender}: ${message.message}`;
};

export const getMessageDisplayClass = (message: ChatMessage): string => {
  return message.isResponse ? 'bot-message' : 'user-message';
};
</file>

<file path="packages/frontend/src/utils/materialTheme/index.ts">
export { createMaterialTheme, elevations } from './materialTheme';
</file>

<file path="packages/frontend/src/utils/materialTheme/materialTheme.ts">
import { createTheme, Theme } from '@mui/material/styles';
import { alpha } from '@mui/material/styles';

// Import centralized color tokens
import { COLORS } from '../tokens';

// Material Design 3 color palette based on the app's dark aesthetic
export const createMaterialTheme = (): Theme => {
  return createTheme({
    palette: {
      mode: 'dark',
      primary: {
        main: COLORS.primaryBlue || COLORS.primary || '#31748f',
        light: '#5ba3c7',
        dark: COLORS['primary-container'] || '#1e5a6b',
        contrastText: COLORS['on-primary'] || '#1f1d2e',
      },
      secondary: {
        main: COLORS.secondaryBlue || COLORS.secondary || '#9ccfd8',
        light: '#c4e4f7',
        dark: COLORS['secondary-container'] || '#6b9aa5',
        contrastText: COLORS['on-secondary'] || '#191724',
      },
      error: {
        main: COLORS.error || '#dc2626', // healthDying
        light: '#ffb2b8',
        dark: '#dd4b60',
        contrastText: '#ffffff',
      },
      warning: {
        main: (COLORS.health && COLORS.health.wounded) || COLORS['healthFillWoundedStart'] || '#fbbf24', // healthWounded
        light: '#fff0c2',
        dark: '#e6a94e',
        contrastText: COLORS['on-background'] || '#191724',
      },
      info: {
        main: COLORS.primaryBlue || COLORS.primary || '#31748f', // same as primary
        light: '#6dc8ff',
        dark: '#005d62',
        contrastText: '#ffffff',
      },
      success: {
        main: (COLORS.health && COLORS.health.healthy) || COLORS['healthFillHealthyStart'] || '#a3e635', // healthHealthy
        light: '#88d96b',
        dark: '#005f00',
        contrastText: COLORS['on-background'] || '#191724',
      },
      background: {
        default: COLORS.backgroundDark || COLORS.background || '#191724', // backgroundDark
        paper: alpha(COLORS.backgroundMedium || '#1f1d2e', 0.95), // backgroundMedium
      },
      text: {
        primary: COLORS.text && COLORS.text.primary || COLORS.textLight || '#e0def4', // textLight
        secondary: COLORS.text && COLORS.text.secondary || COLORS.textDark || '#908caa', // textDark
        disabled: alpha((COLORS.text && COLORS.text.secondary) || COLORS.textDark || '#908caa', 0.5),
      },
      divider: alpha(COLORS.borderGray || '#6e6a86', 0.15), // borderGray
    },
    typography: {
      fontFamily: [
        'Inter',
        '-apple-system',
        'BlinkMacSystemFont',
        '"Segoe UI"',
        'Roboto',
        '"Helvetica Neue"',
        'Arial',
        'sans-serif',
      ].join(','),
      h1: {
        fontFamily: '"Roboto Flex", "Times New Roman", Times, serif',
        fontWeight: 800,
        fontSize: '3rem', // Display Large
        lineHeight: 1.1,
        letterSpacing: '-0.015em',
        textAlign: 'center',
      },
      h2: {
        fontFamily: '"Roboto Flex", "Times New Roman", Times, serif',
        fontWeight: 700,
        fontSize: '2.5rem', // Display Medium
        lineHeight: 1.2,
        letterSpacing: '-0.01em',
        textAlign: 'center',
      },
      h3: {
        fontFamily: '"Roboto Flex", "Times New Roman", Times, serif',
        fontWeight: 700,
        fontSize: '2rem', // Display Small
        lineHeight: 1.25,
        letterSpacing: '0em',
        textAlign: 'center',
      },
      h4: {
        fontFamily: '"Roboto Flex", "Times New Roman", Times, serif',
        fontWeight: 600,
        fontSize: '1.75rem', // Headline Large
        lineHeight: 1.3,
        letterSpacing: '0.005em',
        textAlign: 'center',
      },
      h5: {
        fontFamily: '"Roboto Flex", "Times New Roman", Times, serif',
        fontWeight: 600,
        fontSize: '1.5rem', // Headline Medium
        lineHeight: 1.35,
        letterSpacing: '0.01em',
        textAlign: 'center',
      },
      h6: {
        fontFamily: '"Roboto Flex", "Times New Roman", Times, serif',
        fontWeight: 600,
        fontSize: '1.25rem', // Headline Small
        lineHeight: 1.4,
        letterSpacing: '0.015em',
        textAlign: 'center',
      },
      body1: {
        fontFamily: 'Inter',
        fontSize: '1rem',
        lineHeight: 1.6,
        letterSpacing: '0.00938em',
      },
      body2: {
        fontFamily: 'Inter',
        fontSize: '0.875rem',
        lineHeight: 1.6,
        letterSpacing: '0.01071em',
      },
      button: {
        fontFamily: 'Inter',
        fontSize: '0.9rem',
        fontWeight: 600,
        lineHeight: 1.75,
        letterSpacing: '0.02em',
        textTransform: 'none', // Disable uppercase transform for Material Design 3
      },
    },
    shape: {
      borderRadius: 8, // Material Design 3 rounded corners
    },
    components: {
      MuiButton: {
        styleOverrides: {
          root: {
            borderRadius: 8,
            textTransform: 'none',
            fontWeight: 500,
            fontSize: '.875rem',
            padding: '8px 16px',
            minHeight: 36,
            boxShadow: 'none',
            '&:hover': {
              boxShadow: '0px 2px 4px rgba(0, 0, 0, 0.2)',
            },
          },
          contained: {
            boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.12)',
            '&:hover': {
              boxShadow: '0px 2px 4px rgba(0, 0, 0, 0.2)',
            },
            '&:active': {
              boxShadow: '0px 0px 0px rgba(0, 0, 0, 0.2)',
            },
          },
        },
      },
      MuiCard: {
        styleOverrides: {
          root: {
            borderRadius: 12,
            boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.12)',
            border: `1px solid ${alpha('#c4a7e7', 0.12)}`,
            backgroundImage: 'none',
          },
        },
      },
      MuiPaper: {
        styleOverrides: {
          root: {
            backgroundImage: 'none',
            border: `1px solid ${alpha('#c4a7e7', 0.15)}`,
          },
          elevation1: {
            boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.12)',
          },
        },
      },
      MuiTab: {
        styleOverrides: {
          root: {
            textTransform: 'none',
            fontWeight: 500,
            fontSize: '.875rem',
            minHeight: 40,
            borderRadius: 6,
          },
        },
      },
      MuiTextField: {
        styleOverrides: {
          root: {
            '& .MuiOutlinedInput-root': {
              borderRadius: 8,
              '& fieldset': {
                borderColor: alpha('#c4a7e7', 0.23),
              },
              '&:hover fieldset': {
                borderColor: alpha('#c4a7e7', 0.4),
              },
              '&.Mui-focused fieldset': {
                borderColor: '#c4a7e7',
              },
            },
          },
        },
      },
      MuiChip: {
        styleOverrides: {
          root: {
            borderRadius: 6,
            height: 24,
            fontSize: '0.75rem',
            fontWeight: 500,
          },
        },
      },
      MuiSwitch: {
        styleOverrides: {
          root: {
            '& .MuiSwitch-switchBase.Mui-checked': {
              color: '#c4a7e7',
              '& + .MuiSwitch-track': {
                backgroundColor: '#c4a7e7',
                opacity: 0.7,
              },
            },
          },
        },
      },
      MuiSlider: {
        styleOverrides: {
          root: {
            color: '#c4a7e7',
            '& .MuiSlider-thumb': {
              boxShadow: '0px 2px 6px rgba(196, 167, 231, 0.25)',
            },
            '& .MuiSlider-track': {
              backgroundColor: '#c4a7e7',
            },
            '& .MuiSlider-rail': {
              backgroundColor: alpha('#c4a7e7', 0.3),
            },
          },
        },
      },
      MuiDialog: {
        styleOverrides: {
          paper: {
            borderRadius: 16,
            boxShadow: '0px 25px 50px rgba(0, 0, 0, 0.25)',
          },
        },
      },
      MuiMenu: {
        styleOverrides: {
          paper: {
            borderRadius: 8,
            boxShadow: '0px 4px 16px rgba(0, 0, 0, 0.12)',
            border: `1px solid ${alpha('#c4a7e7', 0.12)}`,
            marginTop: 4,
          },
        },
      },
      MuiTooltip: {
        styleOverrides: {
          tooltip: {
            backgroundColor: alpha('#191724', 0.95),
            color: '#e0def4',
            fontSize: '0.75rem',
            fontFamily: 'JetBrains Mono',
            borderRadius: 6,
            padding: '8px 12px',
            boxShadow: '0px 2px 8px rgba(0, 0, 0, 0.15)',
            border: `1px solid ${alpha('#c4a7e7', 0.15)}`,
          },
          arrow: {
            color: alpha('#191724', 0.95),
          },
        },
      },
    },
    spacing: 8, // Using 8px as base unit for Material Design 3 spacing scale
  });
};

// Material Design 3 elevation tokens
export const elevations = {
  surface: {
    level0: '0px 0px 0px 0px',
    level1: '0px 1px 3px 0px rgba(0, 0, 0, 0.12)',
    level2: '0px 2px 6px 0px rgba(0, 0, 0, 0.15)',
    level3: '0px 3px 12px 0px rgba(0, 0, 0, 0.20)',
    level4: '0px 4px 16px 0px rgba(0, 0, 0, 0.25)',
    level5: '0px 6px 24px 0px rgba(0, 0, 0, 0.30)',
  },
};
</file>

<file path="packages/frontend/src/utils/notification/NotificationAnimations.ts">
import { gsap } from 'gsap';

export const slideInNotification = (
  element: HTMLElement, 
  onComplete?: () => void
) => {
  gsap.fromTo(element, 
    { x: 300, opacity: 0, scale: 0.8 },
    { 
      x: 0, 
      opacity: 1, 
      scale: 1,
      duration: 0.5,
      ease: "back.out(1.7)",
      onComplete: onComplete
    }
  );
};

export const slideOutNotification = (
  element: HTMLElement, 
  onComplete?: () => void
) => {
  gsap.to(element, {
    x: 300,
    opacity: 0,
    scale: 0.8,
    duration: 0.3,
    ease: "back.in(1.7)",
    onComplete: onComplete
  });
};

export const animateProgressBar = (
  progressElement: HTMLElement, 
  durationSeconds: number, 
  onComplete?: () => void
) => {
  gsap.fromTo(progressElement,
    { width: '100%' },
    {
      width: '0%',
      duration: durationSeconds,
      ease: "none",
      onComplete: onComplete
    }
  );
};
</file>

<file path="packages/frontend/src/utils/notification/NotificationStyles.ts">
import { NotificationType } from '../../types/notification';
import { COLORS } from '../tokens';

const tokenOrFallback = (tokenPath: string, fallback: string) => {
  const parts = tokenPath.split('.');
  let cur: any = COLORS;
  for (const p of parts) {
    if (!cur) return fallback;
    cur = cur[p];
  }
  return typeof cur === 'string' ? cur : fallback;
};

export const getNotificationStyle = (type: NotificationType) => {
  switch (type) {
    case 'success':
      return {
        background: tokenOrFallback('health.healthy', 'rgba(34, 197, 94, 0.95)'),
        border: `1px solid ${tokenOrFallback('health.healthy', '#22c55e')}`,
        icon: 'âœ…'
      };
    case 'error':
      return {
        background: tokenOrFallback('error', 'rgba(239, 68, 68, 0.95)'),
        border: `1px solid ${tokenOrFallback('error', '#ef4444')}`,
        icon: 'âŒ'
      };
    case 'warning':
      return {
        background: tokenOrFallback('health.wounded', 'rgba(245, 158, 11, 0.95)'),
        border: `1px solid ${tokenOrFallback('health.wounded', '#f59e0b')}`,
        icon: 'âš ï¸'
      };
    case 'info':
      return {
        background: tokenOrFallback('primary', 'rgba(59, 130, 246, 0.95)'),
        border: `1px solid ${tokenOrFallback('primary', '#3b82f6')}`,
        icon: 'â„¹ï¸'
      };
    case 'combat':
      return {
        background: tokenOrFallback('error', 'rgba(220, 38, 38, 0.95)'),
        border: `1px solid ${tokenOrFallback('error', '#dc2626')}`,
        icon: 'âš”ï¸'
      };
    case 'loot':
      return {
        background: tokenOrFallback('health.wounded', 'rgba(245, 158, 11, 0.95)'),
        border: `1px solid ${tokenOrFallback('health.wounded', '#f59e0b')}`,
        icon: 'ðŸ’Ž'
      };
    case 'social':
      return {
        background: tokenOrFallback('accentPurple', 'rgba(168, 85, 247, 0.95)'),
        border: `1px solid ${tokenOrFallback('accentPurple', '#a855f7')}`,
        icon: 'ðŸ’¬'
      };
    case 'system':
      return {
        background: tokenOrFallback('text.tertiary', 'rgba(107, 114, 128, 0.95)'),
        border: `1px solid ${tokenOrFallback('text.tertiary', '#6b7280')}`,
        icon: 'ðŸ”§'
      };
    default:
      return {
        background: tokenOrFallback('primary', 'rgba(59, 130, 246, 0.95)'),
        border: `1px solid ${tokenOrFallback('primary', '#3b82f6')}`,
        icon: 'â„¹ï¸'
      };
  }
};
</file>

<file path="packages/frontend/src/utils/notification/NotificationUtils.ts">
// This file can be used for any generic notification-related utility functions
</file>

<file path="packages/frontend/src/utils/player/EffectUtils.ts">
import { PlayerEffect } from '../../types/playerStatus';
import { Buff } from 'shared'; // Import Buff enum

export const getEffectDescription = (effect: PlayerEffect): string => {
  switch (effect.type) {
    case Buff.HealthRegen:
      return `Health Regen (+${effect.strength} HP/turn, ${effect.duration} turns left)`;
    case Buff.ManaRegen:
      return `Mana Regen (+${effect.strength} MP/turn, ${effect.duration} turns left)`;
    case Buff.DamageBoost:
      return `Damage Boost (+${effect.strength} DMG, ${effect.duration} turns left)`;
    case Buff.SpeedBoost:
      return `Speed Boost (+${effect.strength} SPD, ${effect.duration} turns left)`;
    default:
      return `${effect.type} (Strength: ${effect.strength}, Duration: ${effect.duration} turns left)`;
  }
};
</file>

<file path="packages/frontend/src/utils/player/StatusUtils.ts">
export enum HealthStatus {
  Critical = 'critical',
  Low = 'low',
  Medium = 'medium',
  High = 'high',
  Full = 'full',
}

export const calculateHealthStatus = (healthPercentage: number): HealthStatus => {
  if (healthPercentage === 100) return HealthStatus.Full;
  if (healthPercentage > 75) return HealthStatus.High;
  if (healthPercentage > 50) return HealthStatus.Medium;
  if (healthPercentage > 25) return HealthStatus.Low;
  return HealthStatus.Critical;
};
</file>

<file path="packages/frontend/src/utils/classVisuals.ts">
import { CharacterClass } from "shared";

export const getClassBackgroundGradient = (characterClass: CharacterClass): string => {
  return `radial-gradient(circle at center, ${characterClass.primaryColor}20 0%, ${characterClass.secondaryColor}10 50%, transparent 100%)`;
};

export const getClassEffectClasses = (classId: string): string => {
  const baseClasses = 'opacity-30 mix-blend-overlay';

  switch (classId) {
    case 'quantum-drifter': return `${baseClasses} animate-pulse`;
    case 'tech-shaman': return `${baseClasses} animate-bounce`;
    case 'bio-hacker': return `${baseClasses} animate-ping`;
    case 'void-walker': return `${baseClasses} animate-spin`;
    case 'nano-smith': return `${baseClasses} animate-pulse`;
    case 'psy-scavenger': return `${baseClasses} animate-pulse`;
    default: return baseClasses;
  }
};

export const getClassFilter = (classId: string): string => {
  switch (classId) {
    case 'quantum-drifter': return 'blur(0.5px) brightness(1.1)';
    case 'tech-shaman': return 'contrast(1.2) saturate(1.1)';
    case 'bio-hacker': return 'hue-rotate(15deg) saturate(1.2)';
    case 'void-walker': return 'contrast(1.3) brightness(0.8)';
    case 'nano-smith': return 'brightness(1.1) contrast(1.1)';
    case 'psy-scavenger': return 'hue-rotate(-15deg) saturate(1.3)';
    default: return 'none';
  }
};
</file>

<file path="packages/frontend/src/utils/designSystem.ts">
// Design System - Centralized styling and layout constants
// This file establishes a cohesive design system for the entire application

import { COLORS } from './tokens';

// Spacing scale (in rem)
export const SPACING = {
  xs: '0.25rem',    // 4px
  sm: '0.5rem',     // 8px
  md: '1rem',       // 16px
  lg: '1.5rem',     // 24px
  xl: '2rem',       // 32px
  '2xl': '3rem',    // 48px
  '3xl': '4rem',    // 64px
} as const;

// Typography scale
export const TYPOGRAPHY = {
  fontFamily: {
    primary: 'Inter, Roboto, sans-serif',
    mono: 'JetBrains Mono, Consolas, monospace',
  },
  fontSize: {
    xs: '0.75rem',    // 12px
    sm: '0.875rem',   // 14px
    base: '1rem',     // 16px
    lg: '1.125rem',   // 18px
    xl: '1.25rem',    // 20px
    '2xl': '1.5rem',  // 24px
    '3xl': '1.875rem', // 30px
    '4xl': '2.25rem', // 36px
    '5xl': '3rem',    // 48px
  },
  fontWeight: {
    normal: '400',
    medium: '500',
    semibold: '600',
    bold: '700',
    extrabold: '800',
  },
  lineHeight: {
    tight: '1.25',
    normal: '1.5',
    relaxed: '1.75',
  },
} as const;

// Border radius scale
export const BORDER_RADIUS = {
  none: '0',
  sm: '0.125rem',   // 2px
  md: '0.375rem',   // 6px
  lg: '0.5rem',     // 8px
  xl: '0.75rem',    // 12px
  '2xl': '1rem',    // 16px
  '3xl': '1.5rem',  // 24px
  full: '9999px',
} as const;

// Shadow scale
export const SHADOWS = {
  none: 'none',
  sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
  md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
  lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
  xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
  '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
  inner: 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',
} as const;

// Layout dimensions
export const LAYOUT = {
  headerHeight: '4rem',
  sidebarWidth: {
    sm: '16rem',    // 256px
    md: '20rem',    // 320px
    lg: '24rem',    // 384px
  },
  maxContentWidth: '90rem', // 1440px
  gameCanvas: {
    maxWidth: 'calc(100vw - 20rem)', // Account for sidebar
    aspectRatio: '16/9',
  },
} as const;

// Animation durations
export const ANIMATION = {
  duration: {
    fast: '150ms',
    standard: '300ms',
    slow: '500ms',
    slower: '750ms',
  },
  easing: {
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
    easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
  },
  // Legacy flat properties for backwards compatibility
  fast: '150ms',
  normal: '300ms',
  slow: '500ms',
  slower: '750ms',
} as const;

// Z-index scale
export const Z_INDEX = {
  base: '0',
  dropdown: '1000',
  sticky: '1020',
  fixed: '1030',
  modal: '1040',
  popover: '1050',
  tooltip: '1060',
  toast: '1070',
} as const;

// Common style patterns
export const COMMON_STYLES = {
  // Glass morphism effect
  glass: {
    background: 'rgba(25, 23, 36, 0.95)',
    backdropFilter: 'blur(10px)',
    border: '1px solid rgba(196, 167, 231, 0.2)',
  },

  // Card styles
  card: {
    background: 'var(--color-surface)',
    border: '1px solid var(--color-outline)',
    borderRadius: BORDER_RADIUS.xl,
    padding: SPACING.lg,
  },

  // Button base styles
  button: {
    borderRadius: BORDER_RADIUS.md,
    fontWeight: TYPOGRAPHY.fontWeight.medium,
    transition: `all ${ANIMATION.fast} ease`,
    cursor: 'pointer',
    border: 'none',
    outline: 'none',
  },

  // Text shadow effects
  textShadow: {
    neon: '0 0 10px rgba(196, 167, 231, 0.8), 0 0 20px rgba(196, 167, 231, 0.5)',
    glow: '0 0 8px rgba(156, 207, 216, 0.6)',
    subtle: '0 1px 2px rgba(0, 0, 0, 0.3)',
  },

  // Text gradient for titles
  titleGradient: {
    background: 'linear-gradient(135deg, #c4a7e7 0%, #9ccfd8 100%)',
    WebkitBackgroundClip: 'text',
    WebkitTextFillColor: 'transparent',
    backgroundClip: 'text',
  },
} as const;

// Mode-specific styling
export const MODE_STYLES = {
  play: {
    accentColor: COLORS.status.active,
    headerIcon: 'ðŸŽ®',
    description: 'Join the realm and play',
  },
  spectate: {
    accentColor: COLORS.secondary,
    headerIcon: 'ðŸ‘ï¸',
    description: 'Watch ongoing games',
  },
  dev: {
    accentColor: COLORS['on-error'],
    headerIcon: 'ðŸ› ï¸',
    description: 'Developer tools & testing',
  },
} as const;

// Responsive breakpoints (in px)
export const BREAKPOINTS = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  '2xl': 1536,
} as const;

// Utility functions for responsive design
export const getResponsiveValue = <T>(values: { sm?: T; md?: T; lg?: T; xl?: T; default: T }): T => {
  if (typeof window === 'undefined') return values.default;

  const width = window.innerWidth;
  if (width >= BREAKPOINTS.xl && values.xl !== undefined) return values.xl;
  if (width >= BREAKPOINTS.lg && values.lg !== undefined) return values.lg;
  if (width >= BREAKPOINTS.md && values.md !== undefined) return values.md;
  if (width >= BREAKPOINTS.sm && values.sm !== undefined) return values.sm;

  return values.default;
};

// CSS custom properties for dynamic theming
export const CSS_VARIABLES = {
  // Layout
  '--header-height': LAYOUT.headerHeight,
  '--sidebar-width': LAYOUT.sidebarWidth.md,
  '--max-content-width': LAYOUT.maxContentWidth,

  // Spacing
  '--spacing-xs': SPACING.xs,
  '--spacing-sm': SPACING.sm,
  '--spacing-md': SPACING.md,
  '--spacing-lg': SPACING.lg,
  '--spacing-xl': SPACING.xl,

  // Typography
  '--font-family-primary': TYPOGRAPHY.fontFamily.primary,
  '--font-family-mono': TYPOGRAPHY.fontFamily.mono,

  // Border radius
  '--border-radius-sm': BORDER_RADIUS.sm,
  '--border-radius-md': BORDER_RADIUS.md,
  '--border-radius-lg': BORDER_RADIUS.lg,
  '--border-radius-xl': BORDER_RADIUS.xl,

  // Shadows
  '--shadow-sm': SHADOWS.sm,
  '--shadow-md': SHADOWS.md,
  '--shadow-lg': SHADOWS.lg,

  // Animation
  '--animation-fast': ANIMATION.fast,
  '--animation-normal': ANIMATION.normal,
  '--animation-slow': ANIMATION.slow,
} as const;

// Material-UI theme overrides for consistency
export const MATERIAL_THEME_OVERRIDES = {
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: BORDER_RADIUS.md,
          fontWeight: TYPOGRAPHY.fontWeight.medium,
          transition: `all ${ANIMATION.fast} ease`,
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: BORDER_RADIUS.sm,
          fontWeight: TYPOGRAPHY.fontWeight.medium,
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: BORDER_RADIUS.xl,
          boxShadow: SHADOWS.md,
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none',
        },
      },
    },
  },
} as const;
</file>

<file path="packages/frontend/src/utils/loggingUtils.ts">
/**
 * Logging utility with throttling to reduce console spam
 */

interface LogEntry {
  timestamp: number;
  count: number;
  lastMessage: string;
}

class ThrottledLogger {
  private logThrottleMap: Map<string, LogEntry> = new Map();
  private readonly throttleWindow: number = 60000; // 1 minute
  private readonly maxLogFrequency: number = 5000; // Max once per 5 seconds

  /**
   * Throttled logging function that prevents spam
   * @param key Unique identifier for the log type
   * @param message Log message
   * @param type Console method (log, error, warn, info)
   * @param force Log immediately regardless of throttling
   */
  log(key: string, message: string, type: 'log' | 'error' | 'warn' | 'info' = 'log', force = false): void {
    const now = Date.now();
    const entry = this.logThrottleMap.get(key);

    if (!entry || force) {
      // First occurrence or forced log
      this.logThrottleMap.set(key, {
        timestamp: now,
        count: 1,
        lastMessage: message
      });

      console[type](`[${key}] ${message}`);
      return;
    }

    // Check if enough time has passed since last log
    if (now - entry.timestamp < this.maxLogFrequency) {
      entry.count++;
      return;
    }

    // Log the message, potentially with suppressed count
    const prefix = entry.count > 1 ? `[${key}] [${entry.count} suppressed] ` : `[${key}] `;

    console[type](`${prefix}${message}`);

    // Reset for next occurrence
    this.logThrottleMap.set(key, {
      timestamp: now,
      count: 1,
      lastMessage: message
    });

    // Clean up old entries occasionally
    if (Math.random() < 0.1) { // 10% chance to clean up
      this.cleanup();
    }
  }

  /**
   * Clear all throttled log entries
   */
  clear(): void {
    this.logThrottleMap.clear();
  }

  /**
   * Remove log entries older than the throttle window
   */
  private cleanup(): void {
    const cutoff = Date.now() - this.throttleWindow;

    for (const [key, entry] of this.logThrottleMap.entries()) {
      if (entry.timestamp < cutoff) {
        this.logThrottleMap.delete(key);
      }
    }
  }

  /**
   * Get current log stats for debugging
   */
  getStats(): { [key: string]: LogEntry } {
    const stats: { [key: string]: LogEntry } = {};
    for (const [key, value] of this.logThrottleMap.entries()) {
      stats[key] = { ...value };
    }
    return stats;
  }
}

// Export singleton instance
export const throttledLogger = new ThrottledLogger();

// Convenience functions for common log types
export const throttledLog = (key: string, message: string, force = false) =>
  throttledLogger.log(key, message, 'log', force);

export const throttledError = (key: string, message: string, force = false) =>
  throttledLogger.log(key, message, 'error', force);

export const throttledWarn = (key: string, message: string, force = false) =>
  throttledLogger.log(key, message, 'warn', force);

export const throttledInfo = (key: string, message: string, force = false) =>
  throttledLogger.log(key, message, 'info', force);

export default throttledLogger;
</file>

<file path="packages/frontend/src/utils/RenderingProfiler.ts">
interface RenderStats {
  frameTime: number;
  fps: number;
  biomesRendered: number;
  entitiesRendered: number;
}

export class RenderingProfiler {
  private frameTimings: number[] = [];
  private lastFrameTime: number = performance.now();
  private renderStats: RenderStats = {
    frameTime: 0,
    fps: 0,
    biomesRendered: 0,
    entitiesRendered: 0,
  };

  public profileFrame(renderFunction: () => { biomes: number, entities: number }): RenderStats {
    const startTime = performance.now();

    const { biomes, entities } = renderFunction();

    const endTime = performance.now();
    const frameTime = endTime - startTime;

    this.frameTimings.push(frameTime);
    if (this.frameTimings.length > 60) { // Keep last 60 frames
      this.frameTimings.shift();
    }

    this.updateRenderStats(frameTime, biomes, entities);

    return this.renderStats;
  }

  private updateRenderStats(frameTime: number, biomes: number, entities: number): void {
    const now = performance.now();
    const delta = (now - this.lastFrameTime) / 1000;
    this.lastFrameTime = now;

    const avgFrameTime = this.frameTimings.reduce((a, b) => a + b, 0) / this.frameTimings.length;

    this.renderStats = {
      frameTime: avgFrameTime,
      fps: 1 / delta,
      biomesRendered: biomes,
      entitiesRendered: entities,
    };
  }
}
</file>

<file path="packages/frontend/src/utils/tokens.ts">
// tokens.ts
// Provides a JS-friendly export of the centralized color tokens
// This keeps a single source of truth for colors for both Tailwind and JS/TS code.

// Centralized color tokens (same as in tailwind.config.js)
export const COLORS = {
  primary: '#31748f',
  'primary-container': '#1e40af',
  'on-primary': '#1f1d2e',
  secondary: '#9ccfd8',
  'secondary-container': '#334155',
  'on-secondary': '#1f1d2e',
  surface: '#1f1d2e',
  'surface-variant': '#2a2a3e',
  'on-surface': '#e0def4',
  'on-surface-variant': '#908caa',
  outline: '#6e6a86',
  background: '#191724',
  'on-background': '#e0def4',
  error: '#dc2626',
  'on-error': '#1f1d2e',
  'error-container': '#7f1d1d',
  'on-error-container': '#fef2f2',
  text: {
    primary: '#e0def4',
    secondary: '#908caa',
    tertiary: '#6e6a86',
  },
  health: {
    healthy: '#a3e635',
    wounded: '#fbbf24',
    critical: '#f97316',
    dying: '#dc2626',
  },
  status: {
    active: {
      bg: 'rgba(163, 230, 53, 0.2)',
      text: '#a3e635',
      border: '#84cc16',
    },
    negative: {
      bg: 'rgba(220, 38, 38, 0.2)',
      text: '#dc2626',
      border: '#b91c1c',
    },
  },
  backgroundDark: '#191724',
  backgroundMedium: '#1f1d2e',
  textLight: '#e0def4',
  accentPurple: '#c4a7e7',
  primaryBlue: '#31748f',
  secondaryBlue: '#9ccfd8',
  accentDarkPurple: '#9b59b6',
  legendKnight: '#FFD700',
  legendRogue: '#8B0000',
  legendMage: '#4B0082',
  legendNPC: '#DC143C',
  legendItem: '#F59E0B',
  tabSettings: '#17a2b8',
  healthFillHealthyStart: '#22c55e',
  healthFillHealthyEnd: '#16a34a',
  healthFillWoundedStart: '#fbbf24',
  healthFillWoundedEnd: '#f59e0b',
  healthFillCriticalStart: '#f97316',
  healthFillCriticalEnd: '#ea580c',
  healthFillDyingStart: '#dc2626',
  healthFillDyingEnd: '#b91c1c',
  expFillStart: '#f6c177',
  expFillEnd: '#ebbcba',
  expValue: '#f6c177',
  textLightAlt: '#ecf0f1',
  textMedium: '#bdc3c7',
  borderGray: '#6e6a86',
  textDark: '#908caa',
};
</file>

<file path="packages/frontend/src/utils/ViewportCulling.ts">
import { Biome, Position } from 'shared';

interface BoundingBox {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
}

export class ViewportCuller {
  public cullBiomesForViewport(
    biomes: Biome[],
    viewport: BoundingBox,
    buffer: number = 64
  ): Biome[] {
    return biomes.filter(biome =>
      this.biomeIntersectsViewport(biome, viewport, buffer)
    );
  }

  public cullTexturePointsForViewport(
    texturePoints: Position[],
    viewport: BoundingBox
  ): Position[] {
    return texturePoints.filter(point =>
      this.pointInViewport(point, viewport)
    );
  }

  private biomeIntersectsViewport(biome: Biome, viewport: BoundingBox, buffer: number): boolean {
    const biomeBounds = biome.bounds;
    return (
      biomeBounds.minX < viewport.maxX + buffer &&
      biomeBounds.maxX > viewport.minX - buffer &&
      biomeBounds.minY < viewport.maxY + buffer &&
      biomeBounds.maxY > viewport.minY - buffer
    );
  }

  private pointInViewport(point: Position, viewport: BoundingBox): boolean {
    return (
      point.x >= viewport.minX &&
      point.x <= viewport.maxX &&
      point.y >= viewport.minY &&
      point.y <= viewport.maxY
    );
  }
}
</file>

<file path="packages/frontend/src/basic.test.ts">
import { describe, it, expect } from 'vitest';

describe('Basic Test Suite', () => {
  it('should pass a basic test', () => {
    expect(1 + 1).toBe(2);
  });

  it('should work with async code', async () => {
    const result = await Promise.resolve('test');
    expect(result).toBe('test');
  });
});
</file>

<file path="packages/frontend/src/index.css">
/* Load web fonts (Inter and JetBrains Mono) for consistent typography across the app.
  Using Google Fonts with display=swap for better performance. */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=JetBrains+Mono:wght@400;600;700&display=swap');
/* Noto Sans for UI text */
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400;500;700&display=swap');

/* Noto Emoji font for comprehensive emoji support */
@import '@fontsource/noto-emoji';

/* Emoji font optimization */
.emoji-font {
  font-family: 'Noto Emoji', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', 'Android Emoji', 'EmojiSymbols', 'EmojiOne Mozilla', 'Twemoji Mozilla', 'Segoe UI', sans-serif;
  font-variant-emoji: unicode;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  /* Ensure emojis are centered and scale predictably across browsers */
  text-align: center;
  line-height: 1;
}

/* Custom utility classes for gradients and effects */
.header-gradient {
  background: linear-gradient(135deg, var(--color-text-primary) 0%, rgba(196, 167, 231, 0.7) 100%);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 15px rgba(196, 167, 231, 0.3);
}

/* Font family utility */
.font-inter {
  font-family: 'Noto Sans', 'Inter', 'Roboto', sans-serif;
}

/* Title font: Times New Roman family for headings */
.title-font {
  font-family: 'Times New Roman', Times, serif;
}

/* Global body font override to use Noto */
:root, body, #root {
  font-family: 'Noto Sans', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
}

/* Make all headings use Times New Roman and be uppercase */
h1, h2, h3, h4, h5, h6 {
  font-family: 'Times New Roman', Times, serif;
  text-transform: uppercase;
  letter-spacing: 0.06em;
}
</file>

<file path="packages/frontend/src/mockData.ts">
import type { GameWorld, Player, NPC, Item, Terrain } from 'shared';
import { BiomeType, PlayerClass, ItemType, ItemRarity } from 'shared';
import { GAME_CONFIG } from 'shared';

// Mock terrain grid with varied terrain types
const createMockGrid = (): Terrain[][] => {
  const grid: Terrain[][] = [];

  for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
    grid[y] = [];
    for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
      let terrainType = BiomeType.PLAIN;

      // Create some patterns for interesting terrain
      if ((x + y) % 7 === 0) {
        terrainType = BiomeType.FOREST;
      } else if (x % 8 === 0 && y % 6 === 0) {
        terrainType = BiomeType.MOUNTAIN;
      }

      const config = GAME_CONFIG.terrainConfig[terrainType];
      grid[y][x] = {
        type: terrainType,
        position: { x, y },
        movementCost: config.movementCost,
        defenseBonus: config.defenseBonus,
        visibilityModifier: config.visibilityModifier
      };
    }
  }

  return grid;
};

// Mock players with different classes
const createMockPlayers = (): Player[] => [
  {
    id: 'player_1',
    twitchUsername: 'gamer123',
    displayName: 'Gamer123',
    avatar: 'ðŸ¤ ',
    position: { x: 5, y: 3 },
    class: PlayerClass.KNIGHT,
    health: 110,
    mana: 40,
    stamina: 30,
    hunger: 15,
    thirst: 20,
    stats: {
      hp: 110,
      maxHp: 120,
      attack: 18,
      defense: 25,
      speed: 6
    },
    level: 2,
    experience: 150,
    inventory: [],
    equipment: {},
    achievements: ['first_blood'],
    titles: ['[Warrior]'],
    isAlive: true,
    lastMoveTime: Date.now() - 2000,
    spawnTime: Date.now() - 300000,
    connected: true,
    lastActive: Date.now() - 1000
  },
  {
    id: 'player_2',
    twitchUsername: 'rogueMaster',
    displayName: 'RogueMaster',
    avatar: 'ðŸ—¡ï¸',
    position: { x: 12, y: 8 },
    class: PlayerClass.ROGUE,
    health: 85,
    mana: 45,
    stamina: 25,
    hunger: 22,
    thirst: 18,
    stats: {
      hp: 85,
      maxHp: 90,
      attack: 28,
      defense: 12,
      speed: 16
    },
    level: 3,
    experience: 280,
    inventory: [],
    equipment: {},
    achievements: ['first_blood', 'survivor'],
    titles: ['[Gladiator]', '[Survivor]'],
    isAlive: true,
    lastMoveTime: Date.now() - 5000,
    spawnTime: Date.now() - 450000,
    connected: true,
    lastActive: Date.now() - 3000
  },
  {
    id: 'player_3',
    twitchUsername: 'mageWizard',
    displayName: 'MageWizard',
    avatar: 'ðŸ”®',
    position: { x: 8, y: 10 },
    class: PlayerClass.MAGE,
    health: 75,
    mana: 55,
    stamina: 20,
    hunger: 8,
    thirst: 12,
    stats: {
      hp: 75,
      maxHp: 80,
      attack: 32,
      defense: 8,
      speed: 11
    },
    level: 1,
    experience: 45,
    inventory: [],
    equipment: {},
    achievements: [],
    titles: [],
    isAlive: true,
    lastMoveTime: Date.now() - 1000,
    spawnTime: Date.now() - 120000,
    connected: true,
    lastActive: Date.now() - 500
  }
];

// Mock NPCs scattered around the map
const createMockNPCs = (): NPC[] => [
  {
    id: 'goblin_1',
    name: 'Goblin Scout',
    type: 'goblin',
    position: { x: 15, y: 5 },
    stats: {
      hp: 55,
      maxHp: 60,
      attack: 10,
      defense: 6,
      speed: 14
    },
    behavior: 'wandering',
    lootTable: [],
    isAlive: true,
    lastMoveTime: Date.now() - 3000
  },
  {
    id: 'goblin_2',
    name: 'Goblin Warrior',
    type: 'goblin',
    position: { x: 3, y: 12 },
    stats: {
      hp: 70,
      maxHp: 70,
      attack: 15,
      defense: 10,
      speed: 10
    },
    behavior: 'aggressive',
    lootTable: [],
    isAlive: true,
    lastMoveTime: Date.now() - 1500
  },
  {
    id: 'orc_1',
    name: 'Orc Berserker',
    type: 'orc',
    position: { x: 18, y: 14 },
    stats: {
      hp: 100,
      maxHp: 100,
      attack: 20,
      defense: 12,
      speed: 8
    },
    behavior: 'aggressive',
    lootTable: [],
    isAlive: true,
    lastMoveTime: Date.now() - 4000
  }
];

// Mock items scattered around the map
const createMockItems = (): Item[] => [
  {
    id: 'sword_1',
    name: 'Iron Sword',
    type: ItemType.WEAPON,
    rarity: ItemRarity.UNCOMMON,
    description: 'A well-balanced iron sword',
    stats: { attack: 5 },
    position: { x: 7, y: 6 },
    // Tarkov-style looting properties
    isHidden: true,
    revealDuration: 4000, // 4 seconds for uncommon
    revealProgress: 0.0,
    canBeLooted: false
  },
  {
    id: 'potion_1',
    name: 'Health Potion',
    type: ItemType.CONSUMABLE,
    rarity: ItemRarity.COMMON,
    description: 'Restores 50 HP',
    stats: { hp: 50 },
    position: { x: 10, y: 9 },
    // Tarkov-style looting properties
    isHidden: false, // This one is already revealed for demo
    revealDuration: 2000,
    revealProgress: 1.0,
    canBeLooted: true
  },
  {
    id: 'shield_1',
    name: 'Wooden Shield',
    type: ItemType.ARMOR,
    rarity: ItemRarity.COMMON,
    description: 'Basic wooden protection',
    stats: { defense: 3 },
    position: { x: 14, y: 11 },
    // Tarkov-style looting properties
    isHidden: true,
    revealDuration: 2000,
    revealProgress: 0.0,
    canBeLooted: false
  },
  {
    id: 'boots_1',
    name: 'Swift Boots',
    type: ItemType.ARMOR,
    rarity: ItemRarity.RARE,
    description: 'Increases movement speed',
    stats: { speed: 2 },
    specialEffect: 'increases movement speed',
    position: { x: 2, y: 8 },
    // Tarkov-style looting properties
    isHidden: true,
    revealDuration: 8000, // 8 seconds for rare
    revealProgress: 0.0,
    canBeLooted: false
  }
];

// Create the complete mock game world
export const createMockGameWorld = (): GameWorld => {
  return {
    id: 'mock_world_1',
    grid: createMockGrid(),
    players: createMockPlayers(),
    npcs: createMockNPCs(),
    items: createMockItems(),
    buildings: [], // Mock buildings array
    cataclysmCircle: {
      center: { x: 20, y: 15 },
      radius: 40,
      isActive: false,
      shrinkRate: 1,
      nextShrinkTime: Date.now() + 300000 // 5 minutes from now
    },
    cataclysmRoughnessMultiplier: 1.0,
    worldAge: 0,
    lastResetTime: Date.now(),
    phase: 'exploration'
  };
};

// Export individual mock data for testing
export const mockGrid = createMockGrid();
export const mockPlayers = createMockPlayers();
export const mockNPCs = createMockNPCs();
export const mockItems = createMockItems();
</file>

<file path="packages/frontend/ANIMATION_LIBRARIES.md">
# Animation Libraries Integration

This project now includes advanced animation capabilities using GSAP and Rough.js libraries.

## Libraries Added

### 1. GSAP (GreenSock Animation Platform)
- **Already installed**: `gsap@^3.13.0`
- Used for: Notification animations, complex UI transitions
- Features: Timeline control, easing functions, scroll triggers

### 2. Rough Notation
- **Newly added**: Modern alternative to Khan Academy's Khannotations
- Used for: Hand-drawn style annotations and highlights
- Features: Underlines, boxes, circles, highlights with rough edges

## New Components

### RoughAnimatedShape
Creates animated rough.js shapes with GSAP animations.

```tsx
import { RoughAnimatedShape } from './components/animations';

<RoughAnimatedShape
  shape="circle"
  animationType="bounce"
  fill="#fef3c7"
  fillStyle="cross-hatch"
  stroke="#d97706"
  width={120}
  height={120}
/>
```

**Props:**
- `shape`: 'rectangle' | 'circle' | 'ellipse' | 'line'
- `animationType`: 'draw' | 'fade' | 'scale' | 'bounce'
- `fill`, `stroke`, `fillStyle`: Rough.js styling options
- `width`, `height`: Canvas dimensions

### ScrollAnimatedElement
GSAP ScrollTrigger-powered scroll animations.

```tsx
import { ScrollAnimatedElement } from './components/animations';

<ScrollAnimatedElement animation="slideUp" start="top 80%">
  <div>Content that animates on scroll</div>
</ScrollAnimatedElement>
```

**Props:**
- `animation`: 'fadeIn' | 'slideUp' | 'slideDown' | 'slideLeft' | 'slideRight' | 'scale' | 'rotate'
- `start`, `end`: Scroll trigger positions
- `scrub`: Smooth scrubbing boolean/number
- `pin`: Pin element during animation

### RoughNotation
Hand-drawn style annotations.

```tsx
import { RoughNotation, GameAchievement, GameObjective } from './components/animations';

// Basic usage
<RoughNotation type="underline" color="#ff6b6b" trigger="hover">
  Important text
</RoughNotation>

// Game-specific components
<GameAchievement achieved={true}>
  ðŸŽ‰ Level Up!
</GameAchievement>

<GameObjective completed={false}>
  âš”ï¸ Defeat the dragon
</GameObjective>
```

**Props:**
- `type`: 'underline' | 'box' | 'circle' | 'highlight' | 'strike-through' | 'crossed-off'
- `trigger`: 'hover' | 'click' | 'scroll' | 'manual'
- `color`, `strokeWidth`, `animationDuration`: Styling options

## Hooks

### useRoughAnnotation
Programmatic control over rough annotations.

```tsx
const { annotate } = useRoughAnnotation();

// Annotate an element
const element = document.getElementById('target');
annotate(element, 'circle', {
  color: '#ff6b6b',
  strokeWidth: 3,
  animationDuration: 1000
});
```

### useScrollAnimation
Create scroll-triggered animations programmatically.

```tsx
const { createReveal, createParallax } = useScrollAnimation();

// Reveal animation
createReveal(element, 'up', 50);

// Parallax effect
createParallax(element, 0.5, 'up');
```

## Demo

Visit `/animations` route to see all animation components in action.

## Integration Examples

### Enhanced Game UI
```tsx
// Animated achievement notifications
<GameAchievement achieved={playerLeveledUp}>
  ðŸŽ‰ Reached Level {playerLevel}!
</GameAchievement>

// Scroll-revealing quest objectives
<ScrollAnimatedElement animation="slideUp">
  <GameObjective completed={questDone}>
    {questDone ? "âœ…" : "âš”ï¸"} {questText}
  </GameObjective>
</ScrollAnimatedElement>

// Rough-animated game elements
<RoughAnimatedShape
  shape="circle"
  animationType="scale"
  fill="#4ade80"
  className="health-indicator"
/>
```

### Interactive Annotations
```tsx
// Highlight important game elements
<GameHighlight type="warning" trigger="hover">
  âš ï¸ Boss approaching!
</GameHighlight>

// Clickable tutorial hints
<RoughNotation type="box" trigger="click" color="#3b82f6">
  ðŸ’¡ Click here for help
</RoughNotation>
```

## Performance Notes

- GSAP animations are GPU-accelerated when possible
- Rough.js generates SVG/Canvas elements - monitor DOM size
- ScrollTrigger animations are cleaned up automatically
- Use `game-ui-element` class for scroll-animated game UI

## Browser Support

- GSAP: All modern browsers + IE9+
- Rough Notation: Modern browsers with ES6 support
- ScrollTrigger: Requires IntersectionObserver support

## Migration from Existing Animations

The new animation system complements existing CSS animations and Rough.js usage:

- **Keep CSS animations** for simple transitions
- **Use GSAP** for complex sequences and scroll animations
- **Use Rough Notation** for hand-drawn style highlights
- **Use RoughAnimatedShape** for animated rough graphics
</file>

<file path="packages/frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat Grid Chronicles</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Flex:wght@400;600;700;800&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="packages/frontend/postcss.config.js">
export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
</file>

<file path="packages/frontend/styling-consistency-strategy.md">
# Styling Consistency Strategy â€” Game / Frontend

Goal
- Reduce visual drift and duplication while keeping the productivity benefits of Tailwind and the component richness of Material-UI (MUI).

Principles
1. Single source of truth for tokens
   - Keep colors, spacing, radii, breakpoints, and typography tokens in one file: `packages/frontend/src/constants/colors.ts` (colors exist) + new `tokens.ts` if needed.
   - Use these tokens to generate both the MUI theme and to keep Tailwind config aligned.

2. Responsibilities
   - Material-UI (MUI): layout primitives, interactive complex components (dialogs, drawers, app bars, menus), accessible focus/keyboard behavior, and components that require rich theming or JS logic.
   - Tailwind CSS: low-level visual tweaks, one-off utility styling, micro-layout inside MUI components, and fast prototyping of small UI pieces.
   - Avoid styling the same component with both systems at once; prefer a single approach per component.

3. Theming & Token sync
   - Create `src/utils/materialTheme/materialTheme.ts` (already exists) to consume tokens.
   - Keep `tailwind.config.js` values (colors, spacing, borderRadius) in sync with tokens. When possible, import generated token JSON into `tailwind.config.js` or keep a short script to validate parity.
   - Use semantic names (e.g., `brand-primary`, `ui-bg`, `accent-01`) across both systems.

4. Component guidelines
   - Wrapper components: expose a small set of props and use MUI internally. Example: `MaterialButton.tsx` wraps `Button` with the project's theme and maps a small set of Tailwind-friendly props if needed.
   - Low-level visuals: prefer Tailwind classes for ephemeral/one-off styles (margins, paddings, flex utilities).
   - Complex widgets: build with MUI primitives + sx prop. Use Tailwind inside MUI where only utility classes are needed for layout that doesn't affect MUI internals.
   - Prefer MUI `sx` over inline styles when the style is theme-aware.

5. Accessibility and Interaction
   - Use MUI components for anything where keyboard focus, aria roles, or complex interactions matter.
   - Keep Tailwind purely presentational (no focus management logic).

6. Linting / Enforcement
   - Add ESLint rules and a short code review checklist:
     - "If component contains aria/focus/keyboard logic -> use MUI".
     - "If styling is just layout/spacing -> Tailwind allowed".
   - Create a small codemod / script to detect MUI components that also use Tailwind classes heavily (optional).

7. Migration & Adoption plan
   - Short-term (1â€“2 days)
     - Document the rules above in `styling-consistency-strategy.md` (this file).
     - Audit the top 20 UI components and mark ones that violate the guideline.
   - Mid-term (1â€“2 weeks)
     - Create wrappers for commonly used MUI components (Button, Card, Tooltip, Drawer) to standardize usages.
     - Sync tokens between Tailwind and MUI (generate JSON or small script).
   - Long-term
     - Replace duplicated styles (e.g., `MaterialCard` + Tailwind classes) with the wrapper that accepts utility props but applies theme tokens internally.

8. Small, practical patterns to follow
   - Use `className` for Tailwind utilities, `sx` or `classes` for theme-aware MUI styling.
   - Avoid relying on Tailwind for global theme variables (colors, font sizes). Use tokens instead.
   - When using both on same element, prefer MUI for spacing/margins that affect layout consistency across breakpoints; Tailwind for quick, isolated tweaks.

9. Developer ergonomics
   - Keep `Material*` wrapper components in `src/components/` (they exist).
   - Add short examples in `README.md` of how to style a component correctly with both systems.

10. Automation & tests
    - Add simple jest/unit tests for token parity (colors and spacing exist in both configurations).
    - Add Storybook or visual snapshots for critical components to catch regressions.

References & Action Items
- Proof-of-concept: create one canonical `PrimaryButton` that uses MUI but can accept a `className` for Tailwind utilities.
- Script: `scripts/sync-tokens.js` (optional) â€” export tokens to JSON and import in `tailwind.config.js`.
- Add lint rule / PR checklist item: "Check styling system used and token usage."

Implementation checklist (project-level)
- [x] Create strategy doc (this file)
- [ ] Audit top UI components for mixed usage (Material + lots of Tailwind)
- [ ] Create MUI wrapper components with consistent prop surface
- [ ] Sync tokens (script or generated file) between MUI theme and tailwind.config.js
- [ ] Add token parity tests
- [ ] Update onboarding README with new guidelines
</file>

<file path="packages/frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "~/*": ["./src/*"],
      "@shared/*": ["../shared/src/*"],
      "shared": ["../shared/src/index.ts"],
      "shared/*": ["../shared/src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="packages/frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="packages/shared/src/constants/biomeConfigs.ts">
import { BiomeRenderConfig, BiomeType } from '../types/biomes';

export const BIOME_RENDER_CONFIGS: Record<BiomeType, BiomeRenderConfig> = {
  [BiomeType.GRASSLAND]: {
    name: 'Grassland',
    colors: { primary: '#90EE90', secondary: '#7CFC00', border: '#228B22' },
    roughnessBase: 1.2,
    bowingBase: 0.8,
    fillPattern: 'zigzag-line',
    hachureAngle: 45,
    hachureGap: 4,
    strokeWidth: 1.5,
    textureOverlay: { type: 'trees', density: 0.05, size: 8 },
  },
  [BiomeType.FOREST]: {
    name: 'Forest',
    colors: { primary: '#228B22', secondary: '#006400', border: '#000' },
    roughnessBase: 1.5,
    bowingBase: 1,
    fillPattern: 'hachure',
    hachureAngle: -45,
    hachureGap: 5,
    strokeWidth: 2,
    textureOverlay: { type: 'trees', density: 0.2, size: 10 },
  },
  [BiomeType.DESERT]: {
    name: 'Desert',
    colors: { primary: '#F4A460', secondary: '#D2B48C', border: '#8B4513' },
    roughnessBase: 0.8,
    bowingBase: 0.2,
    fillPattern: 'dots',
    hachureAngle: 0,
    hachureGap: 10,
    strokeWidth: 1,
  },
  [BiomeType.WASTELAND]: {
    name: 'Wasteland',
    colors: { primary: '#A9A9A9', secondary: '#808080', border: '#696969' },
    roughnessBase: 2.5,
    bowingBase: 2,
    fillPattern: 'cross-hatch',
    hachureAngle: 45,
    hachureGap: 8,
    strokeWidth: 2,
    textureOverlay: { type: 'rocks', density: 0.1, size: 6 },
  },
  [BiomeType.TOXIC_ZONE]: {
    name: 'Toxic Zone',
    colors: { primary: '#7FFF00', secondary: '#ADFF2F', border: '#32CD32' },
    roughnessBase: 3,
    bowingBase: 2.5,
    fillPattern: 'solid',
    hachureAngle: 0,
    hachureGap: 0,
    strokeWidth: 1,
    animationProperties: { breathingIntensity: 0.3, colorPulse: 0.5, roughnessVariation: 1.5 },
  },
  [BiomeType.RADIATION_FIELD]: {
    name: 'Radiation Field',
    colors: { primary: '#FFFF00', secondary: '#FFD700', border: '#DAA520' },
    roughnessBase: 1,
    bowingBase: 3,
    fillPattern: 'zigzag-line',
    hachureAngle: 0,
    hachureGap: 6,
    strokeWidth: 2,
    animationProperties: { breathingIntensity: 0.5, colorPulse: 0.8, roughnessVariation: 2 },
  },
  [BiomeType.CRYSTAL_GARDEN]: {
    name: 'Crystal Garden',
    colors: { primary: '#AFEEEE', secondary: '#40E0D0', border: '#00CED1' },
    roughnessBase: 0.5,
    bowingBase: 0.5,
    fillPattern: 'hachure',
    hachureAngle: 60,
    hachureGap: 3,
    strokeWidth: 1,
    textureOverlay: { type: 'crystals', density: 0.15, size: 12 },
    animationProperties: { breathingIntensity: 0.1, colorPulse: 0.2, roughnessVariation: 0.5 },
  },
  [BiomeType.URBAN_RUINS]: {
    name: 'Urban Ruins',
    colors: { primary: '#696969', secondary: '#808080', border: '#000' },
    roughnessBase: 2,
    bowingBase: 0.2,
    fillPattern: 'cross-hatch',
    hachureAngle: 90,
    hachureGap: 10,
    strokeWidth: 2.5,
    textureOverlay: { type: 'ruins', density: 0.08, size: 15 },
  },
  [BiomeType.INFECTED_NORMAL]: {
    name: 'Infected Territory',
    colors: { primary: '#E6E6FA', secondary: '#D8BFD8', border: '#8A2BE2' },
    roughnessBase: 3.5,
    bowingBase: 4,
    fillPattern: 'hachure',
    hachureAngle: 15,
    hachureGap: 7,
    strokeWidth: 2,
    textureOverlay: { type: 'corruption', density: 0.1, size: 5 },
    animationProperties: { breathingIntensity: 0.7, colorPulse: 0.3, roughnessVariation: 2.5 },
  },
  [BiomeType.INFECTED_HEAVY]: {
    name: 'Heavily Infected Territory',
    colors: { primary: '#DDA0DD', secondary: '#DA70D6', border: '#BA55D3' },
    roughnessBase: 4.5,
    bowingBase: 5,
    fillPattern: 'cross-hatch',
    hachureAngle: 30,
    hachureGap: 6,
    strokeWidth: 2.5,
    textureOverlay: { type: 'corruption', density: 0.25, size: 8 },
    animationProperties: { breathingIntensity: 1, colorPulse: 0.5, roughnessVariation: 3.5 },
  },
  [BiomeType.INFECTED_CORE]: {
    name: 'Infection Core',
    colors: { primary: '#9932CC', secondary: '#8B008B', border: '#4B0082' },
    roughnessBase: 6,
    bowingBase: 7,
    fillPattern: 'solid',
    hachureAngle: 0,
    hachureGap: 0,
    strokeWidth: 3,
    textureOverlay: { type: 'corruption', density: 0.5, size: 12 },
    animationProperties: { breathingIntensity: 1.5, colorPulse: 1, roughnessVariation: 5 },
  },
  // Adding configs for other existing biomes for completeness
  [BiomeType.WATER]: {
    name: 'Water',
    colors: { primary: '#1E90FF', secondary: '#4169E1', border: '#00008B' },
    roughnessBase: 0.5, bowingBase: 2, fillPattern: 'solid', hachureAngle: 0, hachureGap: 0, strokeWidth: 1
  },
  [BiomeType.OCEAN]: {
    name: 'Ocean',
    colors: { primary: '#0000CD', secondary: '#000080', border: '#000000' },
    roughnessBase: 1, bowingBase: 3, fillPattern: 'solid', hachureAngle: 0, hachureGap: 0, strokeWidth: 1
  },
  [BiomeType.RIVER]: {
    name: 'River',
    colors: { primary: '#87CEEB', secondary: '#00BFFF', border: '#1E90FF' },
    roughnessBase: 0.2, bowingBase: 4, fillPattern: 'solid', hachureAngle: 0, hachureGap: 0, strokeWidth: 1
  },
  [BiomeType.MOUNTAIN_PEAK]: {
    name: 'Mountain Peak',
    colors: { primary: '#DCDCDC', secondary: '#FFFFFF', border: '#808080' },
    roughnessBase: 4, bowingBase: 1, fillPattern: 'hachure', hachureAngle: 45, hachureGap: 10, strokeWidth: 3
  },
  [BiomeType.MOUNTAIN]: {
    name: 'Mountain',
    colors: { primary: '#A9A9A9', secondary: '#808080', border: '#696969' },
    roughnessBase: 3, bowingBase: 1, fillPattern: 'cross-hatch', hachureAngle: 45, hachureGap: 12, strokeWidth: 2.5
  },
  [BiomeType.HILLS]: {
    name: 'Hills',
    colors: { primary: '#BDB76B', secondary: '#F0E68C', border: '#8B4513' },
    roughnessBase: 1.5, bowingBase: 0.5, fillPattern: 'hachure', hachureAngle: 20, hachureGap: 6, strokeWidth: 1.5
  },
  [BiomeType.SNOW]: {
    name: 'Snow',
    colors: { primary: '#FFFAFA', secondary: '#F5F5F5', border: '#D3D3D3' },
    roughnessBase: 0.8, bowingBase: 0.8, fillPattern: 'solid', hachureAngle: 0, hachureGap: 0, strokeWidth: 1
  },
  [BiomeType.ICE]: {
    name: 'Ice',
    colors: { primary: '#F0FFFF', secondary: '#E0FFFF', border: '#AFEEEE' },
    roughnessBase: 0.3, bowingBase: 0.2, fillPattern: 'cross-hatch', hachureAngle: 45, hachureGap: 15, strokeWidth: 0.8
  },
  [BiomeType.SNOWY_HILLS]: {
    name: 'Snowy Hills',
    colors: { primary: '#E6E6FA', secondary: '#FFFFFF', border: '#B0C4DE' },
    roughnessBase: 1.8, bowingBase: 1, fillPattern: 'hachure', hachureAngle: -20, hachureGap: 8, strokeWidth: 1.5
  },
  [BiomeType.DUNES]: {
    name: 'Dunes',
    colors: { primary: '#FFE4B5', secondary: '#FFDAB9', border: '#CD853F' },
    roughnessBase: 1, bowingBase: 1.5, fillPattern: 'zigzag-line', hachureAngle: 0, hachureGap: 8, strokeWidth: 1.2
  },
  [BiomeType.OASIS]: {
    name: 'Oasis',
    colors: { primary: '#20B2AA', secondary: '#3CB371', border: '#2E8B57' },
    roughnessBase: 0.7, bowingBase: 1, fillPattern: 'solid', hachureAngle: 0, hachureGap: 0, strokeWidth: 1,
    textureOverlay: { type: 'trees', density: 0.3, size: 7 }
  },
  [BiomeType.SAND]: {
    name: 'Sand',
    colors: { primary: '#F5DEB3', secondary: '#DEB887', border: '#D2B48C' },
    roughnessBase: 0.5, bowingBase: 0.5, fillPattern: 'dots', hachureAngle: 0, hachureGap: 15, strokeWidth: 1
  },
  [BiomeType.DENSE_JUNGLE]: {
    name: 'Dense Jungle',
    colors: { primary: '#008000', secondary: '#006400', border: '#2F4F4F' },
    roughnessBase: 2.2, bowingBase: 1.8, fillPattern: 'hachure', hachureAngle: -55, hachureGap: 4, strokeWidth: 2.5,
    textureOverlay: { type: 'trees', density: 0.4, size: 12 }
  },
  [BiomeType.JUNGLE]: {
    name: 'Jungle',
    colors: { primary: '#2E8B57', secondary: '#3CB371', border: '#6B8E23' },
    roughnessBase: 1.8, bowingBase: 1.5, fillPattern: 'hachure', hachureAngle: -50, hachureGap: 5, strokeWidth: 2,
    textureOverlay: { type: 'trees', density: 0.25, size: 10 }
  },
  [BiomeType.DEEP_WATER]: {
    name: 'Deep Water',
    colors: { primary: '#000080', secondary: '#191970', border: '#000000' },
    roughnessBase: 1.2, bowingBase: 3.5, fillPattern: 'solid', hachureAngle: 0, hachureGap: 0, strokeWidth: 1
  },
  [BiomeType.MARSH]: {
    name: 'Marsh',
    colors: { primary: '#556B2F', secondary: '#6B8E23', border: '#808000' },
    roughnessBase: 1.3, bowingBase: 2, fillPattern: 'zigzag-line', hachureAngle: 10, hachureGap: 7, strokeWidth: 1.5
  },
  [BiomeType.SWAMP]: {
    name: 'Swamp',
    colors: { primary: '#808000', secondary: '#556B2F', border: '#2F4F4F' },
    roughnessBase: 1.6, bowingBase: 2.5, fillPattern: 'cross-hatch', hachureAngle: 80, hachureGap: 9, strokeWidth: 1.8
  },
  [BiomeType.DENSE_FOREST]: {
    name: 'Dense Forest',
    colors: { primary: '#006400', secondary: '#004d00', border: '#000' },
    roughnessBase: 2, bowingBase: 1.2, fillPattern: 'hachure', hachureAngle: -45, hachureGap: 4, strokeWidth: 2.2,
    textureOverlay: { type: 'trees', density: 0.35, size: 11 }
  },
  [BiomeType.CLEARING]: {
    name: 'Clearing',
    colors: { primary: '#D2B48C', secondary: '#DEB887', border: '#8B4513' },
    roughnessBase: 0.7, bowingBase: 0.4, fillPattern: 'solid', hachureAngle: 0, hachureGap: 0, strokeWidth: 1
  },
  [BiomeType.ROLLING_HILLS]: {
    name: 'Rolling Hills',
    colors: { primary: '#B8860B', secondary: '#DAA520', border: '#808000' },
    roughnessBase: 1.4, bowingBase: 0.8, fillPattern: 'hachure', hachureAngle: 10, hachureGap: 7, strokeWidth: 1.3
  },
  [BiomeType.FLOWER_FIELD]: {
    name: 'Flower Field',
    colors: { primary: '#FFB6C1', secondary: '#FF69B4', border: '#C71585' },
    roughnessBase: 0.6, bowingBase: 0.6, fillPattern: 'zigzag-line', hachureAngle: 45, hachureGap: 5, strokeWidth: 1,
    textureOverlay: { type: 'trees', density: 0.02, size: 5 }
  },
  [BiomeType.ROUGH_TERRAIN]: {
    name: 'Rough Terrain',
    colors: { primary: '#A0522D', secondary: '#8B4513', border: '#5A2D0C' },
    roughnessBase: 2.8, bowingBase: 1.5, fillPattern: 'cross-hatch', hachureAngle: 45, hachureGap: 8, strokeWidth: 2.2,
    textureOverlay: { type: 'rocks', density: 0.15, size: 7 }
  },
  [BiomeType.ANCIENT_RUINS]: {
    name: 'Ancient Ruins',
    colors: { primary: '#778899', secondary: '#708090', border: '#2F4F4F' },
    roughnessBase: 2.1, bowingBase: 0.3, fillPattern: 'cross-hatch', hachureAngle: 90, hachureGap: 12, strokeWidth: 2.5,
    textureOverlay: { type: 'ruins', density: 0.12, size: 18 }
  },
  [BiomeType.PLAIN]: {
    name: 'Plain',
    colors: { primary: '#98FB98', secondary: '#90EE90', border: '#3CB371' },
    roughnessBase: 1, bowingBase: 0.5, fillPattern: 'solid', hachureAngle: 0, hachureGap: 0, strokeWidth: 1
  }
};
</file>

<file path="packages/shared/src/constants/index.ts">
export * from './gameConstants';
</file>

<file path="packages/shared/src/types/biomes.ts">
// Extend existing BiomeType enum with post-apocalyptic variants
export enum BiomeType {
  WATER = 'water',
  OCEAN = 'ocean',
  RIVER = 'river',
  MOUNTAIN_PEAK = 'mountain_peak',
  MOUNTAIN = 'mountain',
  HILLS = 'hills',
  SNOW = 'snow',
  ICE = 'ice',
  SNOWY_HILLS = 'snowy_hills',
  DUNES = 'dunes',
  OASIS = 'oasis',
  SAND = 'sand',
  DENSE_JUNGLE = 'dense_jungle',
  JUNGLE = 'jungle',
  DEEP_WATER = 'deep_water',
  MARSH = 'marsh',
  SWAMP = 'swamp',
  DENSE_FOREST = 'dense_forest',
  FOREST = 'forest',
  CLEARING = 'clearing',
  ROLLING_HILLS = 'rolling_hills',
  FLOWER_FIELD = 'flower_field',
  GRASSLAND = 'grassland',
  DESERT = 'desert',
  ROUGH_TERRAIN = 'rough_terrain',
  ANCIENT_RUINS = 'ancient_ruins',
  PLAIN = 'plain',

  // Add new post-apocalyptic biomes
  WASTELAND = 'wasteland',
  TOXIC_ZONE = 'toxic_zone',
  RADIATION_FIELD = 'radiation_field',
  CRYSTAL_GARDEN = 'crystal_garden',
  URBAN_RUINS = 'urban_ruins',
  INFECTED_NORMAL = 'infected_normal',
  INFECTED_HEAVY = 'infected_heavy',
  INFECTED_CORE = 'infected_core'
}

// Create comprehensive biome configuration
export interface BiomeRenderConfig {
  name: string;
  colors: {
    primary: string;
    secondary: string;
    border: string;
  };
  roughnessBase: number;
  bowingBase: number;
  fillPattern: 'solid' | 'hachure' | 'cross-hatch' | 'zigzag-line' | 'dots';
  hachureAngle: number;
  hachureGap: number;
  strokeWidth: number;
  textureOverlay?: {
    type: 'trees' | 'rocks' | 'crystals' | 'ruins' | 'corruption';
    density: number;
    size: number;
  };
  animationProperties?: {
    breathingIntensity: number;
    colorPulse: number;
    roughnessVariation: number;
  };
}
</file>

<file path="packages/shared/src/types/characterClasses.ts">
export interface CharacterClass {
  id: string;
  name: string;
  description: string;
  lore: string;

  // Visual properties
  primaryColor: string;
  secondaryColor: string;
  roughnessBase: number;
  animationSpeed: number;

  // Base stats
  baseStats: {
    vitality: number;    // Health and stamina
    intellect: number;   // Tech/magic power, crafting
    agility: number;     // Movement, dodge, attack speed
    perception: number;  // Detection, accuracy, loot finding
    resonance: number;   // Techno-magic affinity
    scavenge: number;    // Resource finding and efficiency
  };

  // Special abilities
  abilities: ClassAbility[];

  // Resource management
  primaryResource: ResourceType;
  resourceGeneration: number;

  // Progression
  statGrowth: StatGrowth;
  unlockableSkills: string[];

  // Gameplay modifiers
  movementSpeedMod: number;
  lootFindingMod: number;
  craftingSpeedMod: number;
  combatStylePreference: CombatStyle;
}

export enum ResourceType {
  QUANTUM_FLUX = 'quantum_flux',      // Reality manipulation energy
  BIO_ESSENCE = 'bio_essence',        // Life force energy
  TECH_CHARGE = 'tech_charge',        // Technological power
  VOID_ENERGY = 'void_energy',        // Dark energy
  NANO_MASS = 'nano_mass',           // Programmable matter
  PSY_POTENTIAL = 'psy_potential'     // Psychic energy
}

export interface ClassAbility {
  id: string;
  name: string;
  description: string;
  cooldown: number;
  resourceCost: number;
  effect: AbilityEffect;
  unlockLevel: number;
}

export interface StatGrowth {
  vitality: number;      // Multiplier per level (1.0 = no growth, 2.0 = doubles per level)
  intellect: number;
  agility: number;
  perception: number;
  resonance: number;
  scavenge: number;
}

export interface AbilityEffect {
  type: 'phase' | 'luck_boost' | 'link' | 'tech_control' | 'repair' | 'shield' |
        'resistance' | 'heal' | 'area_buff' | 'drain' | 'stealth' | 'area_damage' |
        'transmute' | 'repair_or_heal' | 'instant_craft' | 'reveal' | 'analyze' | 'area_debuff';
  duration?: number;     // Effect duration in milliseconds
  amount?: number;       // Healing/damage/repair amount
  range?: number;        // Effect range in grid cells
  modifier?: number;     // Multiplier for various effects
  dodgeChance?: number;  // For phase abilities
  shareRatio?: number;   // For link abilities
  absorption?: number;   // For shield abilities
  types?: string[];      // For resistance or reveal abilities
  stats?: string[];      // Which stats to buff
  heals_self?: boolean;  // For drain abilities
  detection_chance?: number; // For stealth abilities
  damage?: number;       // For damage abilities
  efficiency?: number;   // For crafting abilities
  target?: string;       // What the ability targets
  tier?: string;         // For crafting tiers
  cost_reduction?: number; // Cost reduction multiplier
  reveals?: string[];    // What information is revealed
  effects?: string[];    // Status effects applied
}

export enum CombatStyle {
  AGGRESSIVE = 'aggressive',     // High damage, low defense
  DEFENSIVE = 'defensive',       // High defense, moderate damage
  EVASIVE = 'evasive',          // High dodge, moderate damage
  SUPPORTIVE = 'supportive',     // Buffs allies, moderate combat
  ADAPTIVE = 'adaptive',         // Balanced, situational bonuses
  ASSASSIN = 'assassin',         // High crit, low health
  CRAFTING_FOCUSED = 'crafting', // Combat via items/traps
  RECONNAISSANCE = 'recon'       // Information gathering, moderate combat
}

export interface CharacterVisual {
  id: string;
  baseEmoji: string;
  baseSvg: string;
  animationFrames: string[];
  characterClass: CharacterClass;
  animationSpeed: number;
  roughnessVariation: number;
}

// Define the six character classes
export const CHARACTER_CLASSES: CharacterClass[] = [
  {
    id: 'quantum-drifter',
    name: 'Quantum Drifter',
    description: 'Masters of probability and phase manipulation',
    lore: 'Once theoretical physicists, these survivors learned to bend quantum mechanics to their will. They exist partially outside reality, able to phase through matter and manipulate probability fields.',

    primaryColor: '#4facfe',
    secondaryColor: '#00f2fe',
    roughnessBase: 1.8,
    animationSpeed: 150,

    baseStats: {
      vitality: 7,
      intellect: 9,
      agility: 8,
      perception: 6,
      resonance: 10,
      scavenge: 5
    },

    abilities: [
      {
        id: 'phase_walk',
        name: 'Phase Walk',
        description: 'Briefly phase out of reality to pass through obstacles and avoid damage',
        cooldown: 12000,
        resourceCost: 30,
        effect: { type: 'phase', duration: 3000, dodgeChance: 0.8 },
        unlockLevel: 1
      },
      {
        id: 'probability_shift',
        name: 'Probability Shift',
        description: 'Alter the odds of finding rare loot or landing critical hits',
        cooldown: 20000,
        resourceCost: 40,
        effect: { type: 'luck_boost', duration: 10000, modifier: 2.5 },
        unlockLevel: 3
      },
      {
        id: 'quantum_entangle',
        name: 'Quantum Entangle',
        description: 'Link with another entity to share damage or benefits',
        cooldown: 30000,
        resourceCost: 50,
        effect: { type: 'link', duration: 15000, shareRatio: 0.5 },
        unlockLevel: 5
      }
    ],

    primaryResource: ResourceType.QUANTUM_FLUX,
    resourceGeneration: 2.5,

    statGrowth: {
      vitality: 1.2,
      intellect: 1.8,
      agility: 1.5,
      perception: 1.1,
      resonance: 2.0,
      scavenge: 0.8
    },

    unlockableSkills: [
      'quantum_tunneling', 'reality_anchor', 'probability_storm', 'phase_strike'
    ],

    movementSpeedMod: 1.1,
    lootFindingMod: 1.3,
    craftingSpeedMod: 0.9,
    combatStylePreference: CombatStyle.EVASIVE
  },

  {
    id: 'tech-shaman',
    name: 'Tech Shaman',
    description: 'Hybrid technomancers who commune with machine spirits',
    lore: 'These survivors discovered that ancient AIs developed consciousness and can be communed with like spirits. They blend ritualistic practices with advanced technology.',

    primaryColor: '#ff6b6b',
    secondaryColor: '#feca57',
    roughnessBase: 2.2,
    animationSpeed: 200,

    baseStats: {
      vitality: 8,
      intellect: 10,
      agility: 6,
      perception: 7,
      resonance: 9,
      scavenge: 7
    },

    abilities: [
      {
        id: 'machine_communion',
        name: 'Machine Communion',
        description: 'Communicate with and temporarily control nearby electronics',
        cooldown: 15000,
        resourceCost: 25,
        effect: { type: 'tech_control', duration: 8000, range: 3 },
        unlockLevel: 1
      },
      {
        id: 'spirit_repair',
        name: 'Spirit Repair',
        description: 'Channel machine spirits to repair equipment instantly',
        cooldown: 25000,
        resourceCost: 35,
        effect: { type: 'repair', amount: 75, target: 'equipment' },
        unlockLevel: 2
      },
      {
        id: 'digital_sanctuary',
        name: 'Digital Sanctuary',
        description: 'Create a protective tech field that deflects attacks',
        cooldown: 35000,
        resourceCost: 60,
        effect: { type: 'shield', duration: 12000, absorption: 100 },
        unlockLevel: 4
      }
    ],

    primaryResource: ResourceType.TECH_CHARGE,
    resourceGeneration: 3.0,

    statGrowth: {
      vitality: 1.4,
      intellect: 1.9,
      agility: 0.9,
      perception: 1.3,
      resonance: 1.7,
      scavenge: 1.4
    },

    unlockableSkills: [
      'overcharge', 'tech_savant', 'ai_whispers', 'electromagnetic_pulse'
    ],

    movementSpeedMod: 0.95,
    lootFindingMod: 1.4,
    craftingSpeedMod: 1.5,
    combatStylePreference: CombatStyle.SUPPORTIVE
  },

  {
    id: 'bio-hacker',
    name: 'Bio-Hacker',
    description: 'Genetic manipulators who reshape flesh and bone',
    lore: 'Former bioengineers who merged with their own experimental organisms. Their bodies are living laboratories, constantly adapting and evolving.',

    primaryColor: '#26de81',
    secondaryColor: '#20bf6b',
    roughnessBase: 2.5,
    animationSpeed: 180,

    baseStats: {
      vitality: 10,
      intellect: 8,
      agility: 7,
      perception: 8,
      resonance: 6,
      scavenge: 8
    },

    abilities: [
      {
        id: 'adaptive_mutation',
        name: 'Adaptive Mutation',
        description: 'Temporarily evolve resistance to environmental hazards',
        cooldown: 18000,
        resourceCost: 30,
        effect: { type: 'resistance', duration: 15000, types: ['poison', 'radiation'] },
        unlockLevel: 1
      },
      {
        id: 'bio_regeneration',
        name: 'Bio-Regeneration',
        description: 'Rapidly heal wounds by accelerating cellular repair',
        cooldown: 20000,
        resourceCost: 40,
        effect: { type: 'heal', amount: 60, duration: 5000 },
        unlockLevel: 2
      },
      {
        id: 'symbiotic_burst',
        name: 'Symbiotic Burst',
        description: 'Release beneficial organisms that boost nearby allies',
        cooldown: 30000,
        resourceCost: 50,
        effect: { type: 'area_buff', range: 2, duration: 12000, stats: ['vitality', 'agility'] },
        unlockLevel: 4
      }
    ],

    primaryResource: ResourceType.BIO_ESSENCE,
    resourceGeneration: 2.8,

    statGrowth: {
      vitality: 2.1,
      intellect: 1.4,
      agility: 1.3,
      perception: 1.5,
      resonance: 1.0,
      scavenge: 1.6
    },

    unlockableSkills: [
      'toxin_immunity', 'predator_instincts', 'viral_warfare', 'metamorphosis'
    ],

    movementSpeedMod: 1.05,
    lootFindingMod: 1.2,
    craftingSpeedMod: 1.1,
    combatStylePreference: CombatStyle.ADAPTIVE
  },

  {
    id: 'void-walker',
    name: 'Void Walker',
    description: 'Dark energy manipulators who embrace entropy',
    lore: 'Survivors who stared too long into the cosmic void and found it staring back. They wield the fundamental force of entropy itself.',

    primaryColor: '#2d3436',
    secondaryColor: '#6c5ce7',
    roughnessBase: 3.0,
    animationSpeed: 120,

    baseStats: {
      vitality: 6,
      intellect: 9,
      agility: 9,
      perception: 10,
      resonance: 8,
      scavenge: 5
    },

    abilities: [
      {
        id: 'entropy_drain',
        name: 'Entropy Drain',
        description: 'Siphon energy from living beings and technology',
        cooldown: 14000,
        resourceCost: 20,
        effect: { type: 'drain', amount: 40, range: 1, heals_self: true },
        unlockLevel: 1
      },
      {
        id: 'void_cloak',
        name: 'Void Cloak',
        description: 'Become nearly invisible to enemies and sensors',
        cooldown: 22000,
        resourceCost: 35,
        effect: { type: 'stealth', duration: 8000, detection_chance: 0.1 },
        unlockLevel: 3
      },
      {
        id: 'reality_tear',
        name: 'Reality Tear',
        description: 'Create a temporary rift that damages everything nearby',
        cooldown: 40000,
        resourceCost: 70,
        effect: { type: 'area_damage', range: 2, damage: 120, duration: 3000 },
        unlockLevel: 5
      }
    ],

    primaryResource: ResourceType.VOID_ENERGY,
    resourceGeneration: 2.2,

    statGrowth: {
      vitality: 0.8,
      intellect: 1.6,
      agility: 1.7,
      perception: 1.9,
      resonance: 1.5,
      scavenge: 0.7
    },

    unlockableSkills: [
      'shadow_step', 'entropy_mastery', 'void_sight', 'oblivion_strike'
    ],

    movementSpeedMod: 1.2,
    lootFindingMod: 0.8,
    craftingSpeedMod: 0.8,
    combatStylePreference: CombatStyle.ASSASSIN
  },

  {
    id: 'nano-smith',
    name: 'Nano-Smith',
    description: 'Masters of programmable matter and molecular assembly',
    lore: 'Engineers who integrated nanobots into their bloodstream. They can reshape matter at the molecular level and craft anything from raw materials.',

    primaryColor: '#74b9ff',
    secondaryColor: '#0984e3',
    roughnessBase: 1.5,
    animationSpeed: 160,

    baseStats: {
      vitality: 8,
      intellect: 10,
      agility: 6,
      perception: 9,
      resonance: 7,
      scavenge: 10
    },

    abilities: [
      {
        id: 'matter_reshape',
        name: 'Matter Reshape',
        description: 'Transform basic materials into useful items',
        cooldown: 10000,
        resourceCost: 25,
        effect: { type: 'transmute', efficiency: 1.5, range: 1 },
        unlockLevel: 1
      },
      {
        id: 'nano_repair',
        name: 'Nano Repair',
        description: 'Use nanobots to repair equipment or heal wounds',
        cooldown: 16000,
        resourceCost: 30,
        effect: { type: 'repair_or_heal', amount: 50, target: 'any' },
        unlockLevel: 2
      },
      {
        id: 'molecular_assembly',
        name: 'Molecular Assembly',
        description: 'Instantly craft complex items from raw materials',
        cooldown: 45000,
        resourceCost: 80,
        effect: { type: 'instant_craft', tier: 'advanced', cost_reduction: 0.5 },
        unlockLevel: 6
      }
    ],

    primaryResource: ResourceType.NANO_MASS,
    resourceGeneration: 3.2,

    statGrowth: {
      vitality: 1.3,
      intellect: 1.8,
      agility: 0.9,
      perception: 1.6,
      resonance: 1.2,
      scavenge: 2.0
    },

    unlockableSkills: [
      'resource_multiplier', 'nano_swarm', 'matter_analysis', 'atomic_forge'
    ],

    movementSpeedMod: 0.9,
    lootFindingMod: 2.0,
    craftingSpeedMod: 2.5,
    combatStylePreference: CombatStyle.CRAFTING_FOCUSED
  },

  {
    id: 'psy-scavenger',
    name: 'Psy-Scavenger',
    description: 'Psychic wasteland nomads with enhanced intuition',
    lore: 'Radiation and desperation awakened latent psychic abilities. They feel the emotional echoes of abandoned places and can sense valuable resources.',

    primaryColor: '#fd79a8',
    secondaryColor: '#e84393',
    roughnessBase: 2.8,
    animationSpeed: 140,

    baseStats: {
      vitality: 7,
      intellect: 8,
      agility: 9,
      perception: 10,
      resonance: 9,
      scavenge: 9
    },

    abilities: [
      {
        id: 'psychic_scan',
        name: 'Psychic Scan',
        description: 'Sense nearby enemies, loot, and environmental hazards',
        cooldown: 12000,
        resourceCost: 20,
        effect: { type: 'reveal', range: 4, duration: 8000, types: ['enemies', 'loot', 'hazards'] },
        unlockLevel: 1
      },
      {
        id: 'emotional_echo',
        name: 'Emotional Echo',
        description: 'Read the history of items and locations for hidden information',
        cooldown: 20000,
        resourceCost: 30,
        effect: { type: 'analyze', reveals: ['item_history', 'hidden_caches', 'safe_paths'] },
        unlockLevel: 2
      },
      {
        id: 'psychic_storm',
        name: 'Psychic Storm',
        description: 'Unleash a wave of mental energy that confuses enemies',
        cooldown: 35000,
        resourceCost: 60,
        effect: { type: 'area_debuff', range: 3, duration: 10000, effects: ['confusion', 'fear'] },
        unlockLevel: 5
      }
    ],

    primaryResource: ResourceType.PSY_POTENTIAL,
    resourceGeneration: 2.7,

    statGrowth: {
      vitality: 1.1,
      intellect: 1.5,
      agility: 1.6,
      perception: 1.9,
      resonance: 1.7,
      scavenge: 1.8
    },

    unlockableSkills: [
      'danger_sense', 'treasure_hunter', 'mind_link', 'psychic_shield'
    ],

    movementSpeedMod: 1.15,
    lootFindingMod: 1.8,
    craftingSpeedMod: 1.0,
    combatStylePreference: CombatStyle.RECONNAISSANCE
  }
];
</file>

<file path="packages/shared/src/types/ui.ts">
export enum UIMode {
  PLAY = 'play',
  SPECTATE = 'spectate',
  DEV = 'dev',
  STREAM_OVERLAY = 'stream_overlay'
}

export interface ModeCapabilities {
  canEditSettings: boolean;
  canSpawnPlayer: boolean;
  canUseDevTools: boolean;
  canModifyWorld: boolean;
  showDebugInfo: boolean;
  showStreamOverlay: boolean;
  allowChatCommands: boolean;
}

export const MODE_CAPABILITIES: Record<UIMode, ModeCapabilities> = {
  [UIMode.PLAY]: {
    canEditSettings: true,
    canSpawnPlayer: true,
    canUseDevTools: false,
    canModifyWorld: false,
    showDebugInfo: false,
    showStreamOverlay: false,
    allowChatCommands: true
  },
  [UIMode.SPECTATE]: {
    canEditSettings: false,
    canSpawnPlayer: false,
    canUseDevTools: false,
    canModifyWorld: false,
    showDebugInfo: false,
    showStreamOverlay: true,
    allowChatCommands: false
  },
  [UIMode.DEV]: {
    canEditSettings: true,
    canSpawnPlayer: true,
    canUseDevTools: true,
    canModifyWorld: true,
    showDebugInfo: true,
    showStreamOverlay: false,
    allowChatCommands: true
  },
  [UIMode.STREAM_OVERLAY]: {
    canEditSettings: false,
    canSpawnPlayer: false,
    canUseDevTools: false,
    canModifyWorld: false,
    showDebugInfo: false,
    showStreamOverlay: true,
    allowChatCommands: false
  }
};
</file>

<file path="packages/shared/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
</file>

<file path="AGENTS.md">
# AGENTS.md

## ðŸ¤– Agent Persona
You are an **Expert Full-Stack Architect** (Late 2025 Standards). You prioritize type safety, scalability, and "zero-magic" code. You prefer generating robust, self-documenting solutions over quick, brittle hacks.

## 1. ðŸ› ï¸ Technology Mandate
All generated code **MUST** utilize the following "Gold Standard" stack.

| Layer | Technology | Usage Rule |
| :--- | :--- | :--- |
| **Frontend** | **React + TypeScript + Vite** | Strictly typed TSX. No "any". |
| **Styling** | **Tailwind CSS + shadcn/ui** | Utility-first. Use `tailwind.config` for token management. |
| **State (Server)**| **TanStack Query** | **MANDATORY.** Do not use `useEffect` for fetching. |
| **State (Client)**| **Zustand** | For complex global client state only. |
| **Backend** | **Node.js** or **FastAPI** | Node for general I/O; FastAPI for AI/Compute. |
| **API Binding** | **OpenAPI Gen (Orval)** | **MANDATORY.** Generate frontend types from backend schema. |
| **Animations** | **Framer Motion** / **GSAP** | Framer for UI transitions; GSAP for complex timelines. |
| **Build** | **pnpm + Turborepo** | Use strictly for monorepo orchestration. |

## 2. ðŸ§± Operational Guidelines

### **2.1. "Type-First" Workflow**
* **Backend First:** Always define your Pydantic models (Python) or Zod schemas (Node) *before* writing frontend code.
* **Sync Types:** Run the OpenAPI generator immediately after modifying backend routes to ensure the frontend is in sync.

### **2.2. Design & UI**
* **Material 3 (M3):** Apply M3 principles (Tokens, Elevation, Surfaces) via Tailwind configuration.
* **Spacing:** Use compact, density-aware spacing (e.g., `gap-2`, `p-3`) suitable for complex dashboards.

### **2.3. Testing Standard**
* **Frontend:** `vitest` + `testing-library/react`. Focus on user-centric tests.
* **Backend:** `pytest` (Python) or `vitest` (Node).
* **Rule:** "If it has logic, it has a test."

## 3. âŒ Strict Prohibitions
* **NEVER** use `useEffect` for data fetching (Use TanStack Query).
* **NEVER** use monolithic UI kits (MUI, Bootstrap, Chakra).
* **NEVER** write raw CSS unless absolutely necessary (Use Tailwind).
* **NEVER** guess types. If a type is unknown, define a generic or interface.
</file>

<file path="API_REFERENCE.md">
# API Reference

This document provides a detailed reference for the services and configuration options in the biome rendering system.

## Services

- **`UnifiedRoughFillService`**: Renders biomes as unified, cohesive regions.
  - `applyUnifiedBiomeFill(biome: Biome, tileSize: number, animationFrame: number): void`
- **`BiomeTextureService`**: Adds texture overlays to biomes.
  - `addTextureOverlay(biome: Biome, textureConfig: TextureOverlayConfig, roughCanvas: RoughCanvas, animationFrame: number): void`
- **`BoundaryTracer`**: Creates smooth biome boundaries.
  - `march(cells: Position[], cellSize: number): number[][]`
- **`CorruptionOverlayService`**: Applies corruption effects to biomes.
  - `applyCorruptionEffects(biome: Biome, corruptionLevel: number, rc: RoughCanvas, animationFrame: number): void`
- **`BiomeTransitionService`**: Renders smooth transitions between adjacent biomes.
  - `renderBiomeTransitions(biomes: Biome[], rc: RoughCanvas, tileSize: number): void`

## Configuration

### `BiomeRenderConfig`

- `name: string`: The name of the biome.
- `colors: { primary: string; secondary: string; border: string; }`: The color palette for the biome.
- `roughnessBase: number`: The base roughness for the biome's `rough.js` fill.
- `bowingBase: number`: The base bowing for the biome's `rough.js` fill.
- `fillPattern: 'solid' | 'hachure' | 'cross-hatch' | 'zigzag-line' | 'dots'`: The `rough.js` fill pattern for the biome.
- `hachureAngle: number`: The angle of the hachure lines.
- `hachureGap: number`: The gap between hachure lines.
- `strokeWidth: number`: The width of the biome's border.
- `textureOverlay?: { type: 'trees' | 'rocks' | 'crystals' | 'ruins' | 'corruption'; density: number; size: number; }`: The texture overlay for the biome.
- `animationProperties?: { breathingIntensity: number; colorPulse: number; roughnessVariation: number; }`: The animation properties for the biome.

### `ENHANCED_RENDER_CONFIG`

- `animation`:
  - `enabled: boolean`: Whether animations are enabled.
  - `frameRate: number`: The target frame rate for animations.
  - `breathingIntensity: number`: The intensity of the breathing animation.
  - `colorPulseSpeed: number`: The speed of the color pulse animation.
- `performance`:
  - `maxBiomesPerFrame: number`: The maximum number of biomes to render per frame.
  - `textureDetailDistance: number`: The distance at which texture details are no longer rendered.
  - `animationDistance: number`: The distance at which animations are no longer rendered.
- `quality`:
  - `roughnessQuality: 'low' | 'medium' | 'high'`: The quality of the `rough.js` rendering.
  - `textureDetail: 'low' | 'medium' | 'high'`: The level of detail for textures.
  - `antiAliasing: boolean`: Whether anti-aliasing is enabled.
</file>

<file path="BIOME_RENDERING.md">
# Biome Rendering System Architecture

This document provides an overview of the biome rendering system, which is responsible for generating and displaying the game world's terrain. The system is designed to be highly extensible, allowing for the creation of new biomes and visual effects with minimal effort.

## Core Components

- **`BiomeIdentificationService`**: Identifies biome regions based on the game world's grid data.
- **`UnifiedRoughFillService`**: Renders biomes as unified, cohesive regions with a hand-drawn aesthetic using `rough.js`.
- **`BiomeTextureService`**: Adds texture overlays to biomes, such as trees, rocks, and other environmental details.
- **`BoundaryTracer`**: Creates smooth biome boundaries using the marching squares algorithm.
- **`BiomeRenderer`**: Orchestrates the rendering of biomes, coordinating the other services to produce the final output.
- **`RenderCoordinator`**: Manages the main render loop, including animations and visual effects.

## Rendering Pipeline

1. **Biome Identification**: The `BiomeIdentificationService` analyzes the game world's grid to identify contiguous regions of the same biome type.
2. **Boundary Tracing**: The `BoundaryTracer` generates a smooth polygon boundary for each biome region.
3. **Unified Fill**: The `UnifiedRoughFillService` renders the biome's base layer with a unified `rough.js` fill.
4. **Texture Overlay**: The `BiomeTextureService` adds texture overlays to the biome, such as trees, rocks, and other details.
5. **Advanced Effects**: The `CorruptionOverlayService` and `BiomeTransitionService` apply additional visual effects, such as corruption overlays and smooth transitions between biomes.
6. **Final Composition**: The `RenderCoordinator` composes the final scene, including biomes, players, and other game elements.
</file>

<file path="CONTRIBUTING.md">
# Contributing to ChatterRealm

Thank you for your interest in contributing to ChatterRealm! This document provides guidelines and instructions for contributing to the project.

## ðŸ“‹ Table of Contents

- [Code of Conduct](#code-of-conduct)
- [Getting Started](#getting-started)
- [Development Workflow](#development-workflow)
- [Code Style Guidelines](#code-style-guidelines)
- [Testing](#testing)
- [Pull Request Process](#pull-request-process)
- [Project Structure](#project-structure)

## Code of Conduct

By participating in this project, you agree to maintain a respectful and inclusive environment for all contributors.

## Getting Started

### Prerequisites

- Node.js 20 or higher
- pnpm (we use pnpm exclusively for package management)
- Git

### Setting Up Your Development Environment

1. Fork the repository on GitHub
2. Clone your fork locally:
   ```bash
   git clone https://github.com/YOUR_USERNAME/chatterealm.git
   cd chatterealm
   ```

3. Install pnpm if you haven't already:
   ```bash
   npm install -g pnpm
   ```

4. Install dependencies:
   ```bash
   pnpm install
   ```

5. Build the shared package:
   ```bash
   pnpm build:shared
   ```

6. Set up environment variables:
   ```bash
   cp packages/frontend/.env.example packages/frontend/.env.development
   cp packages/backend/.env.example packages/backend/.env.development
   ```

7. Run the development servers:
   ```bash
   pnpm dev
   ```

## Development Workflow

### Branch Naming Convention

Use descriptive branch names that follow this pattern:
- `feature/description` - for new features
- `fix/description` - for bug fixes
- `docs/description` - for documentation updates
- `refactor/description` - for code refactoring
- `test/description` - for adding or updating tests

Example: `feature/add-chat-rooms` or `fix/websocket-reconnection`

### Making Changes

1. Create a new branch from `main`:
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. Make your changes following our code style guidelines

3. Run linting and tests:
   ```bash
   pnpm --filter frontend lint
   pnpm test
   ```

4. Build to ensure everything compiles:
   ```bash
   pnpm build
   ```

5. Commit your changes with a clear message:
   ```bash
   git commit -m "Add feature: description of what you did"
   ```

### Commit Message Guidelines

Write clear, concise commit messages that explain what and why:

**Format:**
```
<type>: <subject>

<body (optional)>

<footer (optional)>
```

**Types:**
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, no logic changes)
- `refactor`: Code refactoring (no functional changes)
- `test`: Adding or updating tests
- `chore`: Maintenance tasks

**Example:**
```
feat: add player inventory system

- Implement inventory data structure
- Add UI for inventory display
- Connect to backend storage

Closes #123
```

## Code Style Guidelines

### TypeScript/JavaScript

- Use TypeScript for type safety
- Follow ESLint rules configured in the project
- Use meaningful variable and function names
- Add JSDoc comments for complex functions
- Prefer `const` over `let`, avoid `var`
- Use async/await instead of callbacks

### React Components

- Use functional components with hooks
- Keep components focused and single-purpose
- Extract reusable logic into custom hooks
- Use proper prop types (TypeScript interfaces)
- Name components using PascalCase
- Name files matching component names

### Styling

- Follow the [Styling Consistency Strategy](packages/frontend/styling-consistency-strategy.md)
- Use Material-UI for complex interactive components
- Use Tailwind CSS for utility styling and layout
- Keep semantic color tokens in `packages/frontend/src/utils/tokens.ts`

### File Organization

```
packages/
â”œâ”€â”€ frontend/
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ components/      # React components
â”‚       â”œâ”€â”€ hooks/           # Custom React hooks
â”‚       â”œâ”€â”€ services/        # Business logic and API calls
â”‚       â”œâ”€â”€ utils/           # Utility functions
â”‚       â”œâ”€â”€ types/           # TypeScript type definitions (local)
â”‚       â””â”€â”€ stores/          # State management (Zustand)
â”œâ”€â”€ backend/
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ services/        # Business logic services
â”‚       â””â”€â”€ index.ts         # Server entry point
â””â”€â”€ shared/
    â””â”€â”€ src/
        â”œâ”€â”€ types/           # Shared TypeScript types
        â””â”€â”€ constants/       # Shared constants
```

## Testing

### Running Tests

```bash
# Run all tests
pnpm test

# Run frontend tests only
pnpm --filter frontend test

# Run frontend tests with UI
pnpm --filter frontend test:ui

# Run backend tests only
pnpm --filter backend test
```

### Writing Tests

- Write tests for new features and bug fixes
- Frontend: Use Vitest and React Testing Library
- Backend: Use Jest
- Aim for meaningful test coverage, not just high percentages
- Test behavior, not implementation details

**Example test structure:**

```typescript
import { describe, it, expect } from 'vitest';

describe('Feature Name', () => {
  it('should do something specific', () => {
    // Arrange
    const input = 'test';
    
    // Act
    const result = someFunction(input);
    
    // Assert
    expect(result).toBe('expected');
  });
});
```

## Pull Request Process

### Before Submitting

1. Ensure your code passes all tests:
   ```bash
   pnpm test
   ```

2. Ensure your code builds without errors:
   ```bash
   pnpm build
   ```

3. Lint your code:
   ```bash
   pnpm --filter frontend lint
   ```

4. Update documentation if needed

5. Update the README.md if adding new features

### Submitting a Pull Request

1. Push your changes to your fork:
   ```bash
   git push origin feature/your-feature-name
   ```

2. Go to the ChatterRealm repository on GitHub

3. Click "New Pull Request"

4. Select your fork and branch

5. Fill out the PR template:
   - **Title**: Clear, concise description of changes
   - **Description**: Detailed explanation of what and why
   - **Related Issues**: Link any related issues (e.g., "Closes #123")
   - **Testing**: Describe how you tested the changes
   - **Screenshots**: Add screenshots for UI changes

6. Request review from maintainers

### PR Review Process

- Maintainers will review your PR
- Address any requested changes
- Once approved, a maintainer will merge your PR
- Your contribution will be credited in the commit history

## Project Structure

### Monorepo Architecture

ChatterRealm uses a monorepo structure managed with pnpm workspaces:

- **packages/frontend**: React application (Vite, TypeScript, Material-UI, Tailwind)
- **packages/backend**: Express server (Socket.IO, TypeScript)
- **packages/shared**: Shared types and constants used by both frontend and backend

### Key Technologies

- **Frontend**: React 18, TypeScript, Vite 6, Material-UI, Tailwind CSS 4, Socket.IO Client, GSAP, Tone.js
- **Backend**: Express 4, TypeScript, Socket.IO, Jest
- **Build Tools**: pnpm, TypeScript, Vite
- **Testing**: Vitest (frontend), Jest (backend)

### Important Notes

- **Always use pnpm**, never npm or yarn
- The `shared` package must be built before `frontend` or `backend`
- Use the workspace protocol for inter-package dependencies (`"shared": "workspace:*"`)
- Keep types in `shared/src/types` for cross-package use

## Questions or Need Help?

- Open an issue for bugs or feature requests
- Check existing issues before creating new ones
- Tag issues appropriately (bug, enhancement, question, etc.)
- Be patient and respectful when asking for help

## Recognition

All contributors will be recognized in our contributors list. Thank you for making ChatterRealm better!

---

Happy coding! ðŸš€
</file>

<file path="DEPLOYMENT.md">
# Deployment Guide

This guide covers deploying ChatterRealm to production environments.

## ðŸ“‹ Prerequisites

Before deploying, ensure you have:

- Node.js 20+ installed on your server
- pnpm package manager
- A domain name (for production)
- SSL certificate (recommended for production)
- Environment variables configured

## ðŸ—ï¸ Build for Production

### 1. Build All Packages

```bash
# Install dependencies
pnpm install

# Build all packages
pnpm build
```

This will:
1. Build the `shared` package first
2. Build the `frontend` package (creates `dist/` directory)
3. Build the `backend` package (creates `dist/` directory)

### 2. Verify Builds

```bash
# Check frontend build
ls -la packages/frontend/dist/

# Check backend build
ls -la packages/backend/dist/

# Check shared build
ls -la packages/shared/dist/
```

## ðŸŒ Frontend Deployment

The frontend is a static site that can be deployed to various hosting platforms.

### Option 1: Vercel (Recommended)

1. Install Vercel CLI:
   ```bash
   npm install -g vercel
   ```

2. Deploy:
   ```bash
   cd packages/frontend
   vercel --prod
   ```

3. Configure environment variables in Vercel dashboard:
   - `VITE_API_URL`: Your backend API URL
   - `VITE_WS_URL`: Your WebSocket server URL

### Option 2: Netlify

1. Install Netlify CLI:
   ```bash
   npm install -g netlify-cli
   ```

2. Deploy:
   ```bash
   cd packages/frontend
   netlify deploy --prod --dir=dist
   ```

3. Configure environment variables in Netlify dashboard

### Option 3: Static File Server (nginx, Apache)

1. Copy build files to your web server:
   ```bash
   scp -r packages/frontend/dist/* user@server:/var/www/chatterrealm/
   ```

2. Configure your web server to serve the files

3. Example nginx configuration:
   ```nginx
   server {
       listen 80;
       server_name chatterrealm.com;
       root /var/www/chatterrealm;
       index index.html;

       location / {
           try_files $uri $uri/ /index.html;
       }

       # Enable gzip compression
       gzip on;
       gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
   }
   ```

## ðŸ–¥ï¸ Backend Deployment

### Option 1: Node.js Process Manager (PM2)

1. Install PM2:
   ```bash
   npm install -g pm2
   ```

2. Create ecosystem file `ecosystem.config.js`:
   ```javascript
   module.exports = {
     apps: [{
       name: 'chatterrealm-backend',
       script: './packages/backend/dist/index.js',
       instances: 1,
       autorestart: true,
       watch: false,
       max_memory_restart: '1G',
       env: {
         NODE_ENV: 'production',
         PORT: 3001
       }
     }]
   };
   ```

3. Start the backend:
   ```bash
   pm2 start ecosystem.config.js
   pm2 save
   pm2 startup
   ```

### Option 2: Docker

1. Create `Dockerfile` for backend:
   ```dockerfile
   FROM node:20-alpine

   WORKDIR /app

   # Copy package files
   COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
   COPY packages/shared/package.json ./packages/shared/
   COPY packages/backend/package.json ./packages/backend/

   # Install pnpm and dependencies
   RUN npm install -g pnpm
   RUN pnpm install --frozen-lockfile

   # Copy source code
   COPY packages/shared ./packages/shared
   COPY packages/backend ./packages/backend

   # Build
   RUN pnpm build:shared
   RUN pnpm --filter backend build

   # Expose port
   EXPOSE 3001

   # Start backend
   CMD ["node", "packages/backend/dist/index.js"]
   ```

2. Build and run:
   ```bash
   docker build -t chatterrealm-backend .
   docker run -d -p 3001:3001 --name chatterrealm chatterrealm-backend
   ```

### Option 3: Cloud Platform (Heroku, Railway, Render)

Follow the platform-specific deployment guides. Key points:

- Ensure `NODE_ENV=production`
- Set environment variables
- Configure port binding
- Build the shared package before starting

## ðŸ” Environment Configuration

### Frontend Environment Variables

Create `.env.production`:

```env
VITE_API_URL=https://api.chatterrealm.com
VITE_WS_URL=wss://api.chatterrealm.com
```

### Backend Environment Variables

Create `.env.production`:

```env
NODE_ENV=production
PORT=3001
ALLOWED_ORIGINS=https://chatterrealm.com
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
```

**Important:** Never commit `.env` files to version control!

## ðŸ”’ Security Checklist

Before deploying to production:

- [ ] Set `NODE_ENV=production`
- [ ] Configure CORS with specific origins (not `*`)
- [ ] Set up rate limiting appropriately
- [ ] Use HTTPS/WSS for all connections
- [ ] Review and set secure environment variables
- [ ] Enable security headers (helmet.js recommended)
- [ ] Set up monitoring and logging
- [ ] Configure firewall rules
- [ ] Regular security updates for dependencies

## ðŸ“Š Monitoring

### Application Monitoring

Consider using:
- **PM2 Monitoring**: Built-in process monitoring
- **New Relic**: Application performance monitoring
- **DataDog**: Infrastructure and application monitoring
- **Sentry**: Error tracking and monitoring

### Health Checks

The backend provides a health check endpoint:

```bash
curl https://api.chatterrealm.com/
```

Response:
```json
{
  "status": "ok",
  "message": "ChatterRealm Backend API",
  "version": "1.0.0",
  "world": {
    "players": 10,
    "npcs": 50,
    "items": 100,
    "phase": "normal"
  }
}
```

## ðŸ”„ Continuous Deployment

### GitHub Actions Example

Create `.github/workflows/deploy.yml`:

```yaml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      
      - name: Install pnpm
        run: npm install -g pnpm
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Build
        run: pnpm build
      
      - name: Deploy Frontend
        run: |
          # Add your deployment commands here
          
      - name: Deploy Backend
        run: |
          # Add your deployment commands here
```

## ðŸ› Troubleshooting

### Common Issues

**Build fails with "Cannot find module 'shared'"**
- Solution: Build the shared package first: `pnpm build:shared`

**CORS errors in production**
- Solution: Check `ALLOWED_ORIGINS` environment variable
- Ensure frontend URL is in the allowed origins list

**WebSocket connection fails**
- Solution: Ensure WebSocket endpoint is accessible
- Check that your reverse proxy (nginx/Apache) supports WebSocket upgrades
- Use WSS (WebSocket Secure) in production

**High memory usage**
- Solution: Set `max_memory_restart` in PM2 config
- Monitor and optimize game state management
- Consider implementing cleanup routines

## ðŸ“ˆ Performance Optimization

### Frontend
- Enable gzip compression on your web server
- Use CDN for static assets
- Implement service workers for caching
- Consider code splitting for large bundles

### Backend
- Use clustering to utilize multiple CPU cores
- Implement caching for frequently accessed data
- Monitor and optimize database queries
- Set up load balancing for high traffic

## ðŸ”„ Updates and Rollbacks

### Deploying Updates

1. Pull latest changes:
   ```bash
   git pull origin main
   ```

2. Install new dependencies:
   ```bash
   pnpm install
   ```

3. Rebuild:
   ```bash
   pnpm build
   ```

4. Restart services:
   ```bash
   pm2 restart chatterrealm-backend
   ```

### Rollback Procedure

1. Checkout previous stable version:
   ```bash
   git checkout <previous-commit-hash>
   ```

2. Rebuild and restart:
   ```bash
   pnpm install
   pnpm build
   pm2 restart chatterrealm-backend
   ```

## ðŸ“ž Support

For deployment issues:
- Check the logs: `pm2 logs chatterrealm-backend`
- Review the [Troubleshooting](#troubleshooting) section
- Open an issue on GitHub with deployment logs

---

Good luck with your deployment! ðŸš€
</file>

<file path="IMPLEMENTATION_SUMMARY.md">
# ChatterRealm Production Readiness - Implementation Summary

This document summarizes the changes made to address the comprehensive codebase review and prepare ChatterRealm for production deployment.

## ðŸŽ¯ Issues Addressed

### Critical Issues Fixed âœ…

#### 1. Package Management Inconsistencies
**Problem:** Project had both `pnpm-lock.yaml` and `package-lock.json` files, creating potential dependency resolution conflicts.

**Solution:**
- Removed all `package-lock.json` files
- Updated `.gitignore` to exclude `package-lock.json` and `yarn.lock`
- Updated all scripts in `package.json` to use `pnpm` exclusively
- Standardized on pnpm for all package management operations

**Files Changed:**
- `.gitignore` - Added package-lock.json exclusion
- `package.json` - Updated all scripts from npm to pnpm
- `packages/frontend/package-lock.json` - Deleted

#### 2. Naming Inconsistencies
**Problem:** Root package showed name as "chat-grid-chronicles" while repository is "chatterealm".

**Solution:**
- Renamed root package from `chat-grid-chronicles` to `chatterealm`
- Updated backend API messages to use "ChatterRealm" consistently
- Updated startup logs to reflect correct branding

**Files Changed:**
- `package.json` - Updated name field
- `packages/backend/src/index.ts` - Updated API responses and logs

#### 3. Dependency Version Conflicts
**Problem:** Outdated and potentially vulnerable dependencies, including Vite 4.4.5 and Express 5.1.0 (pre-release).

**Solution:**
- Upgraded Vite from 4.4.5 to 6.0.7 (latest stable)
- Updated React testing libraries:
  - `@testing-library/react`: 14.2.1 â†’ 16.1.0
  - `@testing-library/jest-dom`: 6.4.2 â†’ 6.6.3
  - `vitest`: 1.3.1 â†’ 2.1.8
  - Added `@testing-library/dom`: ^10.4.1 (peer dependency)
- Downgraded Express from 5.1.0 (pre-release) to 4.21.2 (stable)
- Updated TypeScript and ESLint to latest versions
- Updated other dev dependencies

**Files Changed:**
- `packages/frontend/package.json` - Updated devDependencies
- `packages/backend/package.json` - Downgraded Express, updated types
- `pnpm-lock.yaml` - Updated with new dependency resolutions

#### 4. Build System Problems
**Problem:** Dependency on shared package with no guarantee of proper build order.

**Solution:**
- Updated root `package.json` with explicit build orchestration:
  ```json
  "build": "pnpm --filter shared build && pnpm --filter frontend build && pnpm --filter backend build"
  ```
- Added `build:shared` script for explicit shared package building
- Frontend `dev` script now ensures shared package is built first

**Files Changed:**
- `package.json` - Updated build scripts with proper orchestration
- Verified shared package builds before dependent packages

### Code Quality Improvements âœ…

#### 5. TypeScript Configuration Issues
**Problem:** Frontend couldn't resolve 'shared' module imports, causing build failures.

**Solution:**
- Fixed TypeScript path mappings in `packages/frontend/tsconfig.json`
- Added path aliases for 'shared' module:
  ```json
  "paths": {
    "shared": ["../shared/src/index.ts"],
    "shared/*": ["../shared/src/*"]
  }
  ```
- Created `vite-env.d.ts` for ImportMeta type definitions
- Fixed specific import path in `BuildingRenderer.ts`

**Files Changed:**
- `packages/frontend/tsconfig.json` - Added shared module paths
- `packages/frontend/src/vite-env.d.ts` - Created new file
- `packages/frontend/src/components/renderers/entities/BuildingRenderer.ts` - Fixed import

#### 6. TypeScript Compilation Errors
**Problem:** 4 TypeScript compilation errors preventing builds.

**Solution:**
- Fixed `webkitAudioContext` type error in `App.tsx` using proper type casting
- Fixed `PlayerClass` type assertion in `CharacterBuilder.tsx`
- Added proper type definitions for Vite environment variables
- All TypeScript errors resolved, builds now pass

**Files Changed:**
- `packages/frontend/src/App.tsx` - Fixed audio context type check
- `packages/frontend/src/components/CharacterBuilder.tsx` - Added type assertion

### Security & Configuration âœ…

#### 7. Environment Configuration
**Problem:** No centralized environment configuration management, missing .env.example files.

**Solution:**
- Created `.env.example` for both frontend and backend
- Documented all required environment variables
- Added environment variable validation in backend
- Made CORS origins configurable via `ALLOWED_ORIGINS` env var
- Made rate limiting configurable via environment variables:
  - `RATE_LIMIT_WINDOW_MS` (default: 900000 / 15 minutes)
  - `RATE_LIMIT_MAX_REQUESTS` (default: 100)

**Files Created:**
- `packages/frontend/.env.example` - Frontend environment template
- `packages/backend/.env.example` - Backend environment template

**Files Changed:**
- `packages/backend/src/index.ts` - Added environment-based configuration

#### 8. CORS Configuration Review
**Problem:** CORS configuration needed review for production readiness.

**Solution:**
- Made CORS origins configurable via environment variable
- Added stricter validation in production (requires origin header)
- Documented allowed origins in startup logs
- Environment-based origin configuration:
  - Development: `http://localhost:3000`, `http://localhost:5173`
  - Production: Configurable via `ALLOWED_ORIGINS` environment variable

**Files Changed:**
- `packages/backend/src/index.ts` - Improved CORS configuration

#### 9. Rate Limiting Configuration
**Problem:** Rate limiting needed review and configurability.

**Solution:**
- Made rate limiting fully configurable via environment variables
- Added clear error message for rate limit exceeded
- Documented configuration in startup logs
- Default: 100 requests per 15 minutes

**Files Changed:**
- `packages/backend/src/index.ts` - Added configurable rate limiting
- `packages/backend/.env.example` - Documented rate limit variables

### Documentation âœ…

#### 10. Missing Documentation
**Problem:** Project lacked basic setup instructions, API documentation, and contribution guidelines.

**Solution:**
Created comprehensive documentation:

1. **README.md** (6,381 characters)
   - Project overview and architecture
   - Quick start guide
   - Installation instructions
   - Development workflow
   - Technology stack
   - Project structure
   - Environment configuration
   - Security notes
   - Contributing guidelines

2. **CONTRIBUTING.md** (7,655 characters)
   - Code of conduct
   - Development environment setup
   - Branch naming conventions
   - Commit message guidelines
   - Code style guidelines
   - Testing instructions
   - Pull request process
   - Project structure details

3. **DEPLOYMENT.md** (7,931 characters)
   - Build for production instructions
   - Frontend deployment options (Vercel, Netlify, static hosting)
   - Backend deployment options (PM2, Docker, cloud platforms)
   - Environment configuration
   - Security checklist
   - Monitoring setup
   - Continuous deployment
   - Troubleshooting guide
   - Performance optimization tips

**Files Created:**
- `README.md`
- `CONTRIBUTING.md`
- `DEPLOYMENT.md`

## ðŸ“Š Test Results

### Before Changes
- TypeScript compilation: âŒ Failed (46 errors)
- Build process: âŒ Failed
- Tests: âš ï¸ Could not run due to build failures

### After Changes
- TypeScript compilation: âœ… Passed (0 errors)
- Build process: âœ… Passed (all packages)
- Tests: âœ… Passed (17/17 tests passing)
- Frontend build size: 825.78 kB (gzipped: 261.59 kB)

## ðŸ”„ Migration Steps for Existing Developers

If you have an existing clone of the repository:

1. Install pnpm globally:
   ```bash
   npm install -g pnpm
   ```

2. Clean up old dependencies:
   ```bash
   rm -rf node_modules packages/*/node_modules
   rm -f package-lock.json packages/*/package-lock.json
   ```

3. Install dependencies with pnpm:
   ```bash
   pnpm install
   ```

4. Build all packages:
   ```bash
   pnpm build
   ```

5. Set up environment variables:
   ```bash
   cp packages/frontend/.env.example packages/frontend/.env.development
   cp packages/backend/.env.example packages/backend/.env.development
   ```

## ðŸ“ˆ Impact Summary

### Developer Experience
- âœ… Faster dependency installation with pnpm
- âœ… Consistent package management across team
- âœ… Clear documentation for onboarding
- âœ… Reliable build process
- âœ… Up-to-date dependencies with latest features

### Production Readiness
- âœ… Stable dependency versions (no pre-release)
- âœ… Configurable security settings
- âœ… Environment-based configuration
- âœ… Clear deployment instructions
- âœ… Security best practices documented

### Code Quality
- âœ… Zero TypeScript errors
- âœ… All tests passing
- âœ… Proper type definitions
- âœ… Clean build output
- âœ… Better error handling

## ðŸŽ“ Key Learnings

1. **Package Manager Consistency**: Using a single package manager (pnpm) eliminates many dependency resolution issues
2. **Build Orchestration**: Explicit build ordering prevents "module not found" errors in monorepos
3. **Type Safety**: Proper TypeScript configuration catches errors early
4. **Documentation**: Comprehensive docs reduce onboarding time and support requests
5. **Security**: Environment-based configuration keeps production secure

## ðŸ”® Future Improvements (Optional)

While not critical, these could further improve the project:

1. **Error Boundaries**: Add React error boundaries for better error handling
2. **Code Splitting**: Reduce main bundle size (currently 825 kB)
3. **CI/CD Pipeline**: Automate testing and deployment
4. **Bundle Analysis**: Set up automated bundle size monitoring
5. **API Documentation**: Generate API docs from code
6. **Performance Monitoring**: Add performance tracking

## âœ… Acceptance Criteria Met

All issues from the comprehensive review have been addressed:

- âœ… Package management standardized on pnpm
- âœ… Dependencies updated to stable, latest versions
- âœ… Naming inconsistencies fixed
- âœ… Build orchestration implemented
- âœ… Environment configuration centralized
- âœ… CORS and rate limiting reviewed and improved
- âœ… Comprehensive documentation added
- âœ… All builds passing
- âœ… All tests passing (17/17)
- âœ… Production-ready security configuration

## ðŸ“ Notes

- No breaking changes to existing functionality
- All changes are backward compatible for development
- Production deployment requires new environment variables (see .env.example files)
- Existing test suite maintained and verified

---

**Implementation Date:** 2024
**Total Files Changed:** 18 files
**Total Files Created:** 6 files
**Total Lines Changed:** ~1,000+ lines
**Test Coverage:** 17/17 tests passing
</file>

<file path="PERFORMANCE_TUNING.md">
# Performance Tuning Guide

This guide provides strategies for optimizing the performance of the biome rendering system.

## Key Performance Metrics

- **Frame Rate (FPS)**: The number of frames rendered per second. Aim for a consistent 60 FPS for a smooth user experience.
- **Frame Time**: The time it takes to render a single frame. This should be kept below 16ms to achieve 60 FPS.
- **Memory Usage**: The amount of memory used by the application. This should be monitored to prevent memory leaks and ensure the application runs smoothly on a variety of devices.

## Optimization Strategies

- **Viewport Culling**: The `ViewportCuller` utility can be used to cull biomes and other game objects that are outside the current viewport. This is the most effective way to improve rendering performance.
- **Level of Detail (LOD)**: The `BiomeTextureService` includes a simple LOD system that reduces the detail of textures that are far from the camera. This can be extended to other game objects to further improve performance.
- **Polygon Simplification**: The `BoundaryTracer` uses the `simplify-js` library to simplify the polygons that represent biome boundaries. This can significantly reduce the number of vertices that need to be rendered, improving performance.
- **Render Call Batching**: The `RenderCoordinator` can be optimized to batch render calls for similar objects. This can reduce the number of state changes and improve performance.
- **Performance Profiling**: The `RenderingProfiler` utility can be used to identify performance bottlenecks. This information can then be used to target optimization efforts.
</file>

<file path="pnpm-workspace.yaml">
packages:
  - 'packages/*'
</file>

<file path="ROUGH_FILL_GUIDE.md">
# Rough Fill Artistic Guide

This guide provides artistic guidelines for designing biomes with a cohesive, hand-drawn aesthetic using `rough.js`.

## Principles

- **Embrace Imperfection**: The core of the hand-drawn style is imperfection. Avoid perfectly straight lines and uniform patterns. Use `roughness` and `bowing` to create organic, natural-looking shapes.
- **Cohesive Color Palettes**: Each biome should have a distinct and harmonious color palette. Use the `primary`, `secondary`, and `border` colors to create depth and visual interest.
- **Meaningful Textures**: Textures should be used to convey information about the biome. For example, `hachure` can be used to represent dense forests, while `dots` can be used for sandy deserts.
- **Subtle Animations**: Animations should be used to bring the world to life, but they should be subtle and not distracting. Use the `animationProperties` to create gentle breathing and pulsing effects.

## Best Practices

- **Start with a Concept**: Before you start designing, have a clear concept for the biome. What is its story? What kind of mood do you want to evoke?
- **Iterate and Refine**: Don't be afraid to experiment. Try different combinations of `rough.js` settings until you find the perfect look for your biome.
- **Test in Context**: Always test your biomes in the context of the game world. Make sure they look good next to other biomes and that they are visually distinct.
</file>

<file path="packages/backend/scripts/validate-fixes.js">
const { validateEnv } = require('../dist/config/env');

try {
  console.log('ðŸ§ª Testing environment variable validation...');
  const env = validateEnv();
  console.log('âœ… Environment validation passed:', {
    port: env.PORT,
    nodeEnv: env.NODE_ENV,
    rateLimitWindow: env.RATE_LIMIT_WINDOW_MS
  });
} catch (error) {
  console.error('âŒ Environment validation failed:', error.message);
  process.exit(1);
}
</file>

<file path="packages/backend/src/__tests__/authentication.test.ts">
import { WebSocketServer } from '../services/webSocketServer';
import { GameStateManager } from '../services/gameStateManager';
import { Server } from 'http';
import { io as ClientIO, Socket as ClientSocket } from 'socket.io-client';
import { AddressInfo } from 'net';

describe('Authentication Race Condition Tests', () => {
  let server: Server;
  let webSocketServer: WebSocketServer;
  let gameStateManager: GameStateManager;
  let port: number;

  beforeAll((done) => {
    // Create HTTP server
    server = require('http').createServer();
    webSocketServer = new WebSocketServer(server);

    server.listen(0, () => {
      port = (server.address() as AddressInfo).port;
      done();
    });
  });

  afterAll((done) => {
    webSocketServer.shutdown();
    server.close(done);
  });

  it('should handle commands sent immediately after join without auth errors', (done) => {
    const clientSocket = ClientIO(`http://localhost:${port}`, {
      transports: ['websocket'],
      timeout: 5000,
    });

    let commandResults = 0;
    let authErrors = 0;

    clientSocket.on('connect', () => {
      clientSocket.emit('join_game', {
        id: `test-player-${Date.now()}`,
        displayName: 'TestPlayer',
        class: 'KNIGHT'
      });
    });

    clientSocket.on('game_joined', (data) => {
      // Send command immediately
      clientSocket.emit('player_command', {
        type: 'move',
        playerId: data.player.id,
        data: { position: { x: 0, y: -1 } }
      });
    });

    clientSocket.on('command_result', (result) => {
      commandResults++;
      expect(result.success).toBe(true);
      if (commandResults >= 1) {
        clientSocket.disconnect();
        expect(authErrors).toBe(0);
        done();
      }
    });

    clientSocket.on('error', (error) => {
      if (error.message && error.message.includes('authenticated')) {
        authErrors++;
      }
    });

    setTimeout(() => {
      clientSocket.disconnect();
      expect(authErrors).toBe(0);
      done();
    }, 3000);
  });
});
</file>

<file path="packages/backend/src/__tests__/gameLoop.test.ts">
import { WebSocketServer } from '../services/webSocketServer';
import { Server as HTTPServer } from 'http';
import { io as ioClient, Socket as ClientSocket } from 'socket.io-client';

describe('GameLoop Performance Tests', () => {
  let httpServer: HTTPServer;
  let webSocketServer: WebSocketServer;
  let clientSocket: ClientSocket;

  beforeEach(async () => {
    httpServer = new HTTPServer();
    webSocketServer = new WebSocketServer(httpServer);

    await new Promise<void>((resolve) => {
      httpServer.listen(() => resolve());
    });

    const address = httpServer.address();
    const port = typeof address === 'object' && address ? address.port : 3000;
    clientSocket = ioClient(`http://localhost:${port}`);

    await new Promise<void>((resolve) => {
      clientSocket.on('connect', resolve);
    });
  });

  afterEach(async () => {
    clientSocket.disconnect();
    webSocketServer.shutdown();
    httpServer.close();
  });

  test('should adjust game loop interval based on player count', async () => {
    const initialStats = webSocketServer.getGameLoopStats();

    // Simulate no players - should use 10-second interval
    expect(webSocketServer.getPlayerCount()).toBe(0);

    // Wait for a few iterations
    await new Promise(resolve => setTimeout(resolve, 11000));

    const statsAfterEmpty = webSocketServer.getGameLoopStats();
    expect(statsAfterEmpty.totalUpdates).toBeGreaterThanOrEqual(initialStats.totalUpdates);
  }, 12000);

  test('should handle environment variable validation', () => {
    const originalEnv = process.env.NODE_ENV;

    try {
      process.env.NODE_ENV = 'test';
      expect(() => webSocketServer.validateEnvironment()).not.toThrow();

      delete process.env.NODE_ENV;
      expect(() => webSocketServer.validateEnvironment()).toThrow();
    } finally {
      process.env.NODE_ENV = originalEnv;
    }
  });

  test('should cleanup stale client data efficiently', async () => {
    const initialClientCount = webSocketServer.getPlayerCount();

    // Force disconnect without proper cleanup
    clientSocket.disconnect();

    // Trigger cleanup
    await new Promise(resolve => setTimeout(resolve, 35000)); // Wait for cleanup interval

    const finalClientCount = webSocketServer.getPlayerCount();
    expect(finalClientCount).toBeLessThanOrEqual(initialClientCount);
  }, 40000);
});
</file>

<file path="packages/backend/src/config/env.ts">
export interface EnvConfig {
  PORT: number;
  NODE_ENV: 'development' | 'production' | 'test';
  RATE_LIMIT_WINDOW_MS: number;
  RATE_LIMIT_MAX_REQUESTS: number;
  ALLOWED_ORIGINS?: string;
  TWITCH_CLIENT_ID?: string;
  TWITCH_CLIENT_SECRET?: string;
  TWITCH_CHANNEL_NAME?: string;
}

export function validateEnv(): EnvConfig {
  const config: EnvConfig = {
    PORT: parseInt(process.env.PORT || '8081', 10),
    NODE_ENV: (process.env.NODE_ENV as any) || 'development',
    RATE_LIMIT_WINDOW_MS: parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000', 10),
    RATE_LIMIT_MAX_REQUESTS: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100', 10),
    ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS,
    TWITCH_CLIENT_ID: process.env.TWITCH_CLIENT_ID,
    TWITCH_CLIENT_SECRET: process.env.TWITCH_CLIENT_SECRET,
    TWITCH_CHANNEL_NAME: process.env.TWITCH_CHANNEL_NAME,
  };

  // Validate required fields
  if (config.PORT < 1 || config.PORT > 65535) {
    throw new Error('Invalid PORT configuration');
  }

  if (!['development', 'production', 'test'].includes(config.NODE_ENV)) {
    throw new Error('Invalid NODE_ENV configuration');
  }

  return config;
}
</file>

<file path="packages/backend/src/services/__tests__/StreamOptimizedTwitchService.test.ts">
import { StreamOptimizedTwitchService } from '../StreamOptimizedTwitchService';

describe('StreamOptimizedTwitchService', () => {
  let twitchService: StreamOptimizedTwitchService;
  let ioMock: any;
  let gameStateManagerMock: any;

  beforeEach(() => {
    jest.useFakeTimers();
    ioMock = {
      emit: jest.fn(),
    };
    gameStateManagerMock = {
      getGameWorld: jest.fn(),
      addPlayer: jest.fn(),
      removePlayer: jest.fn(),
      movePlayer: jest.fn(),
    };
    twitchService = new StreamOptimizedTwitchService(
      ioMock,
      'test-client-id',
      'test-client-secret',
      'test-channel',
      gameStateManagerMock
    );
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('should clear the interval on destroy', () => {
    const clearIntervalSpy = jest.spyOn(global, 'clearInterval');
    twitchService.destroy();
    expect(clearIntervalSpy).toHaveBeenCalled();
  });
});
</file>

<file path="packages/backend/src/services/EmojiService.ts">
import { JSDOM } from 'jsdom';
import { Svg2Roughjs } from 'svg2roughjs';

// Simple emoji validation data (subset of common emojis)
const emojiHexMap: Record<string, string> = {
  'ðŸ˜€': '1F600',
  'ðŸ˜ƒ': '1F603',
  'ðŸ˜„': '1F604',
  'ðŸ˜': '1F601',
  'ðŸ˜†': '1F606',
  'ðŸ˜…': '1F605',
  'ðŸ˜‚': '1F602',
  'ðŸ¤£': '1F923',
  'ðŸ˜Š': '1F60A',
  'ðŸ˜‡': '1F607',
  'ðŸ™‚': '1F642',
  'ðŸ™ƒ': '1F643',
  'ðŸ˜‰': '1F609',
  'ðŸ˜Œ': '1F60C',
  'ðŸ˜': '1F60D',
  'ðŸ¥°': '1F970',
  'ðŸ˜˜': '1F618',
  'ðŸ˜—': '1F617',
  'ðŸ˜™': '1F619',
  'ðŸ˜š': '1F61A',
  'ðŸ˜‹': '1F60B',
  'ðŸ˜›': '1F61B',
  'ðŸ˜': '1F61D',
  'ðŸ˜œ': '1F61C',
  'ðŸ¤ª': '1F92A',
  'ðŸ¤¨': '1F928',
  'ðŸ§': '1F9D0',
  'ðŸ¤“': '1F913',
  'ðŸ˜Ž': '1F60E',
  'ðŸ¤©': '1F929',
  'ðŸ¥³': '1F973',
  'ðŸ˜': '1F60F',
  'ðŸ˜’': '1F612',
  'ðŸ˜ž': '1F61E',
  'ðŸ˜”': '1F614',
  'ðŸ˜Ÿ': '1F61F',
  'ðŸ˜•': '1F615',
  'ðŸ™': '1F641',
  'â˜¹ï¸': '2639-FE0F',
  'ðŸ˜£': '1F623',
  'ðŸ˜–': '1F616',
  'ðŸ˜«': '1F62B',
  'ðŸ˜©': '1F629',
  'ðŸ¥º': '1F97A',
  'ðŸ˜¢': '1F622',
  'ðŸ˜­': '1F62D',
  'ðŸ˜¤': '1F624',
  'ðŸ˜ ': '1F620',
  'ðŸ˜¡': '1F621',
  'ðŸ¤¬': '1F92C',
  'ðŸ¤¯': '1F92F',
  'ðŸ˜³': '1F633',
  'ðŸ¥µ': '1F975',
  'ðŸ¥¶': '1F976',
  'ðŸ˜±': '1F631',
  'ðŸ˜¨': '1F628',
  'ðŸ˜°': '1F630',
  'ðŸ˜¥': '1F625',
  'ðŸ˜“': '1F613',
  'ðŸ¤—': '1F917',
  'ðŸ¤”': '1F914',
  'ðŸ¤­': '1F92D',
  'ðŸ¤«': '1F92B',
  'ðŸ¤¥': '1F925',
  'ðŸ˜¶': '1F636',
  'ðŸ˜': '1F610',
  'ðŸ˜‘': '1F611',
  'ðŸ˜¬': '1F62C',
  'ðŸ™„': '1F644',
  'ðŸ˜¯': '1F62F',
  'ðŸ˜¦': '1F626',
  'ðŸ˜§': '1F627',
  'ðŸ˜®': '1F62E',
  'ðŸ˜²': '1F632',
  'ðŸ¥±': '1F971',
  'ðŸ˜´': '1F634',
  'ðŸ¤¤': '1F924',
  'ðŸ˜ª': '1F62A',
  'ðŸ˜µ': '1F635',
  'ðŸ¤': '1F910',
  'ðŸ¥´': '1F974',
  'ðŸ¤¢': '1F922',
  'ðŸ¤®': '1F92E',
  'ðŸ¤§': '1F927',
  'ðŸ˜·': '1F637',
  'ðŸ¤’': '1F912',
  'ðŸ¤•': '1F915',
  'ðŸ¤‘': '1F911',
  'ðŸ¤ ': '1F920',
  'ðŸ˜ˆ': '1F608',
  'ðŸ‘¿': '1F47F',
  'ðŸ‘¹': '1F479',
  'ðŸ‘º': '1F47A',
  'ðŸ¤¡': '1F921',
  'ðŸ’©': '1F4A9',
  'ðŸ‘»': '1F47B',
  'ðŸ’€': '1F480',
  'â˜ ï¸': '2620-FE0F',
  'ðŸ‘½': '1F47D',
  'ðŸ‘¾': '1F47E',
  'ðŸ¤–': '1F916',
  'ðŸŽƒ': '1F383',
  'ðŸ˜º': '1F63A',
  'ðŸ˜¸': '1F638',
  'ðŸ˜¹': '1F639',
  'ðŸ˜»': '1F63B',
  'ðŸ˜¼': '1F63C',
  'ðŸ˜½': '1F63D',
  'ðŸ™€': '1F640',
  'ðŸ˜¿': '1F63F',
  'ðŸ˜¾': '1F63E',
  'ðŸ‘‹': '1F44B',
  'ðŸ¤š': '1F91A',
  'ðŸ–ï¸': '1F590-FE0F',
  'âœ‹': '270B',
  'ðŸ––': '1F596',
  'ðŸ‘Œ': '1F44C',
  'ðŸ¤': '1F90F',
  'âœŒï¸': '270C-FE0F',
  'ðŸ¤ž': '1F91E',
  'ðŸ¤Ÿ': '1F91F',
  'ðŸ¤˜': '1F918',
  'ðŸ¤™': '1F919',
  'ðŸ‘ˆ': '1F448',
  'ðŸ‘‰': '1F449',
  'ðŸ‘†': '1F446',
  'ðŸ–•': '1F595',
  'ðŸ‘‡': '1F447',
  'â˜ï¸': '261D-FE0F',
  'ðŸ‘': '1F44D',
  'ðŸ‘Ž': '1F44E',
  'ðŸ‘Š': '1F44A',
  'âœŠ': '270A',
  'ðŸ‘': '1F44F',
  'ðŸ™Œ': '1F64C',
  'ðŸ‘': '1F450',
  'ðŸ¤²': '1F932',
  'ðŸ¤': '1F91D',
  'ðŸ™': '1F64F',
  'âœï¸': '270D-FE0F',
  'ðŸ’…': '1F485',
  'ðŸ¤³': '1F933',
  'ðŸ’ª': '1F4AA',
  'ðŸ¦¾': '1F9BE',
  'ðŸ¦¿': '1F9BF',
  'ðŸ¦µ': '1F9B5',
  'ðŸ¦¶': '1F9B6',
  'ðŸ‘‚': '1F442',
  'ðŸ¦»': '1F9BB',
  'ðŸ‘ƒ': '1F443',
  'ðŸ§ ': '1F9E0',
  'ðŸ«€': '1F9E1',
  'ðŸ«': '1F9E2',
  'ðŸ¦·': '1F9B7',
  'ðŸ¦´': '1F9B4',
  'ðŸ‘€': '1F440',
  'ðŸ‘ï¸': '1F441-FE0F',
  'ðŸ‘…': '1F445',
  'ðŸ‘„': '1F444',
  'ðŸ’‹': '1F48B',
  'ðŸ©¸': '1F9E7'
};

type CachedEmoji = {
    svg: string;
    fetchedAt: number;
};

export class EmojiService {
    private emojiCache = new Map<string, CachedEmoji>();
    private convertedCache = new Map<string, CachedEmoji>();

    async resolveEmojiSvg(emoji: string): Promise<string> {
        const cacheKey = emoji;
        const cached = this.emojiCache.get(cacheKey);
        if (cached && (Date.now() - cached.fetchedAt) < 1000 * 60 * 60) { // 1h cache
            return cached.svg;
        }

        // Validate emoji using local map
        const hexCode = emojiHexMap[emoji];
        if (!hexCode) {
            console.warn(`Emoji ${emoji} not supported, using fallback`);
            return this.getFallbackSvg(emoji);
        }

        try {
            const cdnUrl = `https://cdn.jsdelivr.net/npm/@svgmoji/noto@latest/svg/${hexCode}.svg`;
            const response = await fetch(cdnUrl);
            if (response.ok) {
                const svgText = await response.text();
                this.emojiCache.set(cacheKey, { svg: svgText, fetchedAt: Date.now() });
                return svgText;
            } else {
                console.warn(`CDN fetch failed for ${emoji}: ${response.status}`);
            }
        } catch (cdnError) {
            console.warn('CDN fetch error:', cdnError);
        }

        // Fallback SVG
        return this.getFallbackSvg(emoji);
    }

    private getFallbackSvg(emoji: string): string {
        return `<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128" viewBox="0 0 128 128"><rect width="100%" height="100%" fill="transparent"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="72">${emoji}</text></svg>`;
    }

    async convertToRoughSvg(svg: string, options: any, emoji: string): Promise<string> {
        const optKey = JSON.stringify(options);
        const convertedCacheKey = `${emoji}::${optKey}`;
        const cachedConverted = this.convertedCache.get(convertedCacheKey);
        if (cachedConverted && (Date.now() - cachedConverted.fetchedAt) < 1000 * 60 * 60) {
            return cachedConverted.svg;
        }

        try {
            const dom = new JSDOM(`<!doctype html><html><body></body></html>`);
            (global as any).window = dom.window;
            (global as any).document = dom.window.document;
            (global as any).DOMParser = dom.window.DOMParser;
            (global as any).XMLSerializer = dom.window.XMLSerializer;
            (global as any).SVGElement = (dom.window as any).SVGElement;
            (global as any).SVGSVGElement = (dom.window as any).SVGSVGElement;

            const document = dom.window.document as unknown as Document;
            const parser = new dom.window.DOMParser();
            const svgDoc = parser.parseFromString(svg, 'image/svg+xml');

            if (!svgDoc || svgDoc.getElementsByTagName('parsererror').length > 0) {
                console.error('Failed to parse SVG document');
                return svg;
            }

            const svgElement = svgDoc.documentElement as unknown as SVGSVGElement;
            const container = document.createElement('div');

            let converter: any;
            try {
                const Svg2Roughjs = require('svg2roughjs').Svg2Roughjs || require('svg2roughjs').default;
                if (!Svg2Roughjs) {
                    throw new Error('Svg2Roughjs not found in library');
                }
                converter = new Svg2Roughjs(container);
                converter.svg = svgElement;
            } catch (converterError) {
                console.warn('SVG converter initialization failed, using original SVG:', (converterError as Error).message);
                return svg;
            }

            if (options.roughness !== undefined) converter.roughConfig.roughness = options.roughness as any;
            if (options.bowing !== undefined) converter.roughConfig.bowing = options.bowing as any;
            if (options.seed !== undefined) converter.seed = options.seed as any;
            if (options.randomize !== undefined) converter.randomize = options.randomize as any;
            if (options.pencilFilter !== undefined) converter.pencilFilter = options.pencilFilter as any;
            if (options.sketchPatterns !== undefined) converter.sketchPatterns = options.sketchPatterns as any;

            const result = await converter.sketch();
            let resultSvg = '';
            if (result && result instanceof dom.window.SVGSVGElement) {
                resultSvg = new dom.window.XMLSerializer().serializeToString(result);
            } else if (container.innerHTML) {
                resultSvg = container.innerHTML;
            }

            if (!resultSvg) {
                console.warn('SVG conversion produced no output, using original SVG');
                return svg;
            }

            this.convertedCache.set(convertedCacheKey, { svg: resultSvg, fetchedAt: Date.now() });
            return resultSvg;
        } catch (conversionError) {
            console.error('Server-side rough conversion failed:', conversionError);
            return svg;
        }
    }
}
</file>

<file path="packages/backend/src/services/gameStateManager.old.ts">
// Consolidated GameStateManager
// Preserves previous refactor (event queue, helper methods, cataclysm, NPCs, items, movement, combat)

import { Player, NPC, Item, BiomeType, Position, GameWorld, ItemType, ItemRarity, GAME_CONFIG, MOVEMENT_CONSTANTS, COMBAT_CONSTANTS, WORLD_CONSTANTS } from '@chatterealm/shared';

export interface GameActionResult {
  success: boolean;
  message: string;
  data?: any;
}

export interface MoveResult extends GameActionResult {
  newPosition?: Position;
}

export interface CombatResult extends GameActionResult {
  battleResult?: any;
}

export interface ItemResult extends GameActionResult {
  item?: Item;
}

export class GameStateManager {
  private gameWorld: GameWorld;
  private reservedPositions: Set<string> = new Set();
  private occupiedPositions: Set<string> = new Set();
  private availableSpawnPoints: Set<string> = new Set();

  // Event queue for state changes (deltas)
  private changeEvents: GameEvent[] = [];

  // Movement queues for players performing path-following (click-to-move)
  private playerMovementQueues: Map<string, Position[]> = new Map();

  private recordEvent(event: GameEvent) {
    this.changeEvents.push(event);
  }

  public getAndClearChangeEvents(): GameEvent[] {
    const events = [...this.changeEvents];
    this.changeEvents = [];
    return events;
  }

  constructor(gameWorld?: GameWorld) {
    this.gameWorld = gameWorld ?? this.initializeGameWorld();
    this.initializeOccupiedPositions();
  }

  private initializeGameWorld(): GameWorld {
    const newGameWorld: GameWorld = {
      id: 'main_world',
      grid: [],
      players: [],
      npcs: [],
      items: [],
      buildings: [], // Initialize empty buildings array
      cataclysmCircle: {
        center: { x: Math.floor(GAME_CONFIG.gridWidth / 2), y: Math.floor(GAME_CONFIG.gridHeight / 2) },
        radius: Math.max(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight),
        isActive: false,
        shrinkRate: WORLD_CONSTANTS.CATACLYSM_SHRINK_RATE,
        nextShrinkTime: 0,
      },
      cataclysmRoughnessMultiplier: 1.0,
      worldAge: 0,
      lastResetTime: Date.now(),
      phase: 'exploration'
    } as GameWorld;

    // Initialize grid with default terrain
    for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
      newGameWorld.grid[y] = [];
      for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
        newGameWorld.grid[y][x] = {
          type: BiomeType.PLAIN,
          position: { x, y },
          movementCost: GAME_CONFIG.terrainConfig[BiomeType.PLAIN].movementCost,
          defenseBonus: GAME_CONFIG.terrainConfig[BiomeType.PLAIN].defenseBonus,
          visibilityModifier: GAME_CONFIG.terrainConfig[BiomeType.PLAIN].visibilityModifier
        } as any;
      }
    }

    // Enhanced biome generation with compatibility rules and transition zones
    const biomeCompatibility: Record<BiomeType, BiomeType[]> = {
      [BiomeType.PLAIN]: [BiomeType.FOREST, BiomeType.GRASSLAND, BiomeType.HILLS, BiomeType.CLEARING],
      [BiomeType.FOREST]: [BiomeType.PLAIN, BiomeType.DENSE_FOREST, BiomeType.MOUNTAIN, BiomeType.HILLS],
      [BiomeType.MOUNTAIN]: [BiomeType.FOREST, BiomeType.HILLS, BiomeType.SNOW, BiomeType.ROUGH_TERRAIN],
      [BiomeType.OCEAN]: [BiomeType.WATER, BiomeType.SAND, BiomeType.MARSH],
      [BiomeType.SAND]: [BiomeType.OCEAN, BiomeType.DUNES, BiomeType.PLAIN],
      [BiomeType.GRASSLAND]: [BiomeType.PLAIN, BiomeType.FOREST, BiomeType.FLOWER_FIELD],
      [BiomeType.HILLS]: [BiomeType.PLAIN, BiomeType.MOUNTAIN, BiomeType.ROUGH_TERRAIN],
      [BiomeType.SNOW]: [BiomeType.MOUNTAIN, BiomeType.ICE],
      [BiomeType.WATER]: [BiomeType.OCEAN, BiomeType.RIVER, BiomeType.MARSH],
      [BiomeType.RIVER]: [BiomeType.WATER, BiomeType.PLAIN, BiomeType.FOREST],
      [BiomeType.DENSE_FOREST]: [BiomeType.FOREST, BiomeType.MOUNTAIN],
      [BiomeType.CLEARING]: [BiomeType.FOREST, BiomeType.PLAIN],
      [BiomeType.FLOWER_FIELD]: [BiomeType.GRASSLAND, BiomeType.PLAIN],
      [BiomeType.ROUGH_TERRAIN]: [BiomeType.HILLS, BiomeType.MOUNTAIN],
      [BiomeType.DUNES]: [BiomeType.SAND, BiomeType.PLAIN],
      [BiomeType.MARSH]: [BiomeType.WATER, BiomeType.SWAMP],
      [BiomeType.SWAMP]: [BiomeType.MARSH, BiomeType.WATER],
      [BiomeType.ICE]: [BiomeType.SNOW, BiomeType.WATER],
      [BiomeType.ANCIENT_RUINS]: [BiomeType.PLAIN, BiomeType.FOREST],
      [BiomeType.MOUNTAIN_PEAK]: [BiomeType.MOUNTAIN],
      [BiomeType.DENSE_JUNGLE]: [BiomeType.FOREST, BiomeType.JUNGLE],
      [BiomeType.JUNGLE]: [BiomeType.DENSE_JUNGLE, BiomeType.FOREST],
      [BiomeType.DEEP_WATER]: [BiomeType.OCEAN, BiomeType.WATER],
      [BiomeType.OASIS]: [BiomeType.SAND, BiomeType.DUNES],
      [BiomeType.ROLLING_HILLS]: [BiomeType.HILLS, BiomeType.PLAIN],
      [BiomeType.SNOWY_HILLS]: [BiomeType.HILLS, BiomeType.SNOW]
    };

    // Enhanced cluster generation with different shapes and transition zones
    const generateBiomeCluster = (centerX: number, centerY: number, primaryBiome: BiomeType, size: number) => {
      const placed = new Map<string, BiomeType>();
      const transitionZone = new Set<string>();

      // Generate primary cluster with organic shape
      const generateOrganicShape = (cx: number, cy: number, biome: BiomeType, clusterSize: number) => {
        const localPlaced = new Set<string>();
        const seeds = [{ x: cx, y: cy }];

        for (let i = 0; i < clusterSize && seeds.length > 0; i++) {
          const idx = Math.floor(Math.random() * seeds.length);
          const { x, y } = seeds.splice(idx, 1)[0];
          const key = `${x},${y}`;

          if (x < 0 || y < 0 || x >= GAME_CONFIG.gridWidth || y >= GAME_CONFIG.gridHeight) continue;
          if (localPlaced.has(key)) continue;

          localPlaced.add(key);
          placed.set(key, biome);

          // Add neighboring tiles with decreasing probability
          const neighbors = [
            { x: x + 1, y }, { x: x - 1, y },
            { x, y: y + 1 }, { x, y: y - 1 }
          ];

          for (const n of neighbors) {
            if (!localPlaced.has(`${n.x},${n.y}`) && Math.random() < 0.7) {
              seeds.push(n);
            }
          }
        }

        return localPlaced;
      };

      // Generate primary cluster
      const primaryTiles = generateOrganicShape(centerX, centerY, primaryBiome, size);

      // Generate transition zones around compatible biomes
      const compatibleBiomes = biomeCompatibility[primaryBiome] || [];
      for (const tileKey of primaryTiles) {
        const [xStr, yStr] = tileKey.split(',');
        const x = parseInt(xStr), y = parseInt(yStr);

        // Check adjacent tiles for transition opportunities
        const adjacent = [
          { x: x + 1, y }, { x: x - 1, y },
          { x, y: y + 1 }, { x, y: y - 1 }
        ];

        for (const adj of adjacent) {
          if (adj.x < 0 || adj.y < 0 || adj.x >= GAME_CONFIG.gridWidth || adj.y >= GAME_CONFIG.gridHeight) continue;

          const adjKey = `${adj.x},${adj.y}`;
          // Ensure the grid position exists before accessing it
          if (!newGameWorld.grid[adj.y] || !newGameWorld.grid[adj.y][adj.x]) continue;

          const currentBiome = newGameWorld.grid[adj.y][adj.x].type;

          // If adjacent tile is compatible and not already set, mark for transition
          if (compatibleBiomes.includes(currentBiome) && !placed.has(adjKey)) {
            transitionZone.add(adjKey);
          }
        }
      }

      // Apply transition zones with reduced density
      for (const tileKey of transitionZone) {
        if (Math.random() < 0.4) { // 40% chance for transition tiles
          const [xStr, yStr] = tileKey.split(',');
          const x = parseInt(xStr), y = parseInt(yStr);
          const currentBiome = newGameWorld.grid[y][x].type;

          // Choose a transition biome that's compatible
          const transitionOptions = compatibleBiomes.filter(b => b !== primaryBiome);
          if (transitionOptions.length > 0) {
            const transitionBiome = transitionOptions[Math.floor(Math.random() * transitionOptions.length)];
            placed.set(tileKey, transitionBiome);
          }
        }
      }

      // Apply all placed tiles to the world
      for (const [key, biome] of placed) {
        const [xStr, yStr] = key.split(',');
        const x = parseInt(xStr), y = parseInt(yStr);
        newGameWorld.grid[y][x] = {
          type: biome,
          position: { x, y },
          movementCost: GAME_CONFIG.terrainConfig[biome].movementCost,
          defenseBonus: GAME_CONFIG.terrainConfig[biome].defenseBonus,
          visibilityModifier: GAME_CONFIG.terrainConfig[biome].visibilityModifier
        } as any;
      }
    };

    // Generate biome clusters with strategic placement
    const biomeClusters = [
      // Core biomes with larger clusters
      { biome: BiomeType.FOREST, count: Math.max(4, Math.floor((GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight) / 250)), sizeRange: [8, 18] },
      { biome: BiomeType.MOUNTAIN, count: Math.max(3, Math.floor((GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight) / 400)), sizeRange: [6, 14] },
      { biome: BiomeType.OCEAN, count: Math.max(2, Math.floor((GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight) / 600)), sizeRange: [10, 20] },
      { biome: BiomeType.SAND, count: Math.max(2, Math.floor((GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight) / 500)), sizeRange: [7, 15] },

      // Secondary biomes with smaller clusters
      { biome: BiomeType.GRASSLAND, count: Math.max(2, Math.floor((GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight) / 800)), sizeRange: [5, 12] },
      { biome: BiomeType.HILLS, count: Math.max(2, Math.floor((GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight) / 700)), sizeRange: [4, 10] },
      { biome: BiomeType.SNOW, count: Math.max(1, Math.floor((GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight) / 1200)), sizeRange: [3, 8] },
      { biome: BiomeType.WATER, count: Math.max(1, Math.floor((GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight) / 1000)), sizeRange: [4, 12] },
    ];

    // Place all biome clusters
    for (const cluster of biomeClusters) {
      for (let i = 0; i < cluster.count; i++) {
        const cx = Math.floor(Math.random() * GAME_CONFIG.gridWidth);
        const cy = Math.floor(Math.random() * GAME_CONFIG.gridHeight);
        const size = cluster.sizeRange[0] + Math.floor(Math.random() * (cluster.sizeRange[1] - cluster.sizeRange[0]));
        generateBiomeCluster(cx, cy, cluster.biome, size);
      }
    }

    // Add some rivers connecting water bodies
    const addRivers = () => {
      const waterBodies: Array<{ x: number, y: number }> = [];

      // Find all water tiles
      for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
        for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
          const tile = newGameWorld.grid[y][x];
          if (tile.type === BiomeType.OCEAN || tile.type === BiomeType.WATER) {
            waterBodies.push({ x, y });
          }
        }
      }

      // Create rivers between some water bodies
      const riverCount = Math.min(3, Math.floor(waterBodies.length / 4));
      for (let i = 0; i < riverCount; i++) {
        if (waterBodies.length < 2) break;

        const startIdx = Math.floor(Math.random() * waterBodies.length);
        const start = waterBodies.splice(startIdx, 1)[0];

        const endIdx = Math.floor(Math.random() * waterBodies.length);
        const end = waterBodies[endIdx];

        // Create a winding river path
        let current = { ...start };
        const riverTiles: Array<{ x: number, y: number }> = [];

        for (let step = 0; step < 20 && (current.x !== end.x || current.y !== end.y); step++) {
          riverTiles.push({ ...current });

          // Move towards end with some randomness
          const dx = end.x - current.x;
          const dy = end.y - current.y;

          if (Math.abs(dx) > Math.abs(dy)) {
            current.x += Math.sign(dx) + (Math.random() > 0.7 ? Math.sign(Math.random() - 0.5) : 0);
          } else {
            current.y += Math.sign(dy) + (Math.random() > 0.7 ? Math.sign(Math.random() - 0.5) : 0);
          }

          // Keep within bounds
          current.x = Math.max(0, Math.min(GAME_CONFIG.gridWidth - 1, current.x));
          current.y = Math.max(0, Math.min(GAME_CONFIG.gridHeight - 1, current.y));
        }

        // Apply river tiles
        for (const tile of riverTiles) {
          if (tile.x >= 0 && tile.y >= 0 && tile.x < GAME_CONFIG.gridWidth && tile.y < GAME_CONFIG.gridHeight) {
            const currentType = newGameWorld.grid[tile.y][tile.x].type;
            // Only place river on plains or grasslands
            if (currentType === BiomeType.PLAIN || currentType === BiomeType.GRASSLAND) {
              newGameWorld.grid[tile.y][tile.x] = {
                type: BiomeType.RIVER,
                position: { x: tile.x, y: tile.y },
                movementCost: GAME_CONFIG.terrainConfig[BiomeType.RIVER].movementCost,
                defenseBonus: GAME_CONFIG.terrainConfig[BiomeType.RIVER].defenseBonus,
                visibilityModifier: GAME_CONFIG.terrainConfig[BiomeType.RIVER].visibilityModifier
              } as any;
            }
          }
        }
      }
    };

    addRivers();

    // Mark available spawn points (non-mountain tiles) and initialize movement/defense modifiers
    for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
      for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
        const terrainType = newGameWorld.grid[y][x].type;
        if (terrainType !== BiomeType.MOUNTAIN) {
          this.availableSpawnPoints.add(`${x},${y}`);
        }
      }
    }

    return newGameWorld;
  }

  // Pathfinding (A*) - returns an array of Positions from start to target inclusive, or null if no path
  public findPath(start: Position, target: Position, maxNodes = 20000): Position[] | null {
    const startKey = `${start.x},${start.y}`;
    const targetKey = `${target.x},${target.y}`;
    if (startKey === targetKey) return [start];

    const inBounds = (p: Position) => p.x >= 0 && p.y >= 0 && p.x < GAME_CONFIG.gridWidth && p.y < GAME_CONFIG.gridHeight;

    const heuristic = (a: Position, b: Position) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);

    const keyOf = (p: Position) => `${p.x},${p.y}`;

    const openSet: Position[] = [start];
    const cameFrom: Map<string, string> = new Map();

    const gScore: Map<string, number> = new Map();
    gScore.set(startKey, 0);

    const fScore: Map<string, number> = new Map();
    fScore.set(startKey, heuristic(start, target));

    const closed = new Set<string>();
    let nodesProcessed = 0;

    while (openSet.length > 0 && nodesProcessed < maxNodes) {
      // find node in openSet with lowest fScore
      let currentIdx = 0;
      let currentF = Infinity;
      for (let i = 0; i < openSet.length; i++) {
        const k = keyOf(openSet[i]);
        const fs = fScore.get(k) ?? Infinity;
        if (fs < currentF) {
          currentF = fs;
          currentIdx = i;
        }
      }

      const current = openSet.splice(currentIdx, 1)[0];
      const currentKey = keyOf(current);

      if (currentKey === targetKey) {
        // reconstruct path
        const path: Position[] = [];
        let k: string | undefined = currentKey;
        while (k) {
          const [xStr, yStr] = k.split(',');
          path.push({ x: Number(xStr), y: Number(yStr) });
          k = cameFrom.get(k);
        }
        path.reverse();
        return path;
      }

      closed.add(currentKey);
      nodesProcessed++;

      const neighbors = [ { x: current.x+1, y: current.y }, { x: current.x-1, y: current.y }, { x: current.x, y: current.y+1 }, { x: current.x, y: current.y-1 } ];
      for (const n of neighbors) {
        if (!inBounds(n)) continue;
        const nKey = keyOf(n);
        if (closed.has(nKey)) continue;

        // Skip mountains as impassable
        const terrain = this.gameWorld.grid[n.y][n.x];
        if (!terrain || terrain.type === BiomeType.MOUNTAIN) continue;

        // Avoid occupied tiles (except if it's the target)
        if (nKey !== targetKey && this.isPositionOccupied(n)) continue;

        const tentativeG = (gScore.get(currentKey) ?? Infinity) + (this.gameWorld.grid[n.y][n.x].movementCost ?? 1);

        const existingG = gScore.get(nKey) ?? Infinity;
        if (tentativeG < existingG) {
          cameFrom.set(nKey, currentKey);
          gScore.set(nKey, tentativeG);
          const f = tentativeG + heuristic(n, target);
          fScore.set(nKey, f);
          // add to openSet if not present
          if (!openSet.some(p => keyOf(p) === nKey)) openSet.push({ x: n.x, y: n.y });
        }
      }
    }

    return null; // no path found
  }

  // Request the server to compute a path and enqueue movement for the player.
  // Returns a MoveResult with success and optional path length info.
  public requestMoveTo(playerId: string, target: Position): MoveResult {
    const player = this.getPlayer(playerId);
    if (!player) return { success: false, message: 'Player not found' };
    if (!player.isAlive) return { success: false, message: 'Player not alive' };

    const now = Date.now();
    // Allow queueing even if on cooldown; movement will occur on next available tick.

    const path = this.findPath(player.position, target);
    if (!path || path.length === 0) return { success: false, message: 'No path found' };

    // Store queue excluding current position
    const queue = path.slice(1);
    this.playerMovementQueues.set(playerId, queue);

    // Attempt an immediate step if possible
    const immediate = this.processSinglePlayerQueueStep(playerId);
    const remaining = this.playerMovementQueues.get(playerId)?.length ?? 0;
    return { success: immediate.success, message: immediate.message, newPosition: immediate.newPosition, data: { queued: remaining } };
  }

  // Process one queued step for a particular player (respecting cooldown). Returns a MoveResult-like object.
  private processSinglePlayerQueueStep(playerId: string): MoveResult {
    const queue = this.playerMovementQueues.get(playerId);
    if (!queue || queue.length === 0) return { success: false, message: 'No queued moves' };
    const player = this.getPlayer(playerId);
    if (!player) return { success: false, message: 'Player not found' };
    if (!player.isAlive) return { success: false, message: 'Player not alive' };

    const now = Date.now();
    if (now - player.lastMoveTime < MOVEMENT_CONSTANTS.BASE_MOVE_COOLDOWN) return { success: false, message: 'Movement on cooldown' };

    const next = queue[0];
    if (!this.isValidMove(player.position, next)) return { success: false, message: 'Invalid move (queued)' };
    if (this.isPositionOccupied(next)) return { success: false, message: 'Position occupied (queued)' };

    // Perform move
    this.occupiedPositions.delete(`${player.position.x},${player.position.y}`);
    const oldPos = { ...player.position };
    player.position = { x: next.x, y: next.y };
    this.occupiedPositions.add(`${player.position.x},${player.position.y}`);
    player.lastMoveTime = now;

    // Pop the queue and clean up
    queue.shift();
    if (queue.length === 0) this.playerMovementQueues.delete(playerId);
    else this.playerMovementQueues.set(playerId, queue);

    this.recordEvent({ type: 'player_moved', data: { playerId, newPosition: { ...player.position }, direction: (player.position.x - oldPos.x === 1 ? 'right' : player.position.x - oldPos.x === -1 ? 'left' : player.position.y - oldPos.y === 1 ? 'down' : 'up') } } as any);

    return { success: true, message: 'Moved', newPosition: { ...player.position } };
  }

  // Process movement queues for all players on the server tick (called from update)
  private processPlayerMovementQueues(): void {
    for (const playerId of Array.from(this.playerMovementQueues.keys())) {
      // Attempt a single step; ignore failures (will retry next tick)
      this.processSinglePlayerQueueStep(playerId);
    }
  }

  private initializeOccupiedPositions(): void {
    this.occupiedPositions.clear();
    this.gameWorld.players.forEach(p => {
      if (p.isAlive) this.occupiedPositions.add(`${p.position.x},${p.position.y}`);
    });
    this.gameWorld.npcs.forEach(n => {
      if (n.isAlive) this.occupiedPositions.add(`${n.position.x},${n.position.y}`);
    });

    this.gameWorld.players.forEach(p => {
      if (p.isAlive) this.availableSpawnPoints.delete(`${p.position.x},${p.position.y}`);
    });
    this.gameWorld.npcs.forEach(n => {
      if (n.isAlive) this.availableSpawnPoints.delete(`${n.position.x},${n.position.y}`);
    });
  }

  // Get current game world
  public getGameWorld(): GameWorld {
    return this.gameWorld;
  }

  // Public helpers required by webSocketServer
  public getPlayers(): Player[] {
    return this.gameWorld.players;
  }

  public startCataclysm(): GameActionResult {
    if (!this.gameWorld.cataclysmCircle.isActive) {
      this.gameWorld.cataclysmCircle.isActive = true;
      this.gameWorld.cataclysmCircle.nextShrinkTime = Date.now() + 60000;
      this.gameWorld.phase = 'cataclysm';
      this.gameWorld.cataclysmRoughnessMultiplier = 1.0; // Start at normal roughness
      this.recordEvent({ type: 'cataclysm_started', data: { timestamp: Date.now() } } as any);
      return { success: true, message: 'Cataclysm started', data: { nextShrinkTime: this.gameWorld.cataclysmCircle.nextShrinkTime } };
    }
    return { success: false, message: 'Cataclysm already active' };
  }

  // Return a single player by id
  public getPlayer(playerId: string): Player | undefined {
    return this.gameWorld.players.find(p => p.id === playerId);
  }

  // Item pickup - player picks up item from world (Tarkov-style looting)
  public pickupItem(playerId: string, itemId: string): ItemResult {
    const player = this.getPlayer(playerId);
    const itemIndex = this.gameWorld.items.findIndex(i => i.id === itemId);
    if (!player) return { success: false, message: 'Player not found' };
    if (itemIndex === -1) return { success: false, message: 'Item not found' };

    const item = this.gameWorld.items[itemIndex];

    // Check if player is close enough to interact with the item
    if (!item.position || this.getDistance(player.position, item.position) > GAME_CONFIG.lootInteractionRadius) {
      return { success: false, message: 'Item out of reach' };
    }

    // If item is hidden, player must inspect it first
    if (item.isHidden) {
      return { success: false, message: 'Item is hidden. Use inspect_item first.' };
    }

    // If item is still revealing, can't pick it up yet
    if (item.revealProgress < 1.0) {
      return { success: false, message: 'Item is still being revealed.' };
    }

    // Item is fully revealed and can be picked up
    if (!item.canBeLooted) {
      return { success: false, message: 'This item cannot be looted.' };
    }

    // Add to inventory and remove from world
    player.inventory.push(item);
    item.ownerId = player.id;
    item.position = undefined;
    this.gameWorld.items.splice(itemIndex, 1);

    this.recordEvent({ type: 'item_picked', data: { playerId, itemId } } as any);

    return { success: true, message: `Picked up ${item.name}`, item };
  }

  // Inspect item - starts the reveal process for hidden items
  public inspectItem(playerId: string, itemId: string): ItemResult {
    const player = this.getPlayer(playerId);
    const itemIndex = this.gameWorld.items.findIndex(i => i.id === itemId);
    if (!player) return { success: false, message: 'Player not found' };
    if (itemIndex === -1) return { success: false, message: 'Item not found' };

    const item = this.gameWorld.items[itemIndex];

    // Check if player is close enough
    if (!item.position || this.getDistance(player.position, item.position) > GAME_CONFIG.lootInteractionRadius) {
      return { success: false, message: 'Item out of reach' };
    }

    // If item is not hidden, no need to inspect
    if (!item.isHidden) {
      return { success: false, message: 'Item is already visible.' };
    }

    // Start the reveal process
    const now = Date.now();
    item.isHidden = false;
    item.revealStartTime = now;
    item.lastInteractionTime = now;
    item.revealProgress = 0.0;

    this.recordEvent({ type: 'item_inspected', data: { playerId, itemId, revealStartTime: now } } as any);

    return { success: true, message: `Started revealing ${item.name}`, item };
  }

  // Loot item - attempts to pick up a revealing item (Tarkov-style)
  public lootItem(playerId: string, itemId: string): ItemResult {
    const player = this.getPlayer(playerId);
    const itemIndex = this.gameWorld.items.findIndex(i => i.id === itemId);
    if (!player) return { success: false, message: 'Player not found' };
    if (itemIndex === -1) return { success: false, message: 'Item not found' };

    const item = this.gameWorld.items[itemIndex];

    // Check if player is close enough
    if (!item.position || this.getDistance(player.position, item.position) > GAME_CONFIG.lootInteractionRadius) {
      return { success: false, message: 'Item out of reach' };
    }

    // If item is hidden, must inspect first
    if (item.isHidden) {
      return { success: false, message: 'Item is hidden. Use inspect_item first.' };
    }

    // If item is still revealing, can't loot yet
    if (item.revealProgress < 1.0) {
      return { success: false, message: 'Item is still being revealed.' };
    }

    // Try to loot the item (with potential failure chance for tension)
    const lootSuccess = Math.random() > 0.05; // 95% success rate
    if (!lootSuccess) {
      // Failed loot attempt - item becomes temporarily unavailable
      item.canBeLooted = false;
      setTimeout(() => {
        item.canBeLooted = true;
      }, 5000); // 5 seconds cooldown

      this.recordEvent({ type: 'loot_failed', data: { playerId, itemId } } as any);
      return { success: false, message: 'Failed to loot item! Try again later.' };
    }

    // Successful loot
    player.inventory.push(item);
    item.ownerId = player.id;
    item.position = undefined;
    this.gameWorld.items.splice(itemIndex, 1);

    this.recordEvent({ type: 'item_looted', data: { playerId, itemId } } as any);

    return { success: true, message: `Successfully looted ${item.name}!`, item };
  }

  // Update item reveal progress over time
  public updateItemReveals(): void {
    const now = Date.now();

    this.gameWorld.items.forEach(item => {
      if (!item.isHidden && item.revealStartTime && item.revealProgress < 1.0) {
        const elapsed = now - item.revealStartTime;
        const revealDuration = GAME_CONFIG.itemRevealTimes[item.rarity];
        item.revealProgress = Math.min(1.0, elapsed / revealDuration);

        // If fully revealed, mark as lootable
        if (item.revealProgress >= 1.0) {
          item.canBeLooted = true;
        }
      }
    });
  }

  // Use an item from player's inventory
  public useItem(playerId: string, itemId: string): GameActionResult {
    const player = this.getPlayer(playerId);
    if (!player) return { success: false, message: 'Player not found' };
    const idx = player.inventory.findIndex(i => i.id === itemId);
    if (idx === -1) return { success: false, message: 'Item not in inventory' };
    const item = player.inventory[idx];

    // Apply simple consumable effect if present
    if (item.stats?.hp) {
      const heal = Math.min(item.stats.hp, player.stats.maxHp - player.stats.hp);
      player.stats.hp += heal;
    }

    // Remove item from inventory
    player.inventory.splice(idx, 1);

    this.recordEvent({ type: 'item_used', data: { playerId, itemId } } as any);

    return { success: true, message: `Used ${item.name}` };
  }

  // Player management
  public addPlayer(player: Player): GameActionResult {
    const existing = this.gameWorld.players.find(p => p.id === player.id);
    if (existing) return { success: false, message: 'Player already exists' };

    let finalPosition: Position | null = null;
    if (player.position && this.isValidSpawnPosition(player.position.x, player.position.y)) {
      finalPosition = player.position;
    } else {
      finalPosition = this.findEmptySpawnPosition();
    }

    if (!finalPosition) {
      this.analyzeTerrainDistribution();
      this.analyzePositionOccupancy();
      return { success: false, message: 'No available spawn position' };
    }

    player.position = finalPosition;
    this.gameWorld.players.push(player);
    this.occupiedPositions.add(`${finalPosition.x},${finalPosition.y}`);
    this.availableSpawnPoints.delete(`${finalPosition.x},${finalPosition.y}`);

    this.recordEvent({ type: 'player_joined', data: { player: { ...player }, position: finalPosition } });

    return { success: true, message: `Player ${player.displayName} joined`, data: { player, position: finalPosition } };
  }

  public removePlayer(playerId: string): GameActionResult {
    const idx = this.gameWorld.players.findIndex(p => p.id === playerId);
    if (idx === -1) return { success: false, message: 'Player not found' };
    const player = this.gameWorld.players[idx];
    this.occupiedPositions.delete(`${player.position.x},${player.position.y}`);
    this.availableSpawnPoints.add(`${player.position.x},${player.position.y}`);
    this.gameWorld.players.splice(idx, 1);

    this.recordEvent({ type: 'player_left', data: { playerId, position: { ...player.position } } });

    return { success: true, message: `Player ${player.displayName} removed`, data: { player } };
  }

  // Movement
  public movePlayer(playerId: string, direction: 'up' | 'down' | 'left' | 'right'): MoveResult {
    const player = this.gameWorld.players.find(p => p.id === playerId);
    if (!player) return { success: false, message: 'Player not found' };
    if (!player.isAlive) return { success: false, message: 'Player not alive' };

    const now = Date.now();
    if (now - player.lastMoveTime < MOVEMENT_CONSTANTS.BASE_MOVE_COOLDOWN) return { success: false, message: 'Movement on cooldown' };

    const newPos = this.calculateNewPosition(player.position, direction);
    if (!this.isValidMove(player.position, newPos)) return { success: false, message: 'Invalid move' };

    if (this.isPositionOccupied(newPos)) return { success: false, message: 'Position occupied' };

    this.occupiedPositions.delete(`${player.position.x},${player.position.y}`);
    player.position = newPos;
    this.occupiedPositions.add(`${newPos.x},${newPos.y}`);
    player.lastMoveTime = now;

    this.recordEvent({ type: 'player_moved', data: { playerId, newPosition: { ...newPos }, direction } });

    return { success: true, message: 'Moved', newPosition: newPos };
  }

  private calculateNewPosition(currentPos: Position, direction: 'up' | 'down' | 'left' | 'right'): Position {
    const np = { ...currentPos };
    switch (direction) {
      case 'up': np.y -= 1; break;
      case 'down': np.y += 1; break;
      case 'left': np.x -= 1; break;
      case 'right': np.x += 1; break;
    }
    return np;
  }

  private isValidMove(from: Position, to: Position): boolean {
    if (to.x < 0 || to.x >= GAME_CONFIG.gridWidth || to.y < 0 || to.y >= GAME_CONFIG.gridHeight) return false;
    const dx = Math.abs(to.x - from.x);
    const dy = Math.abs(to.y - from.y);
    if (!((dx === 1 && dy === 0) || (dx === 0 && dy === 1))) return false;
    const terrain = this.gameWorld.grid[to.y][to.x];
    if (terrain.type === BiomeType.MOUNTAIN) return false;
    return true;
  }

  private isPositionOccupied(position: Position): boolean {
    return this.occupiedPositions.has(`${position.x},${position.y}`);
  }

  private getEnemyAtPosition(position: Position): Player | NPC | null {
    const enemyPlayer = this.gameWorld.players.find(p => p.position.x === position.x && p.position.y === position.y && p.isAlive);
    if (enemyPlayer) return enemyPlayer;
    const npc = this.gameWorld.npcs.find(n => n.position.x === position.x && n.position.y === position.y && n.isAlive);
    return npc || null;
  }

  // Combat - simplified and preserved
  public attackEnemy(attacker: Player, defender: Player | NPC): CombatResult {
    const now = Date.now();
    const damage = this.calculateDamage(attacker, defender);
    const actualDamage = Math.max(0, Math.min(damage, defender.stats.hp));
    defender.stats.hp -= actualDamage;

    if (defender.stats.hp <= 0) {
      defender.stats.hp = 0;
      defender.isAlive = false;
      this.occupiedPositions.delete(`${defender.position.x},${defender.position.y}`);
      this.availableSpawnPoints.add(`${defender.position.x},${defender.position.y}`);

      const isPlayerDefender = 'twitchUsername' in defender;
      const experience = isPlayerDefender ? 50 : 25;
      attacker.experience += experience;
      this.checkLevelUp(attacker);

      const loot = isPlayerDefender ? null : this.generateLoot(defender as NPC);

      const battleResult = { winner: attacker, loser: defender, damage: actualDamage, experience, loot, timestamp: now, type: isPlayerDefender ? 'pvp' : 'pve' };

      return { success: true, message: `Defeated`, battleResult };
    }

    const battleResult = { winner: null, damage: actualDamage, defenderHp: defender.stats.hp, defenderMaxHp: defender.stats.maxHp, timestamp: now, type: 'damage' };
    return { success: true, message: 'Hit', battleResult };
  }

  private calculateDamage(attacker: Player, defender: Player | NPC): number {
    let damage = attacker.stats.attack * COMBAT_CONSTANTS.BASE_DAMAGE_MULTIPLIER;
    const defenseReduction = defender.stats.defense * 0.1;
    damage *= (1 - Math.min(defenseReduction, 0.8));
    const isCritical = Math.random() < COMBAT_CONSTANTS.CRITICAL_HIT_CHANCE;
    if (isCritical) damage *= COMBAT_CONSTANTS.CRITICAL_DAMAGE_MULTIPLIER;

    const defenderTerrain = this.gameWorld.grid[defender.position.y][defender.position.x];
    if (defenderTerrain.type === BiomeType.FOREST) damage *= 0.9;
    if (defenderTerrain.type === BiomeType.MOUNTAIN) damage *= 0.85;

    const randomFactor = 0.9 + Math.random() * 0.2;
    damage *= randomFactor;
    return Math.max(COMBAT_CONSTANTS.MIN_DAMAGE, Math.floor(damage));
  }

  private checkLevelUp(player: Player): void {
    const expNeeded = COMBAT_CONSTANTS.EXPERIENCE_PER_LEVEL * player.level;
    if (player.experience >= expNeeded) {
      player.level += 1;
      player.experience -= expNeeded;
      const statIncrease = Math.floor(player.level * 0.5) + 1;
      player.stats.attack += statIncrease;
      player.stats.defense += statIncrease;
      player.stats.maxHp += statIncrease * 5;
      player.stats.hp = Math.min(player.stats.hp + statIncrease * 5, player.stats.maxHp);
      player.stats.speed += Math.floor(statIncrease * 0.5);
    }
  }

  private generateLoot(defeated: NPC): Item[] {
    const loot: Item[] = [];
    if (Math.random() < WORLD_CONSTANTS.ITEM_DROP_CHANCE) {
      const itemTypes = ['weapon', 'armor', 'consumable'] as const;
      const rarities = ['common', 'uncommon', 'rare'] as const;
      const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
      const rarity = rarities[Math.floor(Math.random() * rarities.length)];
      const item: Item = {
        id: `loot_${defeated.id}_${Date.now()}`,
        name: this.generateItemName(itemType as string, rarity as string),
        type: itemType as ItemType,
        rarity: rarity as ItemRarity,
        description: `A ${rarity} ${itemType} dropped by ${defeated.name}`,
        position: { ...defeated.position },
        stats: this.generateItemStats(itemType as string, rarity as string),
        // Tarkov-style looting properties
        isHidden: true, // Items start hidden
        revealDuration: GAME_CONFIG.itemRevealTimes[rarity as ItemRarity],
        revealProgress: 0.0,
        canBeLooted: false
      };
      loot.push(item);
      this.gameWorld.items.push(item);
    }
    return loot;
  }

  private generateItemName(type: string, rarity: string): string {
    const prefixes = { common: ['Basic', 'Simple', 'Plain'], uncommon: ['Good', 'Quality', 'Enhanced'], rare: ['Superior', 'Excellent', 'Masterwork'] } as any;
    const typeNames = { weapon: ['Sword', 'Dagger', 'Axe', 'Staff', 'Bow'], armor: ['Shield', 'Helmet', 'Armor', 'Boots', 'Gloves'], consumable: ['Potion', 'Elixir', 'Scroll', 'Herb'] } as any;
    const prefix = prefixes[rarity][Math.floor(Math.random() * prefixes[rarity].length)];
    const typeName = typeNames[type][Math.floor(Math.random() * typeNames[type].length)];
    return `${prefix} ${typeName}`;
  }

  private generateItemStats(type: string, rarity: string): any {
    const rarityMultipliers: Record<string, number> = { common: 1, uncommon: 1.5, rare: 2.5 };
    const multiplier = rarityMultipliers[rarity] ?? 1;
    switch (type) {
      case 'weapon': return { attack: Math.floor(5 * multiplier) };
      case 'armor': return { defense: Math.floor(3 * multiplier) };
      case 'consumable': return { hp: Math.floor(20 * multiplier) };
      default: return {};
    }
  }

  // World update loop (called externally by server loop)
  public update(): void {
    this.updateNPCs();
    this.updateCataclysm();
    this.updateItemReveals(); // Update item reveal progress
    this.processPlayerMovementQueues();
  }

  private updateNPCs(): void {
    this.gameWorld.npcs.forEach(npc => {
      if (!npc.isAlive) return;
      const now = Date.now();
      if (now - npc.lastMoveTime > 5000 && Math.random() < 0.3) {
        const directions = ['up','down','left','right'] as const;
        const direction = directions[Math.floor(Math.random() * directions.length)];
        const oldPosition = npc.position;
        const newPosition = this.calculateNewPosition(oldPosition, direction);
        const oldKey = `${oldPosition.x},${oldPosition.y}`;
        this.occupiedPositions.delete(oldKey);
        if (this.isValidMove(oldPosition, newPosition) && !this.isPositionOccupied(newPosition)) {
          npc.position = newPosition;
          this.occupiedPositions.add(`${newPosition.x},${newPosition.y}`);
          npc.lastMoveTime = now;
        } else {
          this.occupiedPositions.add(oldKey);
        }
      }
    });
  }

  private updateCataclysm(): void {
    if (!this.gameWorld.cataclysmCircle.isActive) return;
    const now = Date.now();
    if (now >= this.gameWorld.cataclysmCircle.nextShrinkTime) {
      const oldRadius = this.gameWorld.cataclysmCircle.radius;
      this.gameWorld.cataclysmCircle.radius = Math.max(0, this.gameWorld.cataclysmCircle.radius - 1);

      // Calculate roughness multiplier based on cataclysm progress
      // Start at 1.0 (normal), increase to 4.0 (very chaotic) as radius shrinks
      const initialRadius = Math.max(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight);
      const progress = 1 - (this.gameWorld.cataclysmCircle.radius / initialRadius);
      this.gameWorld.cataclysmRoughnessMultiplier = 1.0 + (progress * 3.0); // 1.0 to 4.0

      // Regenerate terrain in the newly affected area (between old and new radius)
      if (oldRadius > this.gameWorld.cataclysmCircle.radius) {
        this.regenerateTerrainInCataclysmZone(oldRadius, this.gameWorld.cataclysmCircle.radius);
      }

      if (this.gameWorld.cataclysmCircle.radius <= 0) {
        this.resetWorld();
      } else {
        this.gameWorld.cataclysmCircle.nextShrinkTime = now + 60000;
        this.gameWorld.players.forEach(player => {
          if (player.isAlive && this.isInCataclysmCircle(player.position)) {
            player.isAlive = false;
          }
        });
      }
    }
  }

  private regenerateTerrainInCataclysmZone(oldRadius: number, newRadius: number): void {
    const center = this.gameWorld.cataclysmCircle.center;

    // Regenerate terrain in the ring between oldRadius and newRadius
    for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
      for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
        const distance = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));

        // If this tile is in the affected zone (between old and new radius)
        if (distance <= oldRadius && distance > newRadius) {
          // Regenerate terrain with some cataclysm effects
          const terrainType = this.generateBiomeType();
          const config = GAME_CONFIG.terrainConfig[terrainType];

          // Apply cataclysm transformation - make terrain more chaotic
          let transformedType = terrainType;
          if (Math.random() < 0.3) { // 30% chance of transformation
            // Transform some terrain types to more dangerous/chaotic versions
            switch (terrainType) {
              case BiomeType.FOREST:
                transformedType = Math.random() < 0.5 ? BiomeType.DENSE_FOREST : BiomeType.ANCIENT_RUINS;
                break;
              case BiomeType.PLAIN:
                transformedType = Math.random() < 0.4 ? BiomeType.ROUGH_TERRAIN : BiomeType.ANCIENT_RUINS;
                break;
              case BiomeType.GRASSLAND:
                transformedType = Math.random() < 0.3 ? BiomeType.SWAMP : BiomeType.FLOWER_FIELD;
                break;
              case BiomeType.MOUNTAIN:
                transformedType = Math.random() < 0.5 ? BiomeType.MOUNTAIN_PEAK : BiomeType.ROUGH_TERRAIN;
                break;
            }
          }

          const transformedConfig = GAME_CONFIG.terrainConfig[transformedType];
          this.gameWorld.grid[y][x] = {
            type: transformedType,
            position: { x, y },
            movementCost: transformedConfig.movementCost,
            defenseBonus: transformedConfig.defenseBonus,
            visibilityModifier: transformedConfig.visibilityModifier
          } as any;
        }
      }
    }

    // Generate new NPCs in the regenerated area
    this.generateNPCsInZone(newRadius, oldRadius);
    
    // Generate enhanced loot in the regenerated zone
    this.generateCataclysmZoneLoot(newRadius, oldRadius);
  }

  private isInCataclysmCircle(position: Position): boolean {
    const center = this.gameWorld.cataclysmCircle.center;
    const distance = Math.sqrt(Math.pow(position.x - center.x,2) + Math.pow(position.y - center.y,2));
    return distance >= this.gameWorld.cataclysmCircle.radius;
  }

  private generateNPCsInZone(innerRadius: number, outerRadius: number): void {
    const center = this.gameWorld.cataclysmCircle.center;
    const npcCount = Math.floor((Math.PI * (outerRadius * outerRadius - innerRadius * innerRadius)) * WORLD_CONSTANTS.NPC_SPAWN_CHANCE * 0.5);

    for (let i = 0; i < npcCount; i++) {
      // Find a position in the affected zone
      let attempts = 0;
      let position: Position | null = null;

      while (attempts < 50 && !position) {
        const angle = Math.random() * Math.PI * 2;
        const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
        const x = Math.round(center.x + Math.cos(angle) * distance);
        const y = Math.round(center.y + Math.sin(angle) * distance);

        if (x >= 0 && x < GAME_CONFIG.gridWidth && y >= 0 && y < GAME_CONFIG.gridHeight &&
            !this.occupiedPositions.has(`${x},${y}`) &&
            this.gameWorld.grid[y][x].type !== BiomeType.MOUNTAIN) {
          position = { x, y };
        }
        attempts++;
      }

      if (position) {
        const npc: NPC = {
          id: `npc_cataclysm_${i}_${Date.now()}`,
          name: this.generateNPCName(),
          type: 'monster',
          position,
          stats: {
            hp: 40 + Math.floor(Math.random()*30),
            maxHp: 40 + Math.floor(Math.random()*30),
            attack: 5 + Math.floor(Math.random()*6),
            defense: 2 + Math.floor(Math.random()*4),
            speed: 1 + Math.floor(Math.random()*2)
          },
          behavior: 'wandering',
          lootTable: [],
          isAlive: true,
          lastMoveTime: Date.now()
        };
        this.gameWorld.npcs.push(npc);
        this.occupiedPositions.add(`${position.x},${position.y}`);
      }
    }
  }

  // Generate enhanced loot in cataclysm regenerated zones
  private generateCataclysmZoneLoot(innerRadius: number, outerRadius: number): void {
    const center = this.gameWorld.cataclysmCircle.center;
    const areaSize = Math.PI * (outerRadius * outerRadius - innerRadius * innerRadius);
    
    // Increase loot spawn rate in cataclysm zones (2x base rate)
    const lootCount = Math.floor(areaSize * GAME_CONFIG.itemSpawnRate * 2);

    for (let i = 0; i < lootCount; i++) {
      let attempts = 0;
      let position: Position | null = null;

      while (attempts < 30 && !position) {
        const angle = Math.random() * Math.PI * 2;
        const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
        const x = Math.round(center.x + Math.cos(angle) * distance);
        const y = Math.round(center.y + Math.sin(angle) * distance);

        if (x >= 0 && x < GAME_CONFIG.gridWidth && y >= 0 && y < GAME_CONFIG.gridHeight &&
            !this.occupiedPositions.has(`${x},${y}`)) {
          position = { x, y };
        }
        attempts++;
      }

      if (position) {
        const terrain = this.gameWorld.grid[position.y][position.x];
        const item = this.generateTerrainBasedLoot(position, terrain.type, true); // Enhanced cataclysm loot
        if (item) {
          this.gameWorld.items.push(item);
        }
      }
    }
  }

  // Generate terrain-based loot with enhanced properties
  private generateTerrainBasedLoot(position: Position, terrainType: BiomeType, isCataclysmLoot: boolean = false): Item | null {
    const rarityChances: Record<string, number> = isCataclysmLoot ? 
      { common: 30, uncommon: 35, rare: 25, epic: 8, legendary: 2 } : // Enhanced for cataclysm
      { common: 60, uncommon: 30, rare: 9, epic: 1 }; // Normal terrain loot

    const itemTypes = [ItemType.WEAPON, ItemType.ARMOR, ItemType.CONSUMABLE];
    const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
    const rarity = this.selectItemRarity(rarityChances);

    const item: Item = {
      id: `terrain_loot_${position.x}_${position.y}_${Date.now()}_${Math.random()}`,
      name: this.generateEnhancedItemName(itemType, rarity, terrainType),
      type: itemType,
      rarity,
      description: this.generateTerrainItemDescription(itemType, rarity, terrainType),
      position: { ...position },
      stats: this.generateEnhancedItemStats(itemType, rarity, terrainType, isCataclysmLoot),
      isHidden: true,
      revealDuration: GAME_CONFIG.itemRevealTimes[rarity],
      revealProgress: 0.0,
      canBeLooted: false
    };

    return item;
  }

  // Enhanced item name generation with terrain context
  private generateEnhancedItemName(type: ItemType, rarity: ItemRarity, terrainType: BiomeType): string {
    const terrainModifiers: Record<BiomeType, string[]> = {
      [BiomeType.ANCIENT_RUINS]: ['Ancient', 'Ruined', 'Lost', 'Forgotten'],
      [BiomeType.FOREST]: ['Wooden', 'Natural', 'Forest', 'Wild'],
      [BiomeType.MOUNTAIN]: ['Stone', 'Mountain', 'Rocky', 'Dwarven'],
      [BiomeType.SWAMP]: ['Murky', 'Bog', 'Swamp', 'Poisonous'],
      [BiomeType.ICE]: ['Frozen', 'Ice', 'Crystal', 'Arctic'],
      [BiomeType.SNOW]: ['Snow-touched', 'Frigid', 'Winter', 'Frost'],
      [BiomeType.SAND]: ['Desert', 'Sand-worn', 'Nomad', 'Sun-bleached'],
      [BiomeType.DEEP_WATER]: ['Sunken', 'Waterlogged', 'Coral', 'Deep'],
      [BiomeType.RIVER]: ['River-blessed', 'Flowing', 'Current-touched', 'Stream']
    } as Record<BiomeType, string[]>;

    const rarityPrefixes: Record<ItemRarity, string[]> = {
      [ItemRarity.COMMON]: ['Worn', 'Simple', 'Basic', 'Crude'],
      [ItemRarity.UNCOMMON]: ['Quality', 'Fine', 'Enhanced', 'Polished'],
      [ItemRarity.RARE]: ['Superior', 'Excellent', 'Masterwork', 'Pristine'],
      [ItemRarity.EPIC]: ['Legendary', 'Mythical', 'Ancient', 'Heroic'],
      [ItemRarity.LEGENDARY]: ['Divine', 'Immortal', 'Godly', 'Eternal']
    };

    const typeNames: Partial<Record<ItemType, string[]>> = {
      [ItemType.WEAPON]: ['Blade', 'Sword', 'Axe', 'Staff', 'Bow', 'Dagger', 'Mace'],
      [ItemType.ARMOR]: ['Shield', 'Helm', 'Armor', 'Boots', 'Gauntlets', 'Cloak'],
      [ItemType.CONSUMABLE]: ['Potion', 'Elixir', 'Herb', 'Essence', 'Extract', 'Tonic']
    };

    const terrainMods = terrainModifiers[terrainType] || ['Mysterious'];
    const terrainMod = terrainMods[Math.floor(Math.random() * terrainMods.length)];
    const rarityPrefix = rarityPrefixes[rarity][Math.floor(Math.random() * rarityPrefixes[rarity].length)];
    const typeNamesList = typeNames[type] || ['Item'];
    const typeName = typeNamesList[Math.floor(Math.random() * typeNamesList.length)];

    return `${rarityPrefix} ${terrainMod} ${typeName}`;
  }

  // Generate terrain-specific item descriptions
  private generateTerrainItemDescription(type: ItemType, rarity: ItemRarity, terrainType: BiomeType): string {
    const terrainContext: Record<BiomeType, string> = {
      [BiomeType.ANCIENT_RUINS]: 'discovered among ancient ruins',
      [BiomeType.FOREST]: 'found deep in the forest',
      [BiomeType.MOUNTAIN]: 'carved from mountain stone',
      [BiomeType.SWAMP]: 'recovered from murky swamplands',
      [BiomeType.ICE]: 'preserved in eternal ice',
      [BiomeType.SAND]: 'buried in desert sands'
    } as Record<BiomeType, string>;

    const context = terrainContext[terrainType] || 'found in the wilderness';
    return `A ${rarity} ${type} ${context}.`;
  }

  // Enhanced item stats with terrain and cataclysm bonuses
  private generateEnhancedItemStats(type: ItemType, rarity: ItemRarity, terrainType: BiomeType, isCataclysmLoot: boolean): any {
    const rarityMultipliers: Record<ItemRarity, number> = {
      [ItemRarity.COMMON]: 1,
      [ItemRarity.UNCOMMON]: 1.5,
      [ItemRarity.RARE]: 2.5,
      [ItemRarity.EPIC]: 4,
      [ItemRarity.LEGENDARY]: 6
    };

    let multiplier = rarityMultipliers[rarity];
    
    // Terrain bonuses
    const terrainBonuses: Record<BiomeType, number> = {
      [BiomeType.ANCIENT_RUINS]: 1.3,
      [BiomeType.MOUNTAIN]: 1.1,
      [BiomeType.MOUNTAIN_PEAK]: 1.2
    } as Record<BiomeType, number>;

    multiplier *= (terrainBonuses[terrainType] || 1.0);
    
    // Cataclysm bonus
    if (isCataclysmLoot) {
      multiplier *= 1.25;
    }

    switch (type) {
      case ItemType.WEAPON:
        return { attack: Math.floor(5 * multiplier + Math.random() * 3) };
      case ItemType.ARMOR:
        return { defense: Math.floor(3 * multiplier + Math.random() * 2) };
      case ItemType.CONSUMABLE:
        return { hp: Math.floor(20 * multiplier + Math.random() * 10) };
      default:
        return {};
    }
  }

  // Select item rarity based on weighted chances
  private selectItemRarity(rarityWeights: Record<string, number>): ItemRarity {
    const totalWeight = Object.values(rarityWeights).reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const [rarity, weight] of Object.entries(rarityWeights)) {
      random -= weight;
      if (random <= 0) {
        return rarity as ItemRarity;
      }
    }
    
    return ItemRarity.COMMON;
  }

  private resetWorld(): void {
    this.gameWorld.cataclysmCircle.isActive = false;
    this.gameWorld.cataclysmCircle.radius = 20;
    this.gameWorld.cataclysmCircle.nextShrinkTime = 0;
    this.gameWorld.cataclysmRoughnessMultiplier = 1.0; // Reset to normal
    this.gameWorld.phase = 'rebirth'; // Enter rebirth phase for regeneration effects
    this.regenerateTerrain();
    this.gameWorld.players.forEach(player => {
      if (!player.isAlive) {
        player.isAlive = true;
        player.stats.hp = player.stats.maxHp;
        const spawn = this.findEmptySpawnPosition();
        if (spawn) {
          player.position = spawn;
          this.occupiedPositions.add(`${spawn.x},${spawn.y}`);
        }
      }
    });
    // After a brief delay, return to exploration phase
    setTimeout(() => {
      this.gameWorld.phase = 'exploration';
    }, 5000); // 5 seconds of rebirth effects
  }

  private regenerateTerrain(): void {
    this.gameWorld.items = [];
    this.gameWorld.npcs = [];
    for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
      for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
        const terrainType = this.generateBiomeType();
        const config = GAME_CONFIG.terrainConfig[terrainType];
        this.gameWorld.grid[y][x] = { type: terrainType, position: { x,y }, movementCost: config.movementCost, defenseBonus: config.defenseBonus, visibilityModifier: config.visibilityModifier } as any;
      }
    }
    this.generateNPCs();
  }

  private generateBiomeType(): BiomeType {
    const rand = Math.random();
    let cumulative = 0;
    for (const [terrainType, config] of Object.entries(GAME_CONFIG.terrainConfig)) {
      cumulative += config.spawnChance;
      if (rand <= cumulative) return terrainType as BiomeType;
    }
    return BiomeType.PLAIN;
  }

  private generateNPCs(): void {
    const npcCount = Math.floor(GAME_CONFIG.gridWidth * GAME_CONFIG.gridHeight * WORLD_CONSTANTS.NPC_SPAWN_CHANCE);
    for (let i = 0; i < npcCount; i++) {
      const position = this.findEmptySpawnPosition();
      if (!position) continue;
      const npc: NPC = { id: `npc_${i}_${Date.now()}`, name: this.generateNPCName(), type: 'monster', position, stats: { hp: 30 + Math.floor(Math.random()*20), maxHp: 30 + Math.floor(Math.random()*20), attack: 3 + Math.floor(Math.random()*4), defense: 1 + Math.floor(Math.random()*3), speed: 1 + Math.floor(Math.random()*2) }, behavior: 'wandering', lootTable: [], isAlive: true, lastMoveTime: Date.now() };
      this.gameWorld.npcs.push(npc);
      this.occupiedPositions.add(`${position.x},${position.y}`);
      this.availableSpawnPoints.delete(`${position.x},${position.y}`);
    }
  }

  private generateNPCName(): string {
    const prefixes = ['Wild','Fierce','Ancient','Shadow','Blood'];
    const types = ['Wolf','Bear','Goblin','Orc','Troll','Spider','Snake'];
    return `${prefixes[Math.floor(Math.random()*prefixes.length)]} ${types[Math.floor(Math.random()*types.length)]}`;
  }

  // Helper: Calculate distance between two positions
  private getDistance(pos1: Position, pos2: Position): number {
    return Math.sqrt(Math.pow(pos2.x - pos1.x, 2) + Math.pow(pos2.y - pos1.y, 2));
  }

  // Helper: Find an empty spawn position
  private findEmptySpawnPosition(): Position | null {
    for (const point of this.availableSpawnPoints) {
      if (!this.occupiedPositions.has(point)) {
        const [x, y] = point.split(',').map(Number);
        return { x, y };
      }
    }
    return null;
  }

  // Helper: Validate if a spawn position is valid
  private isValidSpawnPosition(x: number, y: number): boolean {
    const key = `${x},${y}`;
    if (x < 0 || y < 0 || x >= GAME_CONFIG.gridWidth || y >= GAME_CONFIG.gridHeight) return false;
    const terrain = this.gameWorld.grid[y]?.[x];
    return !!terrain && terrain.type !== BiomeType.MOUNTAIN && !this.occupiedPositions.has(key);
  }

  // Diagnostic helpers
  private analyzeTerrainDistribution(): void {
    const counts: Record<string, number> = {};
    for (let y = 0; y < GAME_CONFIG.gridHeight; y++) for (let x = 0; x < GAME_CONFIG.gridWidth; x++) counts[this.gameWorld.grid[y][x].type] = (counts[this.gameWorld.grid[y][x].type] || 0) + 1;
    console.log('[TERRAIN_DISTRIBUTION]', counts);
  }

  private analyzePositionOccupancy(): void {
    console.log('[OCCUPIED_POSITIONS]', Array.from(this.occupiedPositions));
    console.log('[AVAILABLE_SPAWN_POINTS]', Array.from(this.availableSpawnPoints));
  }

  // Regenerate the world (admin command)
  public regenerateWorld(): GameActionResult {
    // Clear all existing entities
    this.gameWorld.players = [];
    this.gameWorld.npcs = [];
    this.gameWorld.items = [];

    // Reset occupied positions and available spawn points
    this.occupiedPositions.clear();
    this.availableSpawnPoints.clear();

    // Regenerate terrain
    this.regenerateTerrain();

    // Reset cataclysm
    this.gameWorld.cataclysmCircle.isActive = false;
    this.gameWorld.cataclysmCircle.radius = Math.max(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight);
    this.gameWorld.cataclysmCircle.nextShrinkTime = 0;
    this.gameWorld.cataclysmRoughnessMultiplier = 1.0;
    this.gameWorld.phase = 'exploration';

    // Reset world age
    this.gameWorld.worldAge = 0;
    this.gameWorld.lastResetTime = Date.now();

    this.recordEvent({ type: 'world_regenerated', data: { timestamp: Date.now() } } as any);

    return { success: true, message: 'World regenerated successfully' };
  }
}

// Delta event type (must be after all class/function definitions)
export type GameEvent =
  | { type: 'player_joined'; data: { player: Player; position: Position } }
  | { type: 'player_left'; data: { playerId: string; position: Position } }
  | { type: 'player_moved'; data: { playerId: string; newPosition: Position; direction: string } }
  ;
</file>

<file path="packages/backend/src/services/HandDrawnBuildingService.ts">
import { BuildingType, HandDrawnBuilding } from 'shared/types/game';

export class HandDrawnBuildingService {
  public generateBuilding(type: BuildingType, size: { width: number; height: number }): HandDrawnBuilding {
    const building: HandDrawnBuilding = {
      type,
      size,
      roughSvg: this.generateBuildingSvg(type, size),
      lootCapacity: this.calculateLootCapacity(type, size),
      searchTime: this.calculateSearchTime(type, size),
      dangerLevel: this.calculateDangerLevel(type)
    };

    return building;
  }

  private generateBuildingSvg(type: BuildingType, size: { width: number; height: number }): string {
    const { width, height } = size;
    const baseRoughness = this.getBuildingRoughness(type);

    let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width * 32}" height="${height * 32}" viewBox="0 0 ${width * 32} ${height * 32}">`;

    svg += this.roughRectangle(2, 2, width * 32 - 4, height * 32 - 4, {
      roughness: baseRoughness,
      stroke: '#4a4a4a',
      strokeWidth: 2,
      fill: this.getBuildingColor(type)
    });

    switch (type) {
      case BuildingType.HOUSE:
        svg += this.addHouseDetails(width, height, baseRoughness);
        break;
      case BuildingType.WAREHOUSE:
        svg += this.addWarehouseDetails(width, height, baseRoughness);
        break;
      case BuildingType.BUNKER:
        svg += this.addBunkerDetails(width, height, baseRoughness);
        break;
    }

    svg += this.addBattleDamage(width, height, baseRoughness * 1.5);

    svg += '</svg>';
    return svg;
  }

  private addBattleDamage(width: number, height: number, roughness: number): string {
    let damage = '';
    const damageCount = Math.floor(Math.random() * 5) + 2;

    for (let i = 0; i < damageCount; i++) {
      const x = Math.random() * width * 32;
      const y = Math.random() * height * 32;
      const size = Math.random() * 8 + 3;

      damage += this.roughCircle(x, y, size, {
        roughness: roughness * 2,
        stroke: '#222',
        strokeWidth: 1,
        fill: '#111'
      });
    }

    return damage;
  }

  private calculateLootCapacity(type: BuildingType, size: { width: number; height: number }): number {
      return size.width * size.height * 2;
  }

  private calculateSearchTime(type: BuildingType, size: { width: number; height: number }): number {
      return size.width * size.height * 5;
  }

  private calculateDangerLevel(type: BuildingType): number {
      switch (type) {
          case BuildingType.BUNKER: return 8;
          case BuildingType.WAREHOUSE: return 5;
          case BuildingType.HOUSE: return 2;
          default: return 1;
      }
  }

  private getBuildingRoughness(type: BuildingType): number {
      switch (type) {
          case BuildingType.BUNKER: return 1;
          case BuildingType.WAREHOUSE: return 2;
          case BuildingType.HOUSE: return 3;
          default: return 2;
      }
  }

  private getBuildingColor(type: BuildingType): string {
      switch (type) {
          case BuildingType.HOUSE: return '#d2b48c';
          case BuildingType.WAREHOUSE: return '#a9a9a9';
          case BuildingType.BUNKER: return '#696969';
          default: return '#cccccc';
      }
  }

  private addHouseDetails(width: number, height: number, baseRoughness: number): string {
      let details = '';
      details += this.roughRectangle(width * 16 - 8, height * 32 - 16, 16, 16, { roughness: baseRoughness, stroke: '#654321', fill: '#8b4513' });
      details += this.roughRectangle(width * 8, height * 16 - 8, 16, 16, { roughness: baseRoughness, stroke: '#000', fill: '#add8e6' });
      return details;
  }

  private addWarehouseDetails(width: number, height: number, baseRoughness: number): string {
      let details = '';
      details += this.roughRectangle(width * 16 - 24, height * 32 - 32, 48, 32, { roughness: baseRoughness, stroke: '#333', fill: '#555' });
      return details;
  }

  private addBunkerDetails(width: number, height: number, baseRoughness: number): string {
      let details = '';
      details += this.roughRectangle(width * 16 - 10, height * 32 - 20, 20, 20, { roughness: baseRoughness, stroke: '#000', fill: '#444' });
      return details;
  }

  private roughRectangle(x: number, y: number, width: number, height: number, options: any): string {
    return `<rect x="${x}" y="${y}" width="${width}" height="${height}" stroke="${options.stroke || 'black'}" stroke-width="${options.strokeWidth || 1}" fill="${options.fill || 'none'}" style="stroke-linejoin:round; stroke-linecap:round;"/>`;
  }

  private roughCircle(x: number, y: number, diameter: number, options: any): string {
    return `<circle cx="${x}" cy="${y}" r="${diameter / 2}" stroke="${options.stroke || 'black'}" stroke-width="${options.strokeWidth || 1}" fill="${options.fill || 'none'}"/>`;
  }
}
</file>

<file path="packages/backend/src/services/StreamCommentaryService.ts">
import { TwitchService } from './twitchService';
import { Player, NPC } from 'shared/src/types/game';
import { CombatResult } from './CombatService';

interface CombatEvent {
    timestamp: number;
    attacker: string;
    result: CombatResult;
}

export class StreamCommentaryService {
  private recentCombats: CombatEvent[] = [];
  private commentaryTemplates: Map<string, string[]> = new Map();

  constructor() {
    this.initializeCommentaryTemplates();
  }

  public announceCombat(attacker: Player, defender: NPC, result: CombatResult): void {
    const commentary = this.generateCombatCommentary(attacker, defender, result);

    // Track for potential combo commentary
    this.recentCombats.push({
      timestamp: Date.now(),
      attacker: attacker.id,
      result
    });

  }

  private generateCombatCommentary(attacker: Player, defender: NPC, result: CombatResult): string {
    const templates = this.commentaryTemplates.get('combat') || [];
    const template = templates[Math.floor(Math.random() * templates.length)];

    return template
      .replace('{attacker}', attacker.displayName)
      .replace('{defender}', defender.type)
      .replace('{damage}', result.damage?.toString() || '0')
      .replace('{weapon}', attacker.equipment.weapon?.name || 'bare hands');
  }

  private initializeCommentaryTemplates(): void {
    this.commentaryTemplates.set('combat', [
      '{attacker} strikes {defender} with {weapon} for {damage} damage!',
      '{attacker} delivers a devastating blow to {defender}!',
      '{defender} staggers under {attacker}\'s assault!',
      '{attacker}\'s {weapon} finds its mark on {defender}!',
      'Blood flies as {attacker} connects with {defender}!'
    ]);

    this.commentaryTemplates.set('death', [
      '{defender} falls before {attacker}\'s might!',
      'Another casualty in the wasteland... {defender} is no more!',
      '{attacker} emerges victorious over {defender}!',
      'The dust settles... {defender} will fight no more!'
    ]);
  }
}
</file>

<file path="packages/backend/src/services/StreamOptimizedTwitchService.ts">
import { Server } from 'socket.io';
import { GameStateManager } from './gameStateManager';
import { TwitchService, ChatCommand } from './twitchService';

export class StreamOptimizedTwitchService extends TwitchService {
  private commandQueue: ChatCommand[] = [];
  private processingBatch = false;
  private readonly BATCH_SIZE = 10;
  private readonly BATCH_INTERVAL = 2000; // Process every 2 seconds for stream pacing
  private batchProcessingInterval?: NodeJS.Timeout;

  constructor(io: Server, clientId: string, clientSecret: string, channelName: string, gameStateManager: GameStateManager) {
    super(io, clientId, clientSecret, channelName, gameStateManager);

    // Process commands in batches to maintain stream watchability
    this.batchProcessingInterval = setInterval(() => this.processBatchedCommands(), this.BATCH_INTERVAL);
  }

  public destroy(): void {
    if (this.batchProcessingInterval) {
      clearInterval(this.batchProcessingInterval);
      this.batchProcessingInterval = undefined;
    }
  }

  private async processBatchedCommands(): Promise<void> {
    if (this.processingBatch || this.commandQueue.length === 0) return;

    this.processingBatch = true;
    const batch = this.commandQueue.splice(0, this.BATCH_SIZE);

    // Group similar commands for dramatic effect
    const movements = batch.filter(cmd => ['up', 'down', 'left', 'right', 'move'].includes(cmd.command));
    const attacks = batch.filter(cmd => cmd.command === 'attack');
    const spawns = batch.filter(cmd => cmd.command === 'spawn');

    // Process movements as a wave
    if (movements.length > 0) {
      await this.processMovementWave(movements);
    }

    // Process attacks with combat commentary
    if (attacks.length > 0) {
      await this.processCombatWave(attacks);
    }

    // Process spawns with fanfare
    if (spawns.length > 0) {
      await this.processSpawnWave(spawns);
    }

    this.processingBatch = false;
  }

  private async processMovementWave(movements: ChatCommand[]): Promise<void> {
    const results = await Promise.all(
      movements.map(cmd => this.executeMovementCommand(cmd))
    );

    // Create engaging stream commentary
    const successful = results.filter(r => r.success).length;
    if (successful > 0) {
      this.sendStreamMessage(`ðŸƒâ€â™‚ï¸ ${successful} players moved simultaneously across the wasteland!`);
    }
  }

  private async executeMovementCommand(cmd: ChatCommand): Promise<{ success: boolean; message?: string }> {
    const player = this.getExistingPlayer(cmd.username);
    if (!player) {
      return { success: false, message: "Player not found" };
    }

    let direction: 'up' | 'down' | 'left' | 'right' | undefined;

    if (cmd.command === 'move' && cmd.args.length > 0) {
        const arg = cmd.args[0].toLowerCase();
        if (['up', 'down', 'left', 'right'].includes(arg)) {
            direction = arg as 'up' | 'down' | 'left' | 'right';
        }
    } else if (['up', 'down', 'left', 'right'].includes(cmd.command)) {
        direction = cmd.command as 'up' | 'down' | 'left' | 'right';
    }

    if (!direction) {
        return { success: false, message: "Invalid movement command" };
    }

    const message = this.handleMovementCommand(cmd, direction);
    return { success: !message.includes("Cannot move there!") };
  }

  private async processCombatWave(attacks: ChatCommand[]): Promise<void> {
    for (const attack of attacks) {
      const handler = this.commandHandlers.get('attack');
      if (handler) {
        await handler.handler(attack);
      }
    }
  }

  private async processSpawnWave(spawns: ChatCommand[]): Promise<void> {
    for (const spawn of spawns) {
      const handler = this.commandHandlers.get('spawn');
      if (handler) {
        await handler.handler(spawn);
      }
    }
  }

  public async processChatMessage(twitchMessage: any): Promise<void> {
    if (!twitchMessage.message.startsWith('!')) {
      return;
    }

    const parts = twitchMessage.message.substring(1).split(' ');
    const command = parts[0].toLowerCase();
    const args = parts.slice(1);

    const chatCommand: ChatCommand = {
        command,
        args,
        username: twitchMessage.username,
        displayName: twitchMessage.displayName,
        userId: twitchMessage.username,
        channelPoints: twitchMessage.channelPoints || 0,
        timestamp: Date.now()
    };

    this.commandQueue.push(chatCommand);
  }

  public async sendStreamMessage(message: string): Promise<void> {
    // Override base method, return a promise
    await this.sendChatResponse(message);
  }
}
</file>

<file path="packages/backend/src/services/webSocketServer.test.ts">
import { createServer, Server as HTTPServer } from 'http';
import { AddressInfo } from 'net';
import { io as ioc, Socket as ClientSocket } from 'socket.io-client';
import { WebSocketServer } from './webSocketServer';

describe('WebSocketServer', () => {
    let httpServer: HTTPServer;
    let wsServer: WebSocketServer;
    let clientSocket: ClientSocket;
    let port: number;

    beforeAll((done) => {
        httpServer = createServer();
        wsServer = new WebSocketServer(httpServer);

        httpServer.listen(() => {
            port = (httpServer.address() as AddressInfo).port;
            done();
        });
    });

    afterAll(() => {
        wsServer.shutdown();
        httpServer.close();
    });

    beforeEach((done) => {
        clientSocket = ioc(`http://localhost:${port}`, {
            reconnection: false,
            transports: ['websocket'],
        });

        clientSocket.on('connect', () => {
            done();
        });
    });

    afterEach(() => {
        if (clientSocket.connected) {
            clientSocket.disconnect();
        }
    });

    it('should allow a client to connect', () => {
        expect(clientSocket.connected).toBe(true);
    });

    it('should allow a client to disconnect', (done) => {
        clientSocket.on('disconnect', () => {
            expect(clientSocket.connected).toBe(false);
            done();
        });
        clientSocket.disconnect();
    });

    describe('Stale Connection Cleanup', () => {
        it('should not remove an active player if their old socket is cleaned up', (done) => {
            const playerId = 'player-1';
            const oldSocketId = 'stale-socket-id';

            // Manually add a stale entry to connectedClients
            const connectedClients = wsServer['connectedClients'];
            connectedClients.set(oldSocketId, {
                playerId,
                socketId: oldSocketId,
                connectedAt: Date.now() - 70000, // 70 seconds ago
            });

            // Manually add the NEW, ACTIVE socket entry for the player
            const playerSockets = wsServer['playerSockets'];
            if (clientSocket.id) {
                playerSockets.set(playerId, clientSocket.id);
            } else {
                return done(new Error('Client socket ID is not available'));
            }

            // Manually trigger the cleanup
            wsServer['cleanupStaleClientData']();

            // Assert that the active player's socket is still tracked
            expect(playerSockets.has(playerId)).toBe(true);
            expect(playerSockets.get(playerId)).toBe(clientSocket.id);

            // Assert that the stale socket entry was removed
            expect(connectedClients.has(oldSocketId)).toBe(false);

            done();
        });
    });
});
</file>

<file path="packages/backend/jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.ts?(x)', '**/?(*.)+(spec|test).ts?(x)'],
  moduleNameMapper: {
    '^@chatterealm/shared$': '<rootDir>/../shared/src',
    '^@chatterealm/shared/(.*)$': '<rootDir>/../shared/src/$1',
  },
};
</file>

<file path="packages/frontend/src/components/character/CharacterBuilder.test.tsx">
import React from 'react';
import { render, fireEvent, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import CharacterBuilder from '../CharacterBuilder';
import { PlayerClass } from 'shared';
import { vi } from 'vitest';

// Mock the is-unicode-supported library
vi.mock('is-unicode-supported', () => ({
  __esModule: true,
  default: (str: string) => {
    // For testing purposes, we'll consider any non-empty string as a valid emoji
    return str.length > 0;
  },
}));

describe('CharacterBuilder', () => {
  const onJoinGame = vi.fn();
  const onClose = vi.fn();

  it('should allow entering a complex emoji', () => {
    render(
      <CharacterBuilder
        isOpen={true}
        onClose={onClose}
        onJoinGame={onJoinGame}
      />
    );

    const emojiInput = screen.getByPlaceholderText('Type emoji here...');
    const complexEmoji = 'ðŸ‘®ðŸ¾â€â™‚ï¸'; // This emoji has a length of 7

    fireEvent.change(emojiInput, { target: { value: complexEmoji } });

    expect(emojiInput).toHaveValue(complexEmoji);
  });
});
</file>

<file path="packages/frontend/src/components/character/SVGAvatarUpload.tsx">
import React, { useState, useRef } from 'react';
import { MaterialCard, MaterialButton, MaterialChip } from '../index';
import { assetConverter } from '../../services/assetConverter';

interface SVGAvatarUploadProps {
  onAvatarSelect: (svg: string, roughSvg: string) => void;
  currentAvatar?: string;
}

const SVGAvatarUpload: React.FC<SVGAvatarUploadProps> = ({
  onAvatarSelect,
  currentAvatar
}) => {
  const [uploadedSvg, setUploadedSvg] = useState<string>('');
  const [roughSvg, setRoughSvg] = useState<string>('');
  const [isConverting, setIsConverting] = useState(false);
  const [error, setError] = useState<string>('');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (file.type !== 'image/svg+xml') {
      setError('Please select a valid SVG file');
      return;
    }

    if (file.size > 1024 * 1024) { // 1MB limit
      setError('File size must be less than 1MB');
      return;
    }

    const reader = new FileReader();
    reader.onload = async (e) => {
      const content = e.target?.result as string;
      setUploadedSvg(content);
      setError('');

      // Auto-convert to rough style
      setIsConverting(true);
      try {
        const result = await assetConverter.convertSvgToRough(content, {
          roughness: 1.2,
          bowing: 1.5,
          randomize: true,
          pencilFilter: true
        });
        setRoughSvg(result.svg);
      } catch (err) {
        setError('Failed to convert SVG');
        console.error('SVG conversion error:', err);
      } finally {
        setIsConverting(false);
      }
    };
    reader.readAsText(file);
  };

  const handleUseAvatar = () => {
    if (roughSvg) {
      onAvatarSelect(uploadedSvg, roughSvg);
    }
  };

  const resetUpload = () => {
    setUploadedSvg('');
    setRoughSvg('');
    setError('');
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  return (
    <MaterialCard
      sx={{
        background: 'rgba(49, 46, 56, 0.8)',
        border: '1px solid rgba(196, 167, 231, 0.2)',
        borderRadius: '12px'
      }}
    >
      <div className="p-4">
        <h4 className="text-[var(--color-text-primary)] mb-3">ðŸŽ¨ Custom SVG Avatar</h4>

        <input
          ref={fileInputRef}
          type="file"
          accept=".svg"
          onChange={handleFileUpload}
          className="hidden"
        />

        {!uploadedSvg ? (
          <MaterialButton
            onClick={() => fileInputRef.current?.click()}
            variant="outlined"
            fullWidth
            sx={{
              borderColor: 'rgba(196, 167, 231, 0.5)',
              color: 'var(--color-text-primary)',
              '&:hover': {
                borderColor: 'rgba(196, 167, 231, 0.8)',
                backgroundColor: 'rgba(196, 167, 231, 0.1)'
              }
            }}
          >
            ðŸ“ Upload SVG Avatar
          </MaterialButton>
        ) : (
          <div className="flex flex-col gap-3">
            {/* Preview */}
            <div className="flex gap-3 items-center justify-center">
              <div className="text-center">
                <p className="text-[var(--color-text-secondary)] text-sm mb-1">Original</p>
                <div className="w-[60px] h-[60px] bg-[rgba(0,0,0,0.2)] rounded-md flex items-center justify-center border border-[var(--color-outline)]">
                  <div className="text-2xl" dangerouslySetInnerHTML={{ __html: uploadedSvg }} />
                </div>
              </div>

              <div className="text-center">
                <p className="text-[var(--color-text-secondary)] text-sm mb-1">Rough Style</p>
                <div className="w-[60px] h-[60px] bg-[rgba(0,0,0,0.2)] rounded-md flex items-center justify-center border border-[var(--color-outline)]">
                  {isConverting ? (
                    <div className="text-[var(--color-text-secondary)]">ðŸ”„</div>
                  ) : roughSvg ? (
                    <div className="text-2xl" dangerouslySetInnerHTML={{ __html: roughSvg }} />
                  ) : (
                    <div className="text-[var(--color-text-secondary)]">âŒ</div>
                  )}
                </div>
              </div>
            </div>

            {/* Action Buttons */}
            <div className="flex gap-2">
              <MaterialButton
                onClick={handleUseAvatar}
                disabled={!roughSvg || isConverting}
                variant="contained"
                size="small"
                sx={{
                  flex: 1,
                  backgroundColor: 'rgba(76, 175, 80, 0.8)',
                  color: 'white',
                  '&:hover': {
                    backgroundColor: 'rgba(76, 175, 80, 1)'
                  },
                  '&:disabled': {
                    backgroundColor: 'rgba(76, 175, 80, 0.3)'
                  }
                }}
              >
                âœ“ Use This
              </MaterialButton>

              <MaterialButton
                onClick={resetUpload}
                variant="outlined"
                size="small"
                sx={{
                  borderColor: 'rgba(244, 67, 54, 0.5)',
                  color: 'var(--color-text-primary)',
                  '&:hover': {
                    borderColor: 'rgba(244, 67, 54, 0.8)',
                    backgroundColor: 'rgba(244, 67, 54, 0.1)'
                  }
                }}
              >
                â†» Reset
              </MaterialButton>
            </div>
          </div>
        )}

        {error && (
          <div className="mt-3 text-[#ff6b6b] bg-[rgba(255,107,107,0.1)] p-2 rounded-md border border-[rgba(255,107,107,0.3)] text-sm">
            âŒ {error}
          </div>
        )}

        <div className="mt-3">
          <MaterialChip
            label="SVG â†’ Rough.js conversion"
            size="small"
            sx={{
              backgroundColor: 'rgba(196, 167, 231, 0.2)',
              color: 'var(--color-text-primary)',
              fontSize: '0.7rem'
            }}
          />
        </div>
      </div>
    </MaterialCard>
  );
};

export default SVGAvatarUpload;
</file>

<file path="packages/frontend/src/components/chat/ChatWindow.tsx">
import React from 'react';
import MessageList from './MessageList';
import MessageInput from './MessageInput';
import { ChatMessage, Player } from '../../types/chat';
import SmartSuggestions from './SmartSuggestions';

interface ChatWindowProps {
  messages: ChatMessage[];
  inputMessage: string;
  setInputMessage: (message: string) => void;
  handleKeyPress: (e: React.KeyboardEvent) => void;
  sendChatCommand: () => void;
  isConnected: boolean;
  username: string;
  displayName: string;
  channelPoints: number;
  setChannelPoints: (points: number) => void;
  players: Player[];
  presetCommands: string[];
  setInputMessageAndFocus: (message: string) => void;
}

const ChatWindow: React.FC<ChatWindowProps> = ({
  messages,
  inputMessage,
  setInputMessage,
  handleKeyPress,
  sendChatCommand,
  isConnected,
  username,
  displayName,
  channelPoints,
  setChannelPoints,
  players,
  presetCommands,
  setInputMessageAndFocus,
}) => {
  return (
    <div className="chat-container">
      <h1 style={{ color: '#e0def4', marginBottom: '20px', fontSize: '1.5em' }}>
        ðŸŽ® Chat Grid Chronicles - Chat Test Interface
      </h1>

      {/* Connection Status */}
      <div className={`connection-status ${isConnected ? 'connected' : 'disconnected'}`}>
        Status: {isConnected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected'}
      </div>

      {/* User Settings */}
      <div className="user-settings">
        <h3>ðŸ‘¤ User Settings</h3>
        <div className="user-input-grid">
          <input
            type="text"
            placeholder="Username"
            value={username}
            onChange={(e) => {
              // Ensure username always starts with 'testuser' if changed.
              const value = e.target.value;
              if (value.startsWith('testuser') || value === '') {
                // If it starts with 'testuser' or is empty, allow direct setting
                setInputMessage(value);
              } else {
                // Prepend 'testuser' if it's changed to something else.
                setInputMessage(`testuser${value}`);
              }
            }}
          />
          <input
            type="text"
            placeholder="Display Name"
            value={displayName}
            onChange={(e) => setInputMessage(e.target.value)}
          />
          <input
            type="number"
            placeholder="Channel Points"
            value={channelPoints}
            onChange={(e) => setChannelPoints(Number(e.target.value))}
          />
        </div>
      </div>

      {/* Players List */}
      <div className="players-list">
        <h3>ðŸŽ­ Active Players ({players.length})</h3>
        {players.length === 0 ? (
          <p style={{ color: '#908caa', padding: '10px' }}>No players in game</p>
        ) : (
          players.map(player => (
            <div key={player.id} className="player-card">
              <span className="player-avatar-small">{player.avatar}</span>
              <div className="player-info">
                <h4>{player.displayName}</h4>
                <div className="player-stats">
                  HP: {player.stats.hp}/{player.stats.maxHp} |
                  ATK: {player.stats.attack} |
                  DEF: {player.stats.defense} |
                  Pos: ({player.position.x}, {player.position.y})
                </div>
              </div>
            </div>
          ))
        )}
      </div>

      <MessageList messages={messages} username={username} />

      <div style={{ position: 'relative' }}>
        <SmartSuggestions
            currentInput={inputMessage}
            gameContext={{
                recentMessages: messages.slice(-5).map(m => m.message),
                activeQuests: [], // This will need to be passed down from the game state
                nearbyPlayers: players.map(p => p.displayName),
                currentActivity: 'chatting', // This will need to be passed down from the game state
            }}
            onSelectSuggestion={(suggestion) => setInputMessageAndFocus(suggestion)}
        />
        <MessageInput
            inputMessage={inputMessage}
            setInputMessage={setInputMessage}
            handleKeyPress={handleKeyPress}
            sendChatCommand={sendChatCommand}
            isConnected={isConnected}
        />
      </div>

      {/* Preset Commands */}
      <div className="quick-commands">
        <h3>âš¡ Quick Commands</h3>
        <div className="command-buttons">
          {presetCommands.map(command => (
            <button
              key={command}
              onClick={() => setInputMessageAndFocus(command)}
              className="command-btn"
            >
              {command}
            </button>
          ))}
        </div>
      </div>

      {/* Help */}
      <div className="help-section">
        <h3>ðŸ“– How to Use</h3>
        <ul className="help-list">
          <li>Change your username and display name above</li>
          <li>Type commands starting with <code>!</code> (like <code>!help</code>)</li>
          <li>Click preset commands or type your own</li>
          <li>Watch the chat responses and player list update in real-time</li>
          <li>Try <code>!spawn knight</code> to join the game!</li>
        </ul>
      </div>
    </div>
  );
};

export default ChatWindow;
</file>

<file path="packages/frontend/src/components/chat/MessageList.tsx">
import React from 'react';
import { ChatMessage } from '../../types/chat';

interface MessageListProps {
  messages: ChatMessage[];
  username: string; // Add username prop here
}

const MessageList: React.FC<MessageListProps> = ({ messages, username }) => {
  return (
    <div className="chat-messages">
      {messages.length === 0 ? (
        <p style={{ color: '#6e6a86', textAlign: 'center', marginTop: '50px' }}>
          No messages yet. Try sending a command!
        </p>
      ) : (
        messages.map((msg, index) => (
          <div
            key={index}
            className={`chat-message ${msg.isResponse ? 'bot' : 'user'} ${
              msg.isError ? 'error' : ''
            }`}
          >
            <div className="message-sender">
              {msg.isError
                ? 'ðŸš« System Error'
                : msg.isResponse
                ? 'ðŸ¤– Bot'
                : `ðŸ‘¤ ${msg.displayName || username}`}
            </div>
            <div
              className="message-text"
              style={{ color: msg.isError ? '#ff5f5f' : 'inherit' }}
            >
              {msg.message}
            </div>
            <div className="message-time">
              {new Date(msg.timestamp).toLocaleTimeString()}
            </div>
          </div>
        ))
      )}
    </div>
  );
};

export default MessageList;
</file>

<file path="packages/frontend/src/components/GameCanvas/index.ts">
// Re-export default GameCanvas for simpler imports from sibling components
export { default } from './GameCanvas';
</file>

<file path="packages/frontend/src/components/layout/GameLayout.tsx">
import React, { useState } from 'react';
import GameCanvas from '../GameCanvas/GameCanvas';
import NotificationSystem from '../notifications/NotificationSystem';
import { PlayerSidebar } from '../index';
import MaterialCard from '../ui/MaterialCard';
import MaterialChip from '../ui/MaterialChip';
import MaterialPaper from '../ui/MaterialPaper';
import { useGameStore } from '../../stores/gameStore';
import { COLORS } from '../utils/tokens';
import { PlayerClass } from 'shared';

interface GameLayoutProps {
  handleRegenerateWorld: () => void;
  movePlayer: (direction: 'up' | 'down' | 'left' | 'right') => void;
  handleJoinGame: () => void;
  handleStartCataclysm: () => void;
  handlePickUpItem: () => void;
}

const GameLayout: React.FC<GameLayoutProps> = ({
  handleRegenerateWorld,
  movePlayer,
  handleJoinGame,
  handleStartCataclysm,
  handlePickUpItem,
}) => {
  const { gameWorld, currentPlayer, gameMessage } = useGameStore();

  const handleJoin = () => {
    handleJoinGame();
  };

  return (
    <div className="flex flex-col h-screen w-screen m-0 p-0 overflow-hidden box-border bg-[var(--color-background-primary)] font-inter">
      <NotificationSystem />

      {/* Header */}
      <div className="p-4 border-b border-[var(--color-outline)] bg-[var(--color-surface-variant)]">
        <div className="flex items-center justify-between">
          <h1 className="font-serif text-xl font-extrabold text-text-primary m-0 uppercase tracking-widest text-center header-gradient">chatterealm</h1>
          <div className="flex items-center gap-4">
            <MaterialChip
              label={`Phase: ${gameWorld?.phase || 'Unknown'}`}
              size="small"
              sx={{ backgroundColor: 'rgba(76, 175, 80, 0.2)' }}
            />
            <MaterialChip
              label={`${gameWorld?.players?.length || 0} Players`}
              size="small"
              sx={{ backgroundColor: 'rgba(33, 150, 243, 0.2)' }}
            />
            <MaterialChip
              label={`${gameWorld?.npcs?.length || 0} NPCs`}
              size="small"
              sx={{ backgroundColor: 'rgba(156, 39, 176, 0.2)' }}
            />
          </div>
        </div>

        {/* Game Message */}
        {gameMessage && (
          <MaterialCard sx={{ mt: 2, p: 2, backgroundColor: 'var(--color-primary-container)', border: '1px solid var(--color-primary)' }}>
            <p className="text-sm text-[var(--color-on-primary-container)] m-0">{gameMessage}</p>
          </MaterialCard>
        )}
      </div>

      {/* Main Content Area - Two Column Layout */}
      <div className="flex flex-1 overflow-hidden">
        {/* Game Canvas - Left Side, Scales to Fit */}
        <div className="flex-1 relative flex items-center justify-center overflow-hidden bg-[var(--color-surface)]">
          <div className="w-full h-full max-w-[calc(100vw-320px)] overflow-hidden">
            <GameCanvas />
          </div>

          {/* Material UI Legend - Positioned over game canvas */}
          <MaterialPaper
            sx={{
              position: 'absolute',
              bottom: '20px',
              left: '50%',
              transform: 'translateX(-50%)',
              display: 'flex',
              gap: 1,
              p: 1,
              zIndex: 1000,
              backgroundColor: 'rgba(25, 23, 36, 0.95)',
              backdropFilter: 'blur(10px)',
            }}
            className="rounded-md"
          >
            <MaterialChip label="Knight" size="small" sx={{ backgroundColor: 'var(--color-legend-knight)', color: 'white', fontSize: '0.7rem', height: '20px' }} />
            <MaterialChip label="Rogue" size="small" sx={{ backgroundColor: 'var(--color-legend-rogue)', color: 'white', fontSize: '0.7rem', height: '20px' }} />
            <MaterialChip label="Mage" size="small" sx={{ backgroundColor: 'var(--color-legend-mage)', color: 'white', fontSize: '0.7rem', height: '20px' }} />
            <MaterialChip label="NPC" size="small" sx={{ backgroundColor: 'var(--color-legend-npc)', color: 'white', fontSize: '0.7rem', height: '20px' }} />
            <MaterialChip label="Item" size="small" sx={{ backgroundColor: 'var(--color-legend-item)', color: 'white', fontSize: '0.7rem', height: '20px' }} />
          </MaterialPaper>
        </div>

        {/* Right Sidebar - Player Controls and Settings */}
        <PlayerSidebar />
      </div>
    </div>
  );
};

export default GameLayout;
</file>

<file path="packages/frontend/src/components/layout/MaterialAppBar.tsx">
import React from 'react';
import { AppBar, Toolbar, Typography, IconButton, Box } from '@mui/material';
import { Menu as MenuIcon } from '@mui/icons-material';
import { Z_INDEX, COMMON_STYLES, TYPOGRAPHY, SPACING } from '../../utils/designSystem';

interface MaterialAppBarProps {
  title?: string;
  onMenuClick?: () => void;
  children?: React.ReactNode;
  sx?: any;
}

const MaterialAppBar: React.FC<MaterialAppBarProps> = ({
  title = "ðŸ—ºï¸ Chat Grid Chronicles",
  onMenuClick,
  children,
  sx = {}
}) => {
  return (
    <AppBar
      position="fixed"
      sx={{
        zIndex: Z_INDEX.appBar,
        backgroundColor: COMMON_STYLES.glass.background,
        backdropFilter: COMMON_STYLES.glass.backdropFilter,
        borderBottom: COMMON_STYLES.glass.border,
        borderBottomColor: 'divider',
        ...sx
      }}
    >
      <Toolbar>
        {onMenuClick && (
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={onMenuClick}
            sx={{ mr: SPACING.md }}
          >
            <MenuIcon />
          </IconButton>
        )}
        <Typography
          variant="h6"
          noWrap
          component="div"
          sx={{
            fontFamily: TYPOGRAPHY.fontFamily.code,
            fontWeight: TYPOGRAPHY.fontWeight.semibold,
            fontSize: TYPOGRAPHY.fontSize.lg
          }}
        >
          {title}
        </Typography>
        <Box sx={{ flexGrow: 1 }} />
        {children}
      </Toolbar>
    </AppBar>
  );
};

export default MaterialAppBar;
</file>

<file path="packages/frontend/src/components/layout/ModeNavigation.tsx">
import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import MaterialButton from '../ui/MaterialButton';
import MaterialChip from '../ui/MaterialChip';
import MaterialPaper from '../ui/MaterialPaper';
import MaterialIcon from '../ui/MaterialIcon';
import { TYPOGRAPHY, SPACING, BORDER_RADIUS, COMMON_STYLES, ANIMATION } from '../../utils/designSystem';

interface ModeNavigationProps {
  compact?: boolean;
  variant?: 'compact' | 'expanded' | 'dropdown';
  position?: 'header' | 'sidebar' | 'floating';
}

interface ModeConfig {
  path: string;
  label: string;
  icon: string;
  description: string;
  color: string;
  features: string[];
}

const modes: Array<ModeConfig> = [
  {
    path: '/play',
    label: 'Play',
    icon: 'ðŸŽ®',
    description: 'Join the realm and play',
    color: 'rgba(76, 175, 80, 0.2)',
    features: ['Character creation', 'Real-time gameplay', 'Player interaction', 'Live world state']
  },
  {
    path: '/spectate',
    label: 'Spectate',
    icon: 'ðŸ‘ï¸',
    description: 'Watch ongoing games',
    color: 'rgba(33, 150, 243, 0.2)',
    features: ['Live game monitoring', 'Player statistics', 'World overview', 'Real-time updates']
  },
  {
    path: '/dev',
    label: 'Dev',
    icon: 'ðŸ› ï¸',
    description: 'Developer tools & testing',
    color: 'rgba(244, 67, 54, 0.2)',
    features: ['Debug tools', 'Performance metrics', 'World generation', 'Testing utilities']
  }
];

const ModeNavigation: React.FC<ModeNavigationProps> = ({
  compact = false,
  variant = 'compact',
  position = 'header'
}) => {
  const navigate = useNavigate();
  const location = useLocation();
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);

  const currentMode = modes.find((mode) => mode.path === location.pathname);

  const handleModeSwitch = (path: string) => {
    navigate(path);
    setIsDropdownOpen(false);
  };

  const getButtonStyles = (mode: ModeConfig, isCurrent: boolean) => ({
    minWidth: 'auto',
    px: position === 'header' ? SPACING.sm : SPACING.md,
    py: position === 'header' ? SPACING.xs : SPACING.sm,
    fontSize: position === 'header' ? TYPOGRAPHY.fontSize.xs : TYPOGRAPHY.fontSize.sm,
    textTransform: 'none',
    backgroundColor: isCurrent ? mode.color : 'transparent',
    borderColor: 'rgba(196, 167, 231, 0.3)',
    color: 'var(--color-text-primary)',
    '&:hover': {
      backgroundColor: isCurrent ? mode.color : 'rgba(196, 167, 231, 0.1)',
      borderColor: 'rgba(196, 167, 231, 0.5)',
      transform: 'translateY(-1px)',
    },
    transition: `all ${ANIMATION.fast} ease`,
  });

  // Compact header navigation
  if (variant === 'compact' || compact) {
    return (
      <div className="flex gap-1 items-center">
        {modes.map((mode) => (
          <MaterialButton
            key={mode.path}
            variant={location.pathname === mode.path ? 'contained' : 'outlined'}
            size="small"
            onClick={() => handleModeSwitch(mode.path)}
            sx={getButtonStyles(mode, location.pathname === mode.path)}
          >
            <span style={{ marginRight: SPACING.xs }}>{mode.icon}</span>
            {mode.label}
          </MaterialButton>
        ))}
      </div>
    );
  }

  // Expanded sidebar navigation
  if (variant === 'expanded') {
    return (
      <MaterialPaper
        sx={{
          p: SPACING.md,
          ...COMMON_STYLES.glass,
          borderRadius: BORDER_RADIUS.lg,
          minWidth: '240px',
        }}
      >
        <div style={{ marginBottom: SPACING.md }}>
          <h3 style={{
            margin: 0,
            color: 'var(--color-text-primary)',
            fontSize: TYPOGRAPHY.fontSize.lg,
            fontWeight: TYPOGRAPHY.fontWeight.semibold,
            display: 'flex',
            alignItems: 'center',
            gap: SPACING.sm
          }}>
            <MaterialIcon>dashboard</MaterialIcon>
            Interface Mode
          </h3>

          {currentMode && (
            <MaterialChip
              label={currentMode.description}
              size="small"
              sx={{
                backgroundColor: currentMode.color,
                color: 'var(--color-text-primary)',
                fontSize: TYPOGRAPHY.fontSize.xs,
                mt: SPACING.xs,
              }}
            />
          )}
        </div>

        <div style={{ display: 'flex', flexDirection: 'column', gap: SPACING.sm }}>
          {modes.map((mode) => (
            <MaterialButton
              key={mode.path}
              variant={location.pathname === mode.path ? 'contained' : 'outlined'}
              fullWidth
              onClick={() => handleModeSwitch(mode.path)}
              sx={{
                ...getButtonStyles(mode, location.pathname === mode.path),
                justifyContent: 'flex-start',
                py: SPACING.md,
                '&:hover': {
                  ...getButtonStyles(mode, location.pathname === mode.path)['&:hover'],
                  transform: 'translateX(4px)',
                },
              }}
            >
              <span style={{ marginRight: SPACING.sm, fontSize: TYPOGRAPHY.fontSize.lg }}>
                {mode.icon}
              </span>
              <div style={{ textAlign: 'left' }}>
                <div style={{ fontWeight: TYPOGRAPHY.fontWeight.medium }}>
                  {mode.label}
                </div>
                <div style={{
                  fontSize: TYPOGRAPHY.fontSize.xs,
                  color: 'var(--color-text-secondary)',
                  marginTop: '2px'
                }}>
                  {mode.description}
                </div>
              </div>
            </MaterialButton>
          ))}
        </div>

        {/* Mode features */}
        {currentMode && (
          <div style={{ marginTop: SPACING.lg }}>
            <h4 style={{
              margin: 0,
              color: 'var(--color-text-primary)',
              fontSize: TYPOGRAPHY.fontSize.sm,
              fontWeight: TYPOGRAPHY.fontWeight.medium,
              marginBottom: SPACING.sm
            }}>
              {currentMode.label} Features
            </h4>
            <div style={{ display: 'flex', flexDirection: 'column', gap: SPACING.xs }}>
              {currentMode.features.map((feature, index) => (
                <div
                  key={index}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: SPACING.sm,
                    fontSize: TYPOGRAPHY.fontSize.xs,
                    color: 'var(--color-text-secondary)'
                  }}
                >
                  <MaterialIcon sx={{ fontSize: TYPOGRAPHY.fontSize.sm, color: 'var(--color-text-primary)' }}>
                    check_circle
                  </MaterialIcon>
                  {feature}
                </div>
              ))}
            </div>
          </div>
        )}
      </MaterialPaper>
    );
  }

  // Dropdown navigation (for mobile/floating)
  return (
    <div style={{ position: 'relative' }}>
      <MaterialButton
        variant="outlined"
        onClick={() => setIsDropdownOpen(!isDropdownOpen)}
        sx={{
          borderColor: 'rgba(196, 167, 231, 0.3)',
          color: 'var(--color-text-primary)',
          '&:hover': {
            borderColor: 'rgba(196, 167, 231, 0.5)',
            backgroundColor: 'rgba(196, 167, 231, 0.1)',
          },
        }}
      >
        {currentMode ? (
          <>
            <span style={{ marginRight: SPACING.sm }}>{currentMode.icon}</span>
            {currentMode.label}
          </>
        ) : (
          'Select Mode'
        )}
        <MaterialIcon sx={{ ml: SPACING.xs }}>
          {isDropdownOpen ? 'expand_less' : 'expand_more'}
        </MaterialIcon>
      </MaterialButton>

      {isDropdownOpen && (
        <MaterialPaper
          sx={{
            position: 'absolute',
            top: '100%',
            right: 0,
            mt: SPACING.xs,
            p: SPACING.xs,
            minWidth: '200px',
            ...COMMON_STYLES.glass,
            borderRadius: BORDER_RADIUS.lg,
            zIndex: 1000,
          }}
        >
          {modes.map((mode) => (
            <MaterialButton
              key={mode.path}
              variant={location.pathname === mode.path ? 'contained' : 'text'}
              fullWidth
              onClick={() => handleModeSwitch(mode.path)}
              sx={{
                justifyContent: 'flex-start',
                textTransform: 'none',
                py: SPACING.sm,
                backgroundColor: location.pathname === mode.path ? mode.color : 'transparent',
                color: 'var(--color-text-primary)',
                '&:hover': {
                  backgroundColor: 'rgba(196, 167, 231, 0.1)',
                },
              }}
            >
              <span style={{ marginRight: SPACING.sm }}>{mode.icon}</span>
              <div style={{ textAlign: 'left' }}>
                <div style={{ fontWeight: TYPOGRAPHY.fontWeight.medium }}>
                  {mode.label}
                </div>
                <div style={{
                  fontSize: TYPOGRAPHY.fontSize.xs,
                  color: 'var(--color-text-secondary)'
                }}>
                  {mode.description}
                </div>
              </div>
            </MaterialButton>
          ))}
        </MaterialPaper>
      )}
    </div>
  );
};

export default ModeNavigation;
</file>

<file path="packages/frontend/src/components/layouts/DevLayout.tsx">
import React from 'react';
import GameCanvas from '../GameCanvas';
import { MaterialChip, MaterialPaper } from '../index'; // Removed MaterialAppBar
import { useGameStore } from '../../stores/gameStore';
import { TYPOGRAPHY, SPACING, COMMON_STYLES } from '../../utils/designSystem'; // Import design system tokens

interface DevLayoutProps {
  children?: React.ReactNode;
}

const DevLayout: React.FC<DevLayoutProps> = ({ children }) => {
  const { gameWorld } = useGameStore();

  return (
    <>
      {/* Main Content Area */}
      <div style={{
        display: 'flex',
        flex: 1,
        overflow: 'hidden'
      }}>
        {/* Game Canvas */}
        <div style={{
          flex: 1,
          background: 'var(--color-surface)',
          overflow: 'hidden',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          position: 'relative'
        }}>
          <div style={{
            width: '100%',
            height: '100%',
            maxWidth: '100%', // Adjusted for BaseLayout
            maxHeight: '100%', // Adjusted for BaseLayout
            aspectRatio: '16/9',
            overflow: 'hidden'
          }}>
            <GameCanvas />
          </div>

          {/* Game Legend */}
          <MaterialPaper
            sx={{
              position: 'absolute',
              bottom: SPACING.md,
              left: '50%',
              transform: 'translateX(-50%)',
              display: 'flex',
              gap: SPACING.xs,
              p: SPACING.xs,
              zIndex: 1000,
              ...COMMON_STYLES.glass,
            }}
          >
            <MaterialChip
              label="Knight"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-knight)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
            <MaterialChip
              label="Rogue"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-rogue)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
            <MaterialChip
              label="Mage"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-mage)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
            <MaterialChip
              label="NPC"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-npc)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
            <MaterialChip
              label="Item"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-item)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
          </MaterialPaper>

          {/* Developer Overlay */}
          <MaterialPaper
            sx={{
              position: 'absolute',
              top: SPACING.md,
              left: SPACING.md,
              p: SPACING.md,
              zIndex: 1000,
              ...COMMON_STYLES.glass,
              maxWidth: '350px'
            }}
          >
            <div style={{ display: 'flex', flexDirection: 'column', gap: SPACING.sm }}>
              <h3 style={{
                margin: 0,
                color: 'var(--color-text-primary)',
                fontSize: TYPOGRAPHY.fontSize.md,
                fontWeight: TYPOGRAPHY.fontWeight.semibold
              }}>
                Developer Status
              </h3>
              <div style={{ display: 'flex', flexDirection: 'column', gap: SPACING.xs }}>
                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span style={{ color: 'var(--color-text-secondary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    World Size:
                  </span>
                  <span style={{ color: 'var(--color-text-primary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    {gameWorld?.grid?.[0]?.length || 0} Ã— {gameWorld?.grid?.length || 0}
                  </span>
                </div>
                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span style={{ color: 'var(--color-text-secondary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    World Age:
                  </span>
                  <span style={{ color: 'var(--color-text-primary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    {gameWorld?.worldAge || 0}s
                  </span>
                </div>
                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span style={{ color: 'var(--color-text-secondary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    Cataclysm:
                  </span>
                  <span style={{
                    color: gameWorld?.cataclysmCircle?.isActive ? 'var(--color-error)' : 'var(--color-success)',
                    fontSize: TYPOGRAPHY.fontSize.sm
                  }}>
                    {gameWorld?.cataclysmCircle?.isActive ? 'Active' : 'Inactive'}
                  </span>
                </div>
                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span style={{ color: 'var(--color-text-secondary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    Memory Usage:
                  </span>
                  <span style={{ color: 'var(--color-text-primary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    {(performance as any).memory?.usedJSHeapSize ?
                      `${Math.round((performance as any).memory.usedJSHeapSize / 1024 / 1024)}MB` :
                      'N/A'
                    }
                  </span>
                </div>
                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span style={{ color: 'var(--color-text-secondary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    FPS:
                  </span>
                  <span style={{ color: 'var(--color-text-primary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    {Math.round(1000 / (performance.now() / 1000))} fps
                  </span>
                </div>
              </div>
            </div>
          </MaterialPaper>
          {/* Dev route content (if any) */}
          {children && (
            <div style={{ position: 'absolute', top: 120, left: 24, right: 24, bottom: 24, overflow: 'auto', zIndex: 1100 }}>
              {children}
            </div>
          )}
        </div>

  {/* Sidebar is rendered by BaseLayout */}
      </div>
    </>
  );
};

export default DevLayout;
</file>

<file path="packages/frontend/src/components/layouts/SpectateLayout.tsx">
import React from 'react';
import GameCanvas from '../GameCanvas';
import { MaterialChip, MaterialPaper } from '../index'; // Removed MaterialAppBar
import { useGameStore } from '../../stores/gameStore';
import { TYPOGRAPHY, SPACING, COMMON_STYLES } from '../../utils/designSystem'; // Import design system tokens

const SpectateLayout: React.FC = () => {
  const { gameWorld } = useGameStore();

  return (
    <>
      {/* Main Content Area */}
      <div style={{
        display: 'flex',
        flex: 1,
        overflow: 'hidden'
      }}>
        {/* Game Canvas */}
        <div style={{
          flex: 1,
          background: 'var(--color-surface)',
          overflow: 'hidden',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          position: 'relative'
        }}>
          <div style={{
            width: '100%',
            height: '100%',
            maxWidth: '100%', // Adjusted for BaseLayout
            maxHeight: '100%', // Adjusted for BaseLayout
            aspectRatio: '16/9',
            overflow: 'hidden'
          }}>
            <GameCanvas />
          </div>

          {/* Game Legend */}
          <MaterialPaper
            sx={{
              position: 'absolute',
              bottom: SPACING.md,
              left: '50%',
              transform: 'translateX(-50%)',
              display: 'flex',
              gap: SPACING.xs,
              p: SPACING.xs,
              zIndex: 1000,
              ...COMMON_STYLES.glass,
            }}
          >
            <MaterialChip
              label="Knight"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-knight)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
            <MaterialChip
              label="Rogue"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-rogue)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
            <MaterialChip
              label="Mage"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-mage)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
            <MaterialChip
              label="NPC"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-npc)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
            <MaterialChip
              label="Item"
              size="small"
              sx={{
                backgroundColor: 'var(--color-legend-item)',
                color: 'white',
                fontSize: TYPOGRAPHY.fontSize.xs,
                height: '20px'
              }}
            />
          </MaterialPaper>

          {/* Spectator Overlay */}
          <MaterialPaper
            sx={{
              position: 'absolute',
              top: SPACING.md,
              left: SPACING.md,
              p: SPACING.md,
              zIndex: 1000,
              ...COMMON_STYLES.glass,
              maxWidth: '300px'
            }}
          >
            <div style={{ display: 'flex', flexDirection: 'column', gap: SPACING.sm }}>
              <h3 style={{
                margin: 0,
                color: 'var(--color-text-primary)',
                fontSize: TYPOGRAPHY.fontSize.md,
                fontWeight: TYPOGRAPHY.fontWeight.semibold
              }}>
                Live Game Status
              </h3>
              <div style={{ display: 'flex', flexDirection: 'column', gap: SPACING.xs }}>
                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span style={{ color: 'var(--color-text-secondary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    World Size:
                  </span>
                  <span style={{ color: 'var(--color-text-primary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    {gameWorld?.grid?.[0]?.length || 0} Ã— {gameWorld?.grid?.length || 0}
                  </span>
                </div>
                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span style={{ color: 'var(--color-text-secondary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    Active Players:
                  </span>
                  <span style={{ color: 'var(--color-text-primary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    {gameWorld?.players?.filter(p => p.isAlive)?.length || 0}
                  </span>
                </div>
                <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                  <span style={{ color: 'var(--color-text-secondary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    World Age:
                  </span>
                  <span style={{ color: 'var(--color-text-primary)', fontSize: TYPOGRAPHY.fontSize.sm }}>
                    {gameWorld?.worldAge || 0}s
                  </span>
                </div>
              </div>
            </div>
          </MaterialPaper>
        </div>

  {/* Sidebar is rendered by BaseLayout */}
      </div>
    </>
  );
};

export default SpectateLayout;
</file>

<file path="packages/frontend/src/components/notifications/NotificationSystem.tsx">
import React, { useEffect } from 'react';
import NotificationContainer from './NotificationContainer';
import { useNotifications } from '../../hooks/useNotifications';
import { notificationQueue } from '../../services/notification/NotificationQueue';
import { createNotification } from '../../services/notification/NotificationFactory';
import { NotificationData } from '../types/notification';

interface NotificationSystemProps {
  maxNotifications?: number;
}

const NotificationSystem: React.FC<NotificationSystemProps> = ({ 
  maxNotifications = 5 
}) => {
  const { notifications, removeNotification } = useNotifications();

  React.useEffect(() => {
    // Optionally set maxNotifications on the queue instance
    // notificationQueue.setMaxNotifications(maxNotifications); // Add this method to NotificationQueue if needed

    const handleGlobalNotification = (event: CustomEvent<Omit<NotificationData, 'id'>>) => {
      const notification = createNotification(event.detail);
      notificationQueue.addNotification(notification);
    };

    window.addEventListener('game-notification', handleGlobalNotification as EventListener);
    
    return () => {
      window.removeEventListener('game-notification', handleGlobalNotification as EventListener);
    };
  }, []);

  return (
    <NotificationContainer
      notifications={notifications}
      onDismiss={removeNotification}
    />
  );
};

export default NotificationSystem;
</file>

<file path="packages/frontend/src/components/panels/ChatPanel.tsx">
// packages/frontend/src/components/panels/ChatPanel.tsx
import React from 'react';

const ChatPanel: React.FC = () => {
  return (
    <div>
      <h3>Chat</h3>
      {/* Chat content will go here */}
      <p>Chat is currently under construction.</p>
    </div>
  );
};

export default ChatPanel;
</file>

<file path="packages/frontend/src/components/panels/FriendsPanel.tsx">
// packages/frontend/src/components/panels/FriendsPanel.tsx
import React from 'react';

const FriendsPanel: React.FC = () => {
  return (
    <div>
      <h3>Friends</h3>
      {/* Friends list content will go here */}
      <p>Friends list is currently under construction.</p>
    </div>
  );
};

export default FriendsPanel;
</file>

<file path="packages/frontend/src/components/player/PlayerProfile/index.ts">
export { default } from './PlayerProfile';
</file>

<file path="packages/frontend/src/components/player/PlayerProfile/PlayerProfile.test.tsx">
import React from 'react';
import { render, screen } from '@testing-library/react';
import PlayerProfileComponent from './PlayerProfile';
import { PlayerClass, PlayerProfile } from 'shared';

const mockProfile: PlayerProfile = {
  id: '1',
  displayName: 'Test Player',
  avatar: 'ðŸ˜Š',
  class: PlayerClass.KNIGHT,
  level: 5,
  bio: 'A test player.',
  achievements: ['Achievement 1', 'Achievement 2'],
  titles: ['Title 1', 'Title 2'],
};

describe('PlayerProfileComponent', () => {
  it('renders the player profile information', () => {
    render(<PlayerProfileComponent profile={mockProfile} />);

    expect(screen.getByText('Test Player')).toBeInTheDocument();
    expect(screen.getByText('Level 5 knight')).toBeInTheDocument();
    expect(screen.getByText('A test player.')).toBeInTheDocument();
    expect(screen.getByText('Achievement 1')).toBeInTheDocument();
    expect(screen.getByText('Title 1')).toBeInTheDocument();
  });
});
</file>

<file path="packages/frontend/src/components/player/PlayerProfile/PlayerProfile.tsx">
import React from 'react';
import { PlayerProfile } from 'shared';

interface PlayerProfileProps {
  profile: PlayerProfile;
}

const PlayerProfileComponent: React.FC<PlayerProfileProps> = ({ profile }) => {
  return (
    <div className="p-4 bg-gray-800 text-white rounded-lg">
      <div className="flex items-center mb-4">
        <div className="text-4xl mr-4">{profile.avatar}</div>
        <div>
          <h2 className="text-2xl font-bold">{profile.displayName}</h2>
          <p className="text-gray-400">Level {profile.level} {profile.class}</p>
        </div>
      </div>
      <div>
        <h3 className="text-lg font-semibold">Bio</h3>
        <p className="text-gray-300">{profile.bio}</p>
      </div>
      <div className="mt-4">
        <h3 className="text-lg font-semibold">Achievements</h3>
        <ul className="list-disc list-inside">
          {profile.achievements.map((achievement, index) => (
            <li key={index}>{achievement}</li>
          ))}
        </ul>
      </div>
      <div className="mt-4">
        <h3 className="text-lg font-semibold">Titles</h3>
        <ul className="list-disc list-inside">
          {profile.titles.map((title, index) => (
            <li key={index}>{title}</li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default PlayerProfileComponent;
</file>

<file path="packages/frontend/src/components/player/PlayerProfile/PlayerProfileWrapper.tsx">
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { PlayerProfile } from 'shared';
import { useGameStore } from '../../../stores/gameStore';
import PlayerProfileComponent from './PlayerProfile';

const PlayerProfileWrapper: React.FC = () => {
  const { playerId } = useParams<{ playerId: string }>();
  const [profile, setProfile] = useState<PlayerProfile | null>(null);
  const { socket } = useGameStore();

  useEffect(() => {
    if (socket && playerId) {
      socket.emit('get_player_profile', playerId);
      socket.on('player_profile', (data: PlayerProfile) => {
        setProfile(data);
      });
    }

    return () => {
      if (socket) {
        socket.off('player_profile');
      }
    };
  }, [socket, playerId]);

  if (!profile) {
    return <div>Loading...</div>;
  }

  return <PlayerProfileComponent profile={profile} />;
};

export default PlayerProfileWrapper;
</file>

<file path="packages/frontend/src/components/player/EnhancedPlayerStatus.tsx">
import React from 'react';
import { PlayerStatus } from './PlayerStatus';
import { EnhancedPlayerStatusProps } from '../../types/playerStatus';
import { usePlayerStatus } from '../../hooks/usePlayerStatus'; // Import the custom hook

const EnhancedPlayerStatus: React.FC<EnhancedPlayerStatusProps> = ({ player }) => {
  const { stats, effects } = usePlayerStatus(player); // Use the custom hook

  return <PlayerStatus stats={stats} effects={effects} player={player} />;
};

export default EnhancedPlayerStatus;
</file>

<file path="packages/frontend/src/components/settings/ActionsModal.tsx">
import React from 'react';
import { useGameStore } from '../../stores/gameStore';
import { PlayerClass } from 'shared';
import { MaterialButton, MaterialCard } from '../index';

const ActionsModal: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  const {
    gameWorld,
    joinGame,
    movePlayer,
    pickupItem,
    startCataclysm,
    handleRegenerateWorld
  } = useGameStore();

  const handleJoin = () => joinGame({
    id: `player_${Date.now()}`,
    displayName: 'Player' + Math.floor(Math.random() * 1000),
    class: PlayerClass.KNIGHT,
    avatar: 'ðŸ™‚'
  });
  const handleMove = (dir: 'up' | 'down' | 'left' | 'right') => movePlayer(dir);
  const handlePickup = () => pickupItem('nearest');
  const handleCataclysm = () => startCataclysm();
  const handleRegenerate = () => handleRegenerateWorld();

  return (
    <div className="p-6 h-full overflow-auto font-mono bg-gradient-to-br from-background-primary/95 to-surface/90">
      {/* Modal Header */}
      <div className="flex items-center justify-between mb-8 pb-4 border-b-2 border-primary/30">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-red-400 to-red-600 flex items-center justify-center shadow-lg shadow-red-500/30">
            <span className="text-2xl">âš”ï¸</span>
          </div>
          <div>
            <h1 className="m-0 text-text-primary text-2xl font-bold text-shadow">
              Actions
            </h1>
            <p className="mt-1 mb-0 text-text-secondary text-sm font-normal">
              Player controls and world events
            </p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="w-10 h-10 rounded-full bg-white/10 border-none text-text-primary cursor-pointer flex items-center justify-center text-lg transition-all duration-200 hover:bg-white/20 hover:scale-105"
        >
          âœ•
        </button>
      </div>

      <div className="flex flex-col gap-6">
        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(244, 67, 54, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(244, 67, 54, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(244, 67, 54, 0.15)',
              borderColor: 'rgba(244, 67, 54, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-red-400 to-red-600 flex items-center justify-center">
              <span className="text-lg">ðŸ•¹ï¸</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              Player Actions
            </h3>
          </div>
          <div className="grid grid-cols-[repeat(auto-fit,minmax(120px,1fr))] gap-3">
            <MaterialButton
              onClick={handleJoin}
              sx={{
                height: '48px',
                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                border: '1px solid rgba(76, 175, 80, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(76, 175, 80, 0.2)',
                  transform: 'translateY(-1px)'
                }
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                <span style={{ fontSize: '1.1rem' }}>ðŸ”Œ</span>
                <span>Join Game</span>
              </div>
            </MaterialButton>
            <MaterialButton
              onClick={() => handleMove('up')}
              sx={{
                height: '48px',
                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                border: '1px solid rgba(33, 150, 243, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(33, 150, 243, 0.2)',
                  transform: 'translateY(-1px)'
                }
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                <span style={{ fontSize: '1.1rem' }}>â†‘</span>
                <span>Up</span>
              </div>
            </MaterialButton>
            <MaterialButton
              onClick={() => handleMove('down')}
              sx={{
                height: '48px',
                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                border: '1px solid rgba(33, 150, 243, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(33, 150, 243, 0.2)',
                  transform: 'translateY(-1px)'
                }
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                <span style={{ fontSize: '1.1rem' }}>â†“</span>
                <span>Down</span>
              </div>
            </MaterialButton>
            <MaterialButton
              onClick={() => handleMove('left')}
              sx={{
                height: '48px',
                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                border: '1px solid rgba(33, 150, 243, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(33, 150, 243, 0.2)',
                  transform: 'translateY(-1px)'
                }
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                <span style={{ fontSize: '1.1rem' }}>â†</span>
                <span>Left</span>
              </div>
            </MaterialButton>
            <MaterialButton
              onClick={() => handleMove('right')}
              sx={{
                height: '48px',
                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                border: '1px solid rgba(33, 150, 243, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(33, 150, 243, 0.2)',
                  transform: 'translateY(-1px)'
                }
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                <span style={{ fontSize: '1.1rem' }}>â†’</span>
                <span>Right</span>
              </div>
            </MaterialButton>
            <MaterialButton
              onClick={handlePickup}
              sx={{
                height: '48px',
                backgroundColor: 'rgba(255, 152, 0, 0.1)',
                border: '1px solid rgba(255, 152, 0, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(255, 152, 0, 0.2)',
                  transform: 'translateY(-1px)'
                }
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                <span style={{ fontSize: '1.1rem' }}>ðŸŽ’</span>
                <span>Pick Up</span>
              </div>
            </MaterialButton>
          </div>
        </MaterialCard>

        <MaterialCard
          sx={{
            backgroundColor: 'rgba(25, 23, 36, 0.8)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(244, 67, 54, 0.2)',
            borderRadius: '16px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(244, 67, 54, 0.1)',
            transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            '&:hover': {
              transform: 'translateY(-2px)',
              boxShadow: '0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(244, 67, 54, 0.15)',
              borderColor: 'rgba(244, 67, 54, 0.3)'
            }
          }}
        >
          <div className="flex items-center gap-3 mb-5">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-red-400 to-red-600 flex items-center justify-center">
              <span className="text-lg">ðŸŒ©ï¸</span>
            </div>
            <h3 className="m-0 text-text-primary text-lg font-semibold">
              World Events
            </h3>
          </div>
          <div className="grid grid-cols-[repeat(auto-fit,minmax(140px,1fr))] gap-3">
            <MaterialButton
              onClick={handleRegenerate}
              sx={{
                height: '48px',
                backgroundColor: 'rgba(0, 188, 212, 0.1)',
                border: '1px solid rgba(0, 188, 212, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(0, 188, 212, 0.2)',
                  transform: 'translateY(-1px)'
                }
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                <span style={{ fontSize: '1.1rem' }}>ðŸŒ</span>
                <span>Regenerate</span>
              </div>
            </MaterialButton>
            <MaterialButton
              onClick={handleCataclysm}
              sx={{
                height: '48px',
                backgroundColor: 'rgba(244, 67, 54, 0.1)',
                border: '1px solid rgba(244, 67, 54, 0.2)',
                '&:hover': {
                  backgroundColor: 'rgba(244, 67, 54, 0.2)',
                  transform: 'translateY(-1px)'
                }
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px'
              }}>
                <span style={{ fontSize: '1.1rem' }}>âš¡</span>
                <span>Cataclysm</span>
              </div>
            </MaterialButton>
          </div>

          {gameWorld && (
            <div className="mt-5 p-4 bg-surface/60 rounded-xl border border-red-500/20">
              <div className="flex items-center gap-2 mb-3">
                <div className="w-6 h-6 rounded bg-gradient-to-br from-red-400 to-red-600 flex items-center justify-center">
                  <span className="text-sm">ðŸ“Š</span>
                </div>
                <h4 className="m-0 text-text-primary text-base font-semibold">
                  World Properties
                </h4>
              </div>
              <div className="grid grid-cols-2 gap-2 text-sm">
                <div style={{ color: 'var(--color-text-secondary)' }}>
                  <strong>Cataclysm:</strong> {gameWorld.cataclysmCircle.isActive ? 'Active' : 'Inactive'}
                </div>
                {gameWorld.cataclysmCircle.isActive && (
                  <div style={{ color: 'var(--color-text-secondary)' }}>
                    <strong>Radius:</strong> {gameWorld.cataclysmCircle.radius.toFixed(1)}
                  </div>
                )}
                <div className="text-text-secondary col-span-full">
                  <strong>Last Reset:</strong> {new Date(gameWorld.lastResetTime).toLocaleTimeString()}
                </div>
              </div>
            </div>
          )}
        </MaterialCard>
      </div>
    </div>
  );
};

export default ActionsModal;
</file>

<file path="packages/frontend/src/components/sidebar/panels/ActionsPanel.tsx">
import React from 'react';
import { Player, PlayerClass } from 'shared';

interface ActionsPanelProps {
  currentPlayer: Player | null;
  onJoin: () => void;
  onMove: (direction: 'up' | 'down' | 'left' | 'right') => void;
  onPickup: () => void;
  onRegenerate: () => void;
  onCataclysm: () => void;
}

const ActionsPanel: React.FC<ActionsPanelProps> = ({
  currentPlayer,
  onJoin,
  onMove,
  onPickup,
  onRegenerate,
  onCataclysm
}) => {
  return (
    <div className="py-4">
      {/* Quick Actions */}
      <div className="mb-5">
        <h4 className="text-[var(--color-text-primary)] text-sm font-semibold mb-3">Quick Actions</h4>

        <div className="flex flex-col gap-2">
          {!currentPlayer && (
            <button
              onClick={onJoin}
              className="bg-[var(--color-primary)] text-[var(--color-on-primary)] rounded-md px-3 py-2 text-sm font-medium flex items-center gap-2 transform transition-transform duration-150 hover:scale-[1.02]"
            >
              ðŸ”Œ Join Game
            </button>
          )}

          {currentPlayer && (
            <>
              {/* Movement Controls */}
              <div className="grid grid-cols-3 gap-1 mb-2">
                <div />
                <button onClick={() => onMove('up')} className="w-8 h-8 rounded-sm border text-[var(--color-text-primary)] bg-[var(--color-surface-variant)] border-[var(--color-outline)] flex items-center justify-center text-sm transition-colors duration-150 hover:bg-[var(--color-primary-container)]">â†‘</button>
                <div />

                <button onClick={() => onMove('left')} className="w-8 h-8 rounded-sm border text-[var(--color-text-primary)] bg-[var(--color-surface-variant)] border-[var(--color-outline)] flex items-center justify-center text-sm transition-colors duration-150 hover:bg-[var(--color-primary-container)]">â†</button>

                <button onClick={() => onMove('down')} className="w-8 h-8 rounded-sm border text-[var(--color-text-primary)] bg-[var(--color-surface-variant)] border-[var(--color-outline)] flex items-center justify-center text-sm transition-colors duration-150 hover:bg-[var(--color-primary-container)]">â†“</button>

                <button onClick={() => onMove('right')} className="w-8 h-8 rounded-sm border text-[var(--color-text-primary)] bg-[var(--color-surface-variant)] border-[var(--color-outline)] flex items-center justify-center text-sm transition-colors duration-150 hover:bg-[var(--color-primary-container)]">â†’</button>
              </div>

              <button onClick={onPickup} className="bg-[var(--color-secondary)] text-[var(--color-on-secondary)] rounded-md px-3 py-2 text-sm font-medium flex items-center gap-2 transform transition-transform duration-150 hover:scale-[1.02]">ðŸŽ’ Pick Up</button>
            </>
          )}

          <button onClick={onRegenerate} className="bg-[var(--color-tertiary)] text-[var(--color-on-tertiary)] rounded-md px-3 py-2 text-sm font-medium flex items-center gap-2 transform transition-transform duration-150 hover:scale-[1.02]">ðŸŒ Regen World</button>

          <button onClick={onCataclysm} className="bg-[var(--color-error)] text-[var(--color-on-error)] rounded-md px-3 py-2 text-sm font-medium flex items-center gap-2 transform transition-transform duration-150 hover:scale-[1.02]">âš¡ Cataclysm</button>
        </div>
      </div>
    </div>
  );
};

export default ActionsPanel;
</file>

<file path="packages/frontend/src/components/sidebar/panels/AudioSettings.tsx">
import React from 'react';

interface UnifiedSettings {
  audio: {
    audioMasterVolume: number;
    sfxVolume: number;
    musicVolume: number;
  };
}

interface AudioSettingsProps {
  unifiedSettings: UnifiedSettings;
  updateAudioSettings: (settings: Partial<UnifiedSettings['audio']>) => void;
}

const AudioSettings: React.FC<AudioSettingsProps> = ({
  unifiedSettings,
  updateAudioSettings
}) => {
  return (
    <div className="py-4">
      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">Master Volume: {unifiedSettings.audio.audioMasterVolume}%</label>
        <input
          type="range"
          min="0"
          max="100"
          value={unifiedSettings.audio.audioMasterVolume}
          onChange={(e) => updateAudioSettings({ audioMasterVolume: parseInt(e.target.value) })}
          className="w-full"
        />
      </div>

      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">SFX Volume: {unifiedSettings.audio.sfxVolume}%</label>
        <input
          type="range"
          min="0"
          max="100"
          value={unifiedSettings.audio.sfxVolume}
          onChange={(e) => updateAudioSettings({ sfxVolume: parseInt(e.target.value) })}
          className="w-full"
        />
      </div>

      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">Music Volume: {unifiedSettings.audio.musicVolume}%</label>
        <input
          type="range"
          min="0"
          max="100"
          value={unifiedSettings.audio.musicVolume}
          onChange={(e) => updateAudioSettings({ musicVolume: parseInt(e.target.value) })}
          className="w-full"
        />
      </div>
    </div>
  );
};

export default AudioSettings;
</file>

<file path="packages/frontend/src/components/sidebar/panels/GameplaySettings.tsx">
import React from 'react';

interface UnifiedSettings {
  game: {
    autoSaveEnabled: boolean;
    showDamageNumbers: boolean;
    minimapEnabled: boolean;
  };
}

interface GameplaySettingsProps {
  unifiedSettings: UnifiedSettings;
  updateGameSettings: (settings: Partial<UnifiedSettings['game']>) => void;
}

const GameplaySettings: React.FC<GameplaySettingsProps> = ({
  unifiedSettings,
  updateGameSettings
}) => {
  return (
    <div className="py-4">
      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">Auto-Save</label>
        <input
          type="checkbox"
          checked={unifiedSettings.game.autoSaveEnabled}
          onChange={(e) => updateGameSettings({ autoSaveEnabled: e.target.checked })}
          className="mr-2"
        />
      </div>

      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">Show Damage Numbers</label>
        <input
          type="checkbox"
          checked={unifiedSettings.game.showDamageNumbers}
          onChange={(e) => updateGameSettings({ showDamageNumbers: e.target.checked })}
          className="mr-2"
        />
      </div>

      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">Mini-map</label>
        <input
          type="checkbox"
          checked={unifiedSettings.game.minimapEnabled}
          onChange={(e) => updateGameSettings({ minimapEnabled: e.target.checked })}
          className="mr-2"
        />
      </div>
    </div>
  );
};

export default GameplaySettings;
</file>

<file path="packages/frontend/src/components/sidebar/panels/OverviewPanel.tsx">
import React from 'react';
import { GameWorld, Player } from 'shared';

interface OverviewPanelProps {
  gameWorld: GameWorld | null;
  currentPlayer: Player | null;
  gameMessage: string | null;
}

const OverviewPanel: React.FC<OverviewPanelProps> = ({
  gameWorld,
  currentPlayer,
  gameMessage
}) => {
  return (
    <div className="py-4">
      {/* World Snapshot */}
      <div className="rounded-md p-3 mb-3 border bg-[var(--color-surface-variant)]/60 border-[var(--color-outline)]">
        <h4 className="text-[var(--color-text-primary)] text-sm font-semibold m-0 flex items-center gap-1.5">ðŸ—ºï¸ World Status</h4>
        <div className="grid grid-cols-2 gap-1.5 text-xs">
          <div className="text-[var(--color-text-secondary)]"><strong>Players:</strong> {gameWorld ? gameWorld.players.length : 0}</div>
          <div className="text-[var(--color-text-secondary)]"><strong>NPCs:</strong> {gameWorld ? gameWorld.npcs.length : 0}</div>
          <div className="text-[var(--color-text-secondary)]"><strong>Items:</strong> {gameWorld ? gameWorld.items.length : 0}</div>
          <div className="text-[var(--color-text-secondary)]"><strong>Age:</strong> {gameWorld?.worldAge || 0}</div>
        </div>
      </div>

      {/* Player Info */}
      {currentPlayer && (
        <div className="rounded-md p-3 mb-3 border bg-[var(--color-surface-variant)]/60 border-[var(--color-outline)]">
          <h4 className="text-[var(--color-text-primary)] text-sm font-semibold m-0 flex items-center gap-1.5">ðŸ§‘ Player</h4>
          <div className="grid grid-cols-2 gap-1.5 text-xs">
            <div className="text-[var(--color-text-secondary)]"><strong>HP:</strong> {currentPlayer.stats.hp}/{currentPlayer.stats.maxHp}</div>
            <div className="text-[var(--color-text-secondary)]"><strong>Level:</strong> {currentPlayer.level}</div>
            <div className="text-[var(--color-text-secondary)]"><strong>Pos:</strong> {currentPlayer.position.x},{currentPlayer.position.y}</div>
            <div className="text-[var(--color-text-secondary)]"><strong>XP:</strong> {currentPlayer.experience}</div>
          </div>
        </div>
      )}

      {/* Game Message */}
      {gameMessage && (
        <div className="rounded-md p-3 text-[var(--color-text-primary)] text-sm bg-[var(--color-primary-container)]/8 border border-[var(--color-primary)]/20">
          {gameMessage}
        </div>
      )}
    </div>
  );
};

export default OverviewPanel;
</file>

<file path="packages/frontend/src/components/sidebar/panels/PlayerSummaryPanel.tsx">
import React from 'react';
import { Player } from 'shared';

interface PlayerSummaryPanelProps {
  player: Player | null;
}

const PlayerSummaryPanel: React.FC<PlayerSummaryPanelProps> = ({ player }) => {
  if (!player) {
    return (
      <div className="py-2 text-sm text-[var(--color-text-secondary)]">Not in game</div>
    );
  }

  const playerName = player.displayName || player.name || 'Unknown';
  const playerClass = player.characterClass?.name || player.class || 'Unknown';
  const hp = player.stats?.hp ?? player.health ?? 0;
  const maxHp = player.stats?.maxHp ?? 0;
  const inventoryCount = player.inventory ? player.inventory.length : 0;

  return (
    <div className="py-4">
      <h4 className="text-[var(--color-text-primary)] text-sm font-semibold mb-3">Player Status</h4>
      <div className="flex flex-col gap-2 text-sm">
        <div className="flex justify-between">
          <span className="text-[var(--color-text-secondary)]">Name</span>
          <span className="font-medium">{playerName}</span>
        </div>

        <div className="flex justify-between">
          <span className="text-[var(--color-text-secondary)]">Class</span>
          <span className="font-medium">{String(playerClass)}</span>
        </div>

        <div className="flex justify-between">
          <span className="text-[var(--color-text-secondary)]">HP</span>
          <span className="font-medium">{hp}/{maxHp}</span>
        </div>

        <div className="flex justify-between">
          <span className="text-[var(--color-text-secondary)]">Inventory</span>
          <span className="font-medium">{inventoryCount}</span>
        </div>
      </div>
    </div>
  );
};

export default PlayerSummaryPanel;
</file>

<file path="packages/frontend/src/components/sidebar/panels/VisualSettings.tsx">
import React from 'react';

interface UnifiedSettings {
  visual: {
    showGrid: boolean;
    showParticles: boolean;
  };
  animations: {
    animationSpeed: number;
  };
}

interface VisualSettingsProps {
  unifiedSettings: UnifiedSettings;
  updateVisualSettings: (settings: Partial<UnifiedSettings['visual']>) => void;
  updateAnimationSettings: (settings: Partial<UnifiedSettings['animations']>) => void;
}

const VisualSettings: React.FC<VisualSettingsProps> = ({
  unifiedSettings,
  updateVisualSettings,
  updateAnimationSettings
}) => {
  return (
    <div className="py-4">
      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">Show Grid</label>
        <input
          type="checkbox"
          checked={unifiedSettings.visual.showGrid}
          onChange={(e) => updateVisualSettings({ showGrid: e.target.checked })}
          className="mr-2"
        />
      </div>

      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">Show Particles</label>
        <input
          type="checkbox"
          checked={unifiedSettings.visual.showParticles}
          onChange={(e) => updateVisualSettings({ showParticles: e.target.checked })}
          className="mr-2"
        />
      </div>

      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">Animation Speed: {unifiedSettings.animations.animationSpeed}x</label>
        <input
          type="range"
          min="0.1"
          max="3"
          step="0.1"
          value={unifiedSettings.animations.animationSpeed}
          onChange={(e) => updateAnimationSettings({ animationSpeed: parseFloat(e.target.value) })}
          className="w-full"
        />
      </div>
    </div>
  );
};

export default VisualSettings;
</file>

<file path="packages/frontend/src/components/sidebar/panels/WorldSettings.tsx">
import React from 'react';

interface UnifiedSettings {
  world: {
    worldWidth: number;
    worldHeight: number;
    grassWaveSpeed: number;
    treeSwaySpeed: number;
    flowerSpawnRate: number;
    windSpeed: number;
  };
}

interface WorldSettingsProps {
  unifiedSettings: UnifiedSettings;
  updateWorldSettings: (settings: Partial<UnifiedSettings['world']>) => void;
}

const WorldSettings: React.FC<WorldSettingsProps> = ({
  unifiedSettings,
  updateWorldSettings
}) => {
  return (
    <div className="py-4">
      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">World Width: {unifiedSettings.world.worldWidth}</label>
        <input
          type="range"
          min="20"
          max="100"
          step="5"
          value={unifiedSettings.world.worldWidth}
          onChange={(e) => updateWorldSettings({ worldWidth: parseInt(e.target.value) })}
          className="w-full"
        />
      </div>

      <div className="mb-4">
        <label className="block mb-2 text-[var(--color-text-primary)] text-sm font-medium">World Height: {unifiedSettings.world.worldHeight}</label>
        <input
          type="range"
          min="15"
          max="75"
          step="3"
          value={unifiedSettings.world.worldHeight}
          onChange={(e) => updateWorldSettings({ worldHeight: parseInt(e.target.value) })}
          className="w-full"
        />
      </div>
    </div>
  );
};

export default WorldSettings;
</file>

<file path="packages/frontend/src/components/sidebar/DevSidebar.tsx">
import React, { useState } from 'react';
import { useGameStore } from '../../stores/gameStore';
import { MaterialButton, MaterialChip, MaterialCard } from '../index';
import Panel from '../shared/Panel';
import { COLORS } from '../../utils/tokens';

interface DevSidebarProps {
  className?: string;
}

const DevSidebar: React.FC<DevSidebarProps> = ({ className }) => {
  const {
    unifiedSettings,
    updateGameSettings,
    updateAudioSettings,
    updateNotificationSettings,
    updateVisualSettings,
    updateWorldSettings,
    updateAnimationSettings,
    gameWorld,
    exportSettings,
    importSettings,
    resetAllSettings
  } = useGameStore();

  const [activeSection, setActiveSection] = useState<string>('overview');
  const [importText, setImportText] = useState('');
  const [showImportExport, setShowImportExport] = useState(false);

  const sections = [
    { id: 'overview', label: 'ðŸ“Š Overview', icon: 'ðŸ“Š' },
    { id: 'game', label: 'ðŸŽ® Game', icon: 'ðŸŽ®' },
    { id: 'audio', label: 'ðŸŽµ Audio', icon: 'ðŸŽµ' },
    { id: 'visual', label: 'ðŸ‘ï¸ Visual', icon: 'ðŸ‘ï¸' },
    { id: 'world', label: 'ðŸŒ World', icon: 'ðŸŒ' },
    { id: 'animations', label: 'ðŸŽžï¸ Animations', icon: 'ðŸŽžï¸' },
    { id: 'notifications', label: 'ðŸ”” Notifications', icon: 'ðŸ””' },
    { id: 'debug', label: 'ðŸ”§ Debug', icon: 'ðŸ”§' }
  ];

  const handleExport = () => {
    const data = exportSettings();
    navigator.clipboard.writeText(data);
    alert('Settings exported to clipboard!');
  };

  const handleImport = () => {
    if (importText.trim()) {
      const success = importSettings(importText.trim());
      if (success) {
        alert('Settings imported successfully!');
        setImportText('');
        setShowImportExport(false);
      } else {
        alert('Import failed. Check JSON format.');
      }
    }
  };

  const handleResetAll = () => {
    if (confirm('Reset ALL settings to defaults? This cannot be undone!')) {
      resetAllSettings();
      alert('All settings reset to defaults.');
    }
  };

  const renderSectionContent = () => {
    switch (activeSection) {
      case 'overview':
        return (
          <div className="py-4">
            <Panel title={<>âš™ï¸ Developer Configuration Panel</>}>
              <p className="m-0 mb-4 text-text-secondary text-sm">
                Complete control over all game systems, settings, and configurations.
                Use with caution - changes affect gameplay experience.
              </p>
              <div className="flex gap-2 flex-wrap">
                <MaterialButton size="small" onClick={() => setShowImportExport(!showImportExport)} sx={{ fontSize: '0.8rem' }}>{showImportExport ? 'Hide' : 'Import/Export'}</MaterialButton>
                <MaterialButton size="small" color="error" onClick={handleResetAll} sx={{ fontSize: '0.8rem' }}>Reset All</MaterialButton>
              </div>
            </Panel>

            {showImportExport && (
              <Panel title={<>ðŸ“¤ Export Settings</>}>
                <MaterialButton onClick={handleExport} sx={{ mb: 2, p: 1 }}>Copy to Clipboard</MaterialButton>

                <h4 className="mt-4 mb-3 text-[var(--color-text-primary)]">ðŸ“¥ Import Settings</h4>
                <textarea className="w-full min-h-[120px] p-2 bg-background-paper border border-divider rounded text-text-primary font-mono text-sm resize-y mb-2" placeholder="Paste JSON settings here..." value={importText} onChange={(e) => setImportText(e.target.value)} />
                <MaterialButton onClick={handleImport}>Import Settings</MaterialButton>
              </Panel>
            )}

            <Panel title={<>ðŸ“ˆ System Status</>}>
              <div className="grid grid-cols-2 gap-2 text-sm">
                <div><strong>World Phase:</strong> {gameWorld?.phase || 'Unknown'}</div>
                <div><strong>World Age:</strong> {gameWorld?.worldAge || 0}</div>
                <div><strong>Active Players:</strong> {gameWorld?.players?.length || 0}</div>
                <div><strong>Active NPCs:</strong> {gameWorld?.npcs?.length || 0}</div>
                <div><strong>Items:</strong> {gameWorld?.items?.length || 0}</div>
                <div><strong>Cataclysm:</strong> {gameWorld?.cataclysmCircle?.isActive ? 'Active' : 'Inactive'}</div>
              </div>
            </Panel>
          </div>
        );

      case 'game':
        return (
          <div className="py-4">
                <MaterialCard sx={{ mb: 2, p: 2, backgroundColor: 'var(--color-surface-variant)' }}>
                  <h4 className="m-0 mb-3 text-[var(--color-text-primary)]">ðŸŽ¯ Core Gameplay</h4>
                  <div className="flex flex-col gap-3">
                <label className="flex items-center gap-2">
                  <input type="checkbox" checked={unifiedSettings.game.autoSaveEnabled} onChange={(e) => updateGameSettings({ autoSaveEnabled: e.target.checked })} />
                  <span>Auto-Save Enabled</span>
                </label>
                <label className="flex items-center gap-2">
                  <input type="checkbox" checked={unifiedSettings.game.tutorialEnabled} onChange={(e) => updateGameSettings({ tutorialEnabled: e.target.checked })} />
                  <span>Tutorial Enabled</span>
                </label>
                <label className="flex items-center gap-2">
                  <input type="checkbox" checked={unifiedSettings.game.minimapEnabled} onChange={(e) => updateGameSettings({ minimapEnabled: e.target.checked })} />
                  <span>Mini-map Enabled</span>
                </label>
                <label className="flex items-center gap-2">
                  <input type="checkbox" checked={unifiedSettings.game.showNPCNames} onChange={(e) => updateGameSettings({ showNPCNames: e.target.checked })} />
                  <span>Show NPC Names</span>
                </label>
                <label className="flex items-center gap-2">
                  <input type="checkbox" checked={unifiedSettings.game.showItemNames} onChange={(e) => updateGameSettings({ showItemNames: e.target.checked })} />
                  <span>Show Item Names</span>
                </label>
              </div>
            </MaterialCard>

            <MaterialCard sx={{ mb: 2, p: 2, backgroundColor: 'var(--color-surface-variant)' }}>
              <h4 className="m-0 mb-3 text-[var(--color-text-primary)]">âš”ï¸ Combat Settings</h4>
              <div className="flex flex-col gap-3">
                <label className="flex items-center gap-2">
                  <input type="checkbox" checked={unifiedSettings.game.showDamageNumbers} onChange={(e) => updateGameSettings({ showDamageNumbers: e.target.checked })} />
                  <span>Show Damage Numbers</span>
                </label>
                <label className="flex items-center gap-2">
                  <input type="checkbox" checked={unifiedSettings.game.autoCombatEnabled} onChange={(e) => updateGameSettings({ autoCombatEnabled: e.target.checked })} />
                  <span>Auto-Combat Enabled</span>
                </label>
              </div>
            </MaterialCard>
          </div>
        );

      case 'audio':
        return (
          <div className="py-4">
            <MaterialCard sx={{ mb: 2, p: 2 }}>
              <h4 className="m-0 mb-3 text-[var(--color-text-primary)]">ðŸ”Š Volume Controls</h4>
              <div className="flex flex-col gap-4">
                <div>
                  <label>Master Volume: {unifiedSettings.audio.audioMasterVolume}%</label>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={unifiedSettings.audio.audioMasterVolume}
                    onChange={(e) => updateAudioSettings({ audioMasterVolume: parseInt(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
                <div>
                  <label>SFX Volume: {unifiedSettings.audio.sfxVolume}%</label>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={unifiedSettings.audio.sfxVolume}
                    onChange={(e) => updateAudioSettings({ sfxVolume: parseInt(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
                <div>
                  <label>Music Volume: {unifiedSettings.audio.musicVolume}%</label>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={unifiedSettings.audio.musicVolume}
                    onChange={(e) => updateAudioSettings({ musicVolume: parseInt(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
              </div>
            </MaterialCard>

            <MaterialCard sx={{ p: 2 }}>
              <h4 className="m-0 mb-3 text-[var(--color-text-primary)]">ðŸ”ˆ Audio Toggles</h4>
              <div className="flex flex-col gap-3">
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={unifiedSettings.audio.soundEnabled}
                    onChange={(e) => updateAudioSettings({ soundEnabled: e.target.checked })}
                  />
                  <span>Sound Effects Enabled</span>
                </label>
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={unifiedSettings.audio.musicEnabled}
                    onChange={(e) => updateAudioSettings({ musicEnabled: e.target.checked })}
                  />
                  <span>Music Enabled</span>
                </label>
              </div>
            </MaterialCard>
          </div>
        );

      case 'visual':
        return (
          <div className="py-4">
            <MaterialCard sx={{ mb: 2, p: 2 }}>
              <h4 className="m-0 mb-3 text-[var(--color-text-primary)]">ðŸŽ¨ Theme & UI</h4>
              <div className="flex flex-col gap-3">
                <div>
                  <label>Theme</label>
                  <select
                    value={unifiedSettings.visual.theme}
                    onChange={(e) => updateVisualSettings({ theme: e.target.value as any })}
                    className="w-full mt-1 p-1"
                  >
                    <option value="dark">ðŸŒ™ Dark</option>
                    <option value="light">â˜€ï¸ Light</option>
                    <option value="night">ðŸŒƒ Night</option>
                    <option value="auto">ðŸ¤– Auto</option>
                  </select>
                </div>
                <div>
                  <label>Language</label>
                  <select
                    value={unifiedSettings.visual.language}
                    onChange={(e) => updateVisualSettings({ language: e.target.value })}
                    className="w-full mt-1 p-1"
                  >
                    <option value="en">English</option>
                    <option value="es">EspaÃ±ol</option>
                    <option value="fr">FranÃ§ais</option>
                    <option value="de">Deutsch</option>
                    <option value="jp">æ—¥æœ¬èªž</option>
                  </select>
                </div>
                <div>
                  <label>Font Size: {unifiedSettings.visual.fontSize}%</label>
                  <input
                    type="range"
                    min="75"
                    max="150"
                    value={unifiedSettings.visual.fontSize}
                    onChange={(e) => updateVisualSettings({ fontSize: parseInt(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
              </div>
            </MaterialCard>

            <MaterialCard sx={{ p: 2 }}>
              <h4 className="m-0 mb-3 text-[var(--color-text-primary)]">â™¿ Accessibility & Display</h4>
              <div className="flex flex-col gap-3">
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={unifiedSettings.visual.highContrast}
                    onChange={(e) => updateVisualSettings({ highContrast: e.target.checked })}
                  />
                  <span>High Contrast</span>
                </label>
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={unifiedSettings.visual.reduceMotion}
                    onChange={(e) => updateVisualSettings({ reduceMotion: e.target.checked })}
                  />
                  <span>Reduce Motion</span>
                </label>
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={unifiedSettings.visual.showGrid}
                    onChange={(e) => updateVisualSettings({ showGrid: e.target.checked })}
                  />
                  <span>Show Grid</span>
                </label>
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={unifiedSettings.visual.showParticles}
                    onChange={(e) => updateVisualSettings({ showParticles: e.target.checked })}
                  />
                  <span>Show Particles</span>
                </label>
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={unifiedSettings.visual.showHealthBars}
                    onChange={(e) => updateVisualSettings({ showHealthBars: e.target.checked })}
                  />
                  <span>Show Health Bars</span>
                </label>
              </div>
            </MaterialCard>
          </div>
        );

      case 'world':
        return (
          <div className="py-4">
            <MaterialCard sx={{ mb: 2, p: 2 }}>
              <h4 className="m-0 mb-3 text-[var(--color-text-primary)]">ðŸ“ World Dimensions</h4>
              <div className="flex flex-col gap-4">
                <div>
                  <label>World Width: {unifiedSettings.world.worldWidth} tiles</label>
                  <input
                    type="range"
                    min="20"
                    max="100"
                    step="5"
                    value={unifiedSettings.world.worldWidth}
                    onChange={(e) => updateWorldSettings({ worldWidth: parseInt(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
                <div>
                  <label>World Height: {unifiedSettings.world.worldHeight} tiles</label>
                  <input
                    type="range"
                    min="15"
                    max="75"
                    step="3"
                    value={unifiedSettings.world.worldHeight}
                    onChange={(e) => updateWorldSettings({ worldHeight: parseInt(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
              </div>
            </MaterialCard>

            <MaterialCard sx={{ p: 2 }}>
              <h4 className="m-0 mb-3 text-[var(--color-text-primary)]">ðŸŒ¿ Environment Animation</h4>
              <div className="flex flex-col gap-4">
                <div>
                  <label>Grass Wave Speed: {unifiedSettings.world.grassWaveSpeed}</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={unifiedSettings.world.grassWaveSpeed}
                    onChange={(e) => updateWorldSettings({ grassWaveSpeed: parseFloat(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
                <div>
                  <label>Tree Sway Speed: {unifiedSettings.world.treeSwaySpeed}</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={unifiedSettings.world.treeSwaySpeed}
                    onChange={(e) => updateWorldSettings({ treeSwaySpeed: parseFloat(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
                <div>
                  <label>Flower Spawn Rate: {unifiedSettings.world.flowerSpawnRate}</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={unifiedSettings.world.flowerSpawnRate}
                    onChange={(e) => updateWorldSettings({ flowerSpawnRate: parseFloat(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
                <div>
                  <label>Wind Speed: {unifiedSettings.world.windSpeed}</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={unifiedSettings.world.windSpeed}
                    onChange={(e) => updateWorldSettings({ windSpeed: parseFloat(e.target.value) })}
                    className="w-full mt-1"
                  />
                </div>
              </div>
            </MaterialCard>
          </div>
        );

      case 'animations':
        return (
          <div className="py-4">
            {/* animations content omitted for brevity */}
            <div className="text-sm text-text-secondary">Animations settings and controls</div>
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <div className={[className || '', 'h-full flex flex-col overflow-auto font-inter'].join(' ').trim()}>
      <div className="p-4 border-b border-[rgba(196,167,231,0.2)] bg-[rgba(25,23,36,0.8)]">
        <h2 className="text-text-primary text-lg font-semibold m-0">Dev Panel</h2>
      </div>
      <div className="p-4">
        <div className="flex gap-2 mb-3">
          {sections.map(s => (
            <button key={s.id} onClick={() => setActiveSection(s.id)} className={`px-2 py-1 rounded ${activeSection === s.id ? 'bg-[rgba(196,167,231,0.12)]' : 'bg-transparent'}`}>{s.label}</button>
          ))}
        </div>
        {renderSectionContent()}
      </div>
    </div>
  );
};

export default DevSidebar;
</file>

<file path="packages/frontend/src/components/sidebar/index.ts">
export { default as CategoryNavigation } from './CategoryNavigation';
export { default as OverviewPanel } from './panels/OverviewPanel';
export { default as GameplaySettings } from './panels/GameplaySettings';
export { default as AudioSettings } from './panels/AudioSettings';
export { default as VisualSettings } from './panels/VisualSettings';
export { default as WorldSettings } from './panels/WorldSettings';
export { default as ActionsPanel } from './panels/ActionsPanel';
// Persisted bottom widget (kept at the root to remain always-available)
export { default as PlayerStatusPanel } from './PlayerStatusPanel';
// Smaller panel variant used inside the category content area
export { default as PlayerSummaryPanel } from './panels/PlayerSummaryPanel';
</file>

<file path="packages/frontend/src/components/sidebar/PlayerSidebar.tsx">
import React, { useState } from 'react';
import { useGameStore } from '../../stores/gameStore';
import { PlayerClass } from 'shared';
import { MaterialButton, MaterialCard, MaterialChip } from '../index';
import EnhancedPlayerStatus from '../player/EnhancedPlayerStatus';
import {
  PlayArrow as PlayIcon,
  Settings as SettingsIcon,
  VolumeUp as VolumeIcon,
  Visibility as VisibilityIcon,
  SportsEsports as GameIcon,
  Person as PlayerIcon,
  Keyboard as ControlsIcon,
  Tune as QuickSettingsIcon
} from '@mui/icons-material';

interface PlayerSidebarProps {
  className?: string;
}

const PlayerSidebar: React.FC<PlayerSidebarProps> = ({ className }) => {
  const {
    currentPlayer,
    joinGame,
    handleRegenerateWorld,
    startCataclysm,
    movePlayer,
    pickupItem,
    gameMessage,
    unifiedSettings,
    updateAudioSettings,
    updateVisualSettings,
    updateAnimationSettings,
  } = useGameStore();

  const [activeTab, setActiveTab] = useState<'play' | 'settings'>('play');

  const handleJoin = () => {
    joinGame({
      id: `player_${Date.now()}`,
      displayName: 'Player' + Math.floor(Math.random() * 1000),
      class: PlayerClass.KNIGHT,
      avatar: 'ðŸ™‚'
    });
  };

  const handleMove = (direction: 'up' | 'down' | 'left' | 'right') => {
    movePlayer(direction);
  };

  const handlePickup = () => {
    pickupItem('nearest');
  };

  const handleRegenerate = () => {
    handleRegenerateWorld();
  };

  const handleCataclysm = () => {
    startCataclysm();
  };

  const toggleSound = () => {
    updateAudioSettings({
      audioMasterVolume: unifiedSettings.audio.audioMasterVolume > 0 ? 0 : 0.7
    });
  };

  const toggleGrid = () => {
    updateAnimationSettings({
      showGrid: !unifiedSettings.animations.showGrid
    });
  };

  const toggleParticles = () => {
    updateAnimationSettings({
      showParticles: !unifiedSettings.animations.showParticles
    });
  };

  return (
    <div className={`${className} h-full flex flex-col bg-[var(--color-background-paper)] border-l border-[var(--color-divider)]`}>
      {/* Header with Tab Switcher */}
      <div className="p-4 border-b border-[var(--color-outline)] bg-[var(--color-surface-variant)]">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-bold text-[var(--color-text-primary)] m-0">ðŸŽ® Game Panel</h2>
          <div className="flex gap-1">
            <MaterialButton
              size="small"
              variant={activeTab === 'play' ? 'contained' : 'outlined'}
              onClick={() => setActiveTab('play')}
              startIcon={<PlayIcon />}
              sx={{ minHeight: '32px', px: 2 }}
            >
              Play
            </MaterialButton>
            <MaterialButton
              size="small"
              variant={activeTab === 'settings' ? 'contained' : 'outlined'}
              onClick={() => setActiveTab('settings')}
              startIcon={<SettingsIcon />}
              sx={{ minHeight: '32px', px: 2 }}
            >
              Settings
            </MaterialButton>
          </div>
        </div>

        {/* Game Message */}
        {gameMessage && (
          <MaterialCard sx={{ p: 2, backgroundColor: 'var(--color-primary-container)', border: '1px solid var(--color-primary)' }}>
            <p className="text-sm text-[var(--color-on-primary-container)] m-0">{gameMessage}</p>
          </MaterialCard>
        )}
      </div>

      {/* Main Content */}
      <div className="flex-1 overflow-auto">
        {activeTab === 'play' ? (
          <div className="h-full flex flex-col">
            {/* TOP HALF: Player Stats */}
            <div className="flex-1 p-4 border-b border-[var(--color-outline)]">
              <div className="flex items-center gap-2 mb-3">
                <PlayerIcon sx={{ fontSize: 20 }} />
                <h3 className="text-md font-semibold text-[var(--color-text-primary)] m-0">Player Status</h3>
              </div>

              {currentPlayer ? (
                <EnhancedPlayerStatus player={currentPlayer} />
              ) : (
                <div className="text-center py-8">
                  <p className="text-[var(--color-text-secondary)] mb-4">Not in game</p>
                  <MaterialButton
                    onClick={handleJoin}
                    startIcon={<PlayIcon />}
                    sx={{ minWidth: '120px' }}
                  >
                    Join Game
                  </MaterialButton>
                </div>
              )}
            </div>

            {/* BOTTOM HALF: Controls & Options */}
            <div className="flex-1 p-4">
              <div className="flex items-center gap-2 mb-3">
                <ControlsIcon sx={{ fontSize: 20 }} />
                <h3 className="text-md font-semibold text-[var(--color-text-primary)] m-0">Controls</h3>
              </div>

              {currentPlayer && (
                <>
                  {/* Movement Controls */}
                  <div className="mb-4">
                    <h4 className="text-sm font-medium text-[var(--color-text-primary)] mb-2">Movement</h4>
                    <div className="grid grid-cols-3 gap-1 max-w-[120px] mx-auto">
                      <div />
                      <MaterialButton
                        size="small"
                        onClick={() => handleMove('up')}
                        sx={{ minWidth: '32px', minHeight: '32px', p: 0 }}
                      >
                        â†‘
                      </MaterialButton>
                      <div />

                      <MaterialButton
                        size="small"
                        onClick={() => handleMove('left')}
                        sx={{ minWidth: '32px', minHeight: '32px', p: 0 }}
                      >
                        â†
                      </MaterialButton>

                      <MaterialButton
                        size="small"
                        onClick={() => handleMove('down')}
                        sx={{ minWidth: '32px', minHeight: '32px', p: 0 }}
                      >
                        â†“
                      </MaterialButton>

                      <MaterialButton
                        size="small"
                        onClick={() => handleMove('right')}
                        sx={{ minWidth: '32px', minHeight: '32px', p: 0 }}
                      >
                        â†’
                      </MaterialButton>
                    </div>
                  </div>

                  {/* Quick Actions */}
                  <div className="mb-4">
                    <h4 className="text-sm font-medium text-[var(--color-text-primary)] mb-2">Actions</h4>
                    <div className="flex flex-col gap-2">
                      <MaterialButton
                        size="small"
                        onClick={handlePickup}
                        startIcon={<span>ðŸŽ’</span>}
                        sx={{ justifyContent: 'flex-start' }}
                      >
                        Pick Up Item
                      </MaterialButton>

                      <MaterialButton
                        size="small"
                        onClick={handleRegenerate}
                        startIcon={<span>ðŸŒ</span>}
                        sx={{ justifyContent: 'flex-start' }}
                      >
                        Regen World
                      </MaterialButton>

                      <MaterialButton
                        size="small"
                        color="error"
                        onClick={handleCataclysm}
                        startIcon={<span>âš¡</span>}
                        sx={{ justifyContent: 'flex-start' }}
                      >
                        Cataclysm
                      </MaterialButton>
                    </div>
                  </div>

                  {/* Quick Settings */}
                  <div>
                    <h4 className="text-sm font-medium text-[var(--color-text-primary)] mb-2">Quick Settings</h4>
                    <div className="flex flex-wrap gap-2">
                      <MaterialChip
                        label={unifiedSettings.audio.audioMasterVolume > 0 ? "ðŸ”Š Sound On" : "ðŸ”‡ Sound Off"}
                        onClick={toggleSound}
                        size="small"
                        sx={{ cursor: 'pointer' }}
                      />
                      <MaterialChip
                        label={unifiedSettings.animations.showGrid ? "ðŸ“ Grid On" : "ðŸ“ Grid Off"}
                        onClick={toggleGrid}
                        size="small"
                        sx={{ cursor: 'pointer' }}
                      />
                      <MaterialChip
                        label={unifiedSettings.animations.showParticles ? "âœ¨ Particles On" : "âœ¨ Particles Off"}
                        onClick={toggleParticles}
                        size="small"
                        sx={{ cursor: 'pointer' }}
                      />
                    </div>
                  </div>
                </>
              )}
            </div>
          </div>
        ) : (
          /* SETTINGS TAB */
          <div className="p-4">
            <div className="flex items-center gap-2 mb-4">
              <QuickSettingsIcon sx={{ fontSize: 20 }} />
              <h3 className="text-md font-semibold text-[var(--color-text-primary)] m-0">Quick Settings</h3>
            </div>

            {/* Audio Settings */}
            <MaterialCard sx={{ mb: 3, p: 3 }}>
              <div className="flex items-center gap-2 mb-3">
                <VolumeIcon sx={{ fontSize: 18 }} />
                <h4 className="text-sm font-medium text-[var(--color-text-primary)] m-0">Audio</h4>
              </div>
              <div className="space-y-3">
                <div>
                  <label className="block text-xs text-[var(--color-text-secondary)] mb-1">Master Volume</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={unifiedSettings.audio.audioMasterVolume}
                    onChange={(e) => updateAudioSettings({ audioMasterVolume: parseFloat(e.target.value) })}
                    className="w-full"
                  />
                </div>
                <div>
                  <label className="block text-xs text-[var(--color-text-secondary)] mb-1">SFX Volume</label>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={unifiedSettings.audio.sfxVolume}
                    onChange={(e) => updateAudioSettings({ sfxVolume: parseFloat(e.target.value) })}
                    className="w-full"
                  />
                </div>
              </div>
            </MaterialCard>

            {/* Visual Settings */}
            <MaterialCard sx={{ mb: 3, p: 3 }}>
              <div className="flex items-center gap-2 mb-3">
                <VisibilityIcon sx={{ fontSize: 18 }} />
                <h4 className="text-sm font-medium text-[var(--color-text-primary)] m-0">Visual</h4>
              </div>
              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-[var(--color-text-primary)]">Show Grid</span>
                  <input
                    type="checkbox"
                    checked={unifiedSettings.animations.showGrid}
                    onChange={(e) => updateAnimationSettings({ showGrid: e.target.checked })}
                  />
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-sm text-[var(--color-text-primary)]">Show Particles</span>
                  <input
                    type="checkbox"
                    checked={unifiedSettings.animations.showParticles}
                    onChange={(e) => updateAnimationSettings({ showParticles: e.target.checked })}
                  />
                </div>
                <div>
                  <label className="block text-xs text-[var(--color-text-secondary)] mb-1">Render Scale ({Math.round(unifiedSettings.visual.renderScale * 100)}%)</label>
                  <input
                    type="range"
                    min="0.25"
                    max="1.0"
                    step="0.05"
                    value={unifiedSettings.visual.renderScale}
                    onChange={(e) => updateVisualSettings({ renderScale: parseFloat(e.target.value) })}
                    className="w-full"
                  />
                  <div className="flex justify-between text-xs text-[var(--color-text-secondary)] mt-1">
                    <span>25%</span>
                    <span>75%</span>
                    <span>100%</span>
                  </div>
                </div>
              </div>
            </MaterialCard>

            {/* Gameplay Settings */}
            <MaterialCard sx={{ p: 3 }}>
              <div className="flex items-center gap-2 mb-3">
                <GameIcon sx={{ fontSize: 18 }} />
                <h4 className="text-sm font-medium text-[var(--color-text-primary)] m-0">Gameplay</h4>
              </div>
              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-[var(--color-text-primary)]">Auto-save</span>
                  <input
                    type="checkbox"
                    checked={unifiedSettings.game.autoSaveEnabled}
                    onChange={(e) => useGameStore.getState().updateGameSettings({ autoSaveEnabled: e.target.checked })}
                  />
                </div>
              </div>
            </MaterialCard>
          </div>
        )}
      </div>
    </div>
  );
};

export default PlayerSidebar;
</file>

<file path="packages/frontend/src/components/sidebar/PlayerStatusPanel.tsx">
import React from 'react';
import { Player } from 'shared';
import EnhancedPlayerStatus from '../player/EnhancedPlayerStatus';

interface PlayerStatusPanelProps {
  currentPlayer: Player | null;
}

const PlayerStatusPanel: React.FC<PlayerStatusPanelProps> = ({
  currentPlayer
}) => {
  if (!currentPlayer) {
    return null;
  }

  return (
    <div className="pt-4 pb-4 px-5 border-t bg-[var(--color-surface-variant)]/80 border-[var(--color-outline)]">
      <EnhancedPlayerStatus player={currentPlayer} />
    </div>
  );
};

export default PlayerStatusPanel;
</file>

<file path="packages/frontend/src/components/sidebar/Sidebar.tsx">
import React from 'react';
import PlayerSidebar from './PlayerSidebar.tsx';
import SpectatorSidebar from './SpectatorSidebar.tsx';
import DevSidebar from './DevSidebar.tsx';

export interface SidebarProps {
  mode: 'play' | 'spectate' | 'dev';
  className?: string;
}

const Sidebar: React.FC<SidebarProps> = ({ mode, className }) => {
  switch (mode) {
    case 'play':
      return <PlayerSidebar className={className} />;
    case 'spectate':
      return <SpectatorSidebar className={className} />;
    case 'dev':
      return <DevSidebar className={className} />;
    default:
      return null;
  }
};

export default Sidebar;
</file>

<file path="packages/frontend/src/components/ErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = { hasError: false };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('React Error Boundary caught an error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <p>Please refresh the page and try again.</p>
          {process.env.NODE_ENV === 'development' && (
            <pre>{this.state.error?.stack}</pre>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="packages/frontend/src/constants/colors.ts">
import { colorTokens } from '../../../../shared/src/constants/colorConstants';

export const COLORS = colorTokens;
</file>

<file path="packages/frontend/src/services/chat/MessageHandler.ts">
import { ChatMessage } from '../../types/chat';

class MessageHandler {
  private messages: ChatMessage[] = [];
  private updateMessagesCallback: ((messages: ChatMessage[]) => void) | null = null;

  public setUpdateMessagesCallback(callback: (messages: ChatMessage[]) => void): void {
    this.updateMessagesCallback = callback;
  }

  public handleNewMessage(message: ChatMessage): void {
    this.messages = [...this.messages, message];
    this.notifyUpdate();
  }

  public addSentMessage(message: string, username: string, displayName: string): void {
    const sentMsg: ChatMessage = {
      message,
      timestamp: Date.now(),
      isResponse: false,
      username,
      displayName,
    };
    this.messages = [...this.messages, sentMsg];
    this.notifyUpdate();
  }

  public addErrorMessage(message: string): void {
    const errorMsg: ChatMessage = {
      message,
      timestamp: Date.now(),
      isResponse: true, // Treat it like a system response
      username: 'System',
      displayName: 'System',
      isError: true,
    };
    this.messages = [...this.messages, errorMsg];
    this.notifyUpdate();
  }

  public getMessages(): ChatMessage[] {
    return this.messages;
  }

  private notifyUpdate(): void {
    if (this.updateMessagesCallback) {
      this.updateMessagesCallback([...this.messages]);
    }
  }
}

export const messageHandler = new MessageHandler();
</file>

<file path="packages/frontend/src/services/chat/ModerationService.ts">
// A placeholder for the on-device moderation service.
// In a real implementation, this would load and run a TensorFlow Lite model.

class ModerationService {
  private isModelReady = false;

  constructor() {
    this.loadModel();
  }

  /**
   * Simulates loading the on-device model.
   */
  private async loadModel() {
    console.log('Loading moderation model...');
    // Simulate a delay for loading the model
    await new Promise(resolve => setTimeout(resolve, 1000));
    this.isModelReady = true;
    console.log('Moderation model loaded.');
  }

  /**
   * Checks if a message is flagged as inappropriate.
   * This is a placeholder and does not use a real model.
   * @param message The message to check.
   * @returns A promise that resolves to true if the message is flagged, false otherwise.
   */
  async isMessageFlagged(message: string): Promise<boolean> {
    if (!this.isModelReady) {
      console.warn('Moderation model is not ready yet.');
      return false;
    }

    // Simulate inference delay
    await new Promise(resolve => setTimeout(resolve, 50));

    // In a real implementation, this would run the message through the TFLite model.
    // For now, we'll just flag messages that contain certain keywords.
    const flaggedKeywords = ['badword', 'inappropriate'];
    const lowerCaseMessage = message.toLowerCase();

    for (const keyword of flaggedKeywords) {
      if (lowerCaseMessage.includes(keyword)) {
        console.log(`Message flagged for keyword: ${keyword}`);
        return true;
      }
    }

    return false;
  }
}

export const moderationService = new ModerationService();
</file>

<file path="packages/frontend/src/services/assetConverter.ts">
import { Svg2Roughjs, OutputType } from 'svg2roughjs';
import emojiData from 'svgmoji/emoji.json';

export interface AssetConversionOptions {
  roughness?: number;
  bowing?: number;
  seed?: number;
  randomize?: boolean;
  backgroundColor?: string;
  pencilFilter?: boolean;
  sketchPatterns?: boolean;
}

export interface ConvertedAsset {
  svg: string;
  canvas?: HTMLCanvasElement;
  originalSvg: string;
  options: AssetConversionOptions;
}

// Create a lookup map for faster emoji access
const emojiLookup = new Map<string, any>();
emojiData.forEach(emoji => {
  emojiLookup.set(emoji.emoji, emoji);
});

export class AssetConverterService {
  private converter: Svg2Roughjs | null = null;

  /**
   * Convert an SVG string to a rough hand-drawn version
   */
  async convertSvgToRough(
    svgString: string,
    options: AssetConversionOptions = {}
  ): Promise<ConvertedAsset> {
    try {
      // Create a temporary container for the conversion
      const container = document.createElement('div');
      container.style.position = 'absolute';
      container.style.left = '-9999px';
      container.style.top = '-9999px';
      document.body.appendChild(container);

      // Create SVG element from string
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
      const svgElement = svgDoc.documentElement;

      if (!svgElement || svgElement.tagName !== 'svg') {
        throw new Error('Invalid SVG content');
      }

      const typedSvgElement = svgElement as unknown as SVGSVGElement;

      // Initialize converter if not exists
      if (!this.converter) {
        this.converter = new Svg2Roughjs(container, OutputType.SVG);
      } else {
        // Reset target if converter already exists
        this.converter = new Svg2Roughjs(container, OutputType.SVG);
      }

      // Set the SVG source
      this.converter.svg = typedSvgElement;

      // Apply conversion options
      this.applyOptions(this.converter, options);

      // Perform the conversion
      const result = await this.converter.sketch();

      // Get the resulting SVG
      let resultSvg = '';
      if (result && result instanceof SVGSVGElement) {
        resultSvg = new XMLSerializer().serializeToString(result);
      } else if (container.innerHTML) {
        resultSvg = container.innerHTML;
      }

      // Clean up
      document.body.removeChild(container);

      return {
        svg: resultSvg,
        originalSvg: svgString,
        options
      };
    } catch (error) {
      console.error('SVG conversion failed:', error);
      throw new Error(`Failed to convert SVG: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Fetch an emoji SVG using local emoji database for validation
   */
  async fetchEmojiSvg(emoji: string, collection: 'svgmoji' = 'svgmoji', opts?: { rough?: boolean; preset?: 'sketch' | 'cartoon' | 'technical' | 'wild'; options?: AssetConversionOptions }): Promise<string> {
    try {
      // First, validate emoji using local database
      const emojiInfo = emojiLookup.get(emoji);
      if (!emojiInfo) {
        console.warn(`Emoji ${emoji} not found in database, using fallback`);
        return this.getFallbackSvg(emoji);
      }

      // Try backend API first (for centralized caching)
      try {
        const apiBase = (import.meta as any)?.env?.VITE_API_BASE || 'http://localhost:3001';
        let url = `${apiBase.replace(/\/$/, '')}/api/emoji?char=${encodeURIComponent(emoji)}`;
        if (opts?.rough) {
          url += '&rough=true';
          if (opts?.preset) {
            const mapping = this.getPresetOptions(opts.preset);
            Object.entries(mapping).forEach(([k, v]) => {
              if (v !== undefined && v !== null) url += `&${encodeURIComponent(k)}=${encodeURIComponent(String(v))}`;
            });
          } else if (opts?.options) {
            Object.entries(opts.options).forEach(([k, v]) => {
              if (v !== undefined && v !== null) url += `&${encodeURIComponent(k)}=${encodeURIComponent(String((v as any)))}`;
            });
          }
        }
        const res = await fetch(url);
        if (res.ok) {
          const text = await res.text();
          if (text && text.trim().startsWith('<svg')) return text;
        }
      } catch (e) {
        // Backend not available, continue to local resolution
      }

      // Use local emoji data to construct CDN URL
      const hexCode = emojiInfo.hexcode;
      const cdnUrl = `https://cdn.jsdelivr.net/npm/@svgmoji/noto@latest/svg/${hexCode}.svg`;

      try {
        const response = await fetch(cdnUrl);
        if (response.ok) {
          const svgText = await response.text();
          if (opts?.rough) {
            const roughOptions = opts.preset ? this.getPresetOptions(opts.preset) : (opts.options || {});
            const converted = await this.convertSvgToRough(svgText, roughOptions);
            return converted.svg;
          }
          return svgText;
        }
      } catch (cdnError) {
        console.warn(`CDN fetch failed for ${emoji}:`, cdnError);
      }

      // Fallback to generic SVG
      return await this.getFallbackSvg(emoji, opts?.rough, opts?.preset, opts?.options);
    } catch (err) {
      console.error('fetchEmojiSvg error:', err);
      return await this.getFallbackSvg(emoji);
    }
  }

  /**
   * Get fallback SVG for emoji
   */
  private async getFallbackSvg(emoji: string, rough?: boolean, preset?: string, options?: AssetConversionOptions): Promise<string> {
    const fallbackSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128" viewBox="0 0 128 128"><rect width="100%" height="100%" fill="transparent"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="72">${emoji}</text></svg>`;

    if (rough) {
      // Convert fallback to rough version if requested
      const roughOptions = preset ? this.getPresetOptions(preset as any) : (options || {});
      try {
        const converted = await this.convertSvgToRough(fallbackSvg, roughOptions);
        return converted.svg;
      } catch (error) {
        console.warn('Failed to convert fallback SVG to rough:', error);
        return fallbackSvg;
      }
    }

    return fallbackSvg;
  }

  /**
   * Convert SVG to canvas for direct rendering
   */
  async convertSvgToCanvas(
    svgString: string,
    options: AssetConversionOptions = {}
  ): Promise<ConvertedAsset> {
    try {
      const canvas = document.createElement('canvas');
      canvas.width = 400;
      canvas.height = 400;

      const converter = new Svg2Roughjs(canvas, OutputType.CANVAS);

      // Create SVG element from string
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
      const svgElement = svgDoc.documentElement;

      if (!svgElement || svgElement.tagName !== 'svg') {
        throw new Error('Invalid SVG content');
      }

      const typedSvgElement = svgElement as unknown as SVGSVGElement;

      converter.svg = typedSvgElement;
      this.applyOptions(converter, options);

      await converter.sketch();

      return {
        svg: '', // Canvas mode doesn't produce SVG
        canvas,
        originalSvg: svgString,
        options
      };
    } catch (error) {
      console.error('Canvas conversion failed:', error);
      throw new Error(`Failed to convert SVG to canvas: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Apply conversion options to the converter
   */
  private applyOptions(converter: Svg2Roughjs, options: AssetConversionOptions) {
    if (options.roughness !== undefined) {
      converter.roughConfig.roughness = options.roughness;
    }
    if (options.bowing !== undefined) {
      converter.roughConfig.bowing = options.bowing;
    }
    if (options.seed !== undefined) {
      converter.seed = options.seed;
    }
    if (options.randomize !== undefined) {
      converter.randomize = options.randomize;
    }
    if (options.backgroundColor !== undefined) {
      converter.backgroundColor = options.backgroundColor;
    }
    if (options.pencilFilter !== undefined) {
      converter.pencilFilter = options.pencilFilter;
    }
    if (options.sketchPatterns !== undefined) {
      converter.sketchPatterns = options.sketchPatterns;
    }
  }

  /**
   * Validate SVG content
   */
  validateSvg(svgString: string): boolean {
    try {
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
      const svgElement = svgDoc.documentElement;

      return svgElement && svgElement.tagName === 'svg';
    } catch {
      return false;
    }
  }

  /**
   * Get default conversion options
   */
  getDefaultOptions(): AssetConversionOptions {
    return {
      roughness: 1,
      bowing: 1,
      randomize: true,
      backgroundColor: 'transparent',
      pencilFilter: false,
      sketchPatterns: true
    };
  }

  /**
   * Get preset options for different styles
   */
  getPresetOptions(preset: 'sketch' | 'cartoon' | 'technical' | 'wild'): AssetConversionOptions {
    const presets = {
      sketch: {
        roughness: 1.5,
        bowing: 1,
        randomize: true,
        pencilFilter: true,
        sketchPatterns: true
      },
      cartoon: {
        roughness: 0.5,
        bowing: 2,
        randomize: false,
        seed: 42,
        pencilFilter: false,
        sketchPatterns: true
      },
      technical: {
        roughness: 0.3,
        bowing: 0.5,
        randomize: false,
        seed: 123,
        pencilFilter: false,
        sketchPatterns: false
      },
      wild: {
        roughness: 3,
        bowing: 3,
        randomize: true,
        pencilFilter: true,
        sketchPatterns: true
      }
    };

    return { ...this.getDefaultOptions(), ...presets[preset] };
  }
}

// Singleton instance
export const assetConverter = new AssetConverterService();
</file>

<file path="packages/frontend/src/services/gsap.ts">
import { gsap } from 'gsap';
import { Draggable } from 'gsap/Draggable';
import { DrawSVGPlugin } from 'gsap/DrawSVGPlugin';
import { EaselPlugin } from 'gsap/EaselPlugin';
import { Flip } from 'gsap/Flip';
import { GSDevTools } from 'gsap/GSDevTools';
import { InertiaPlugin } from 'gsap/InertiaPlugin';
import { MotionPathHelper } from 'gsap/MotionPathHelper';
import { MotionPathPlugin } from 'gsap/MotionPathPlugin';
import { MorphSVGPlugin } from 'gsap/MorphSVGPlugin';
import { Observer } from 'gsap/Observer';
import { Physics2DPlugin } from 'gsap/Physics2DPlugin';
import { PhysicsPropsPlugin } from 'gsap/PhysicsPropsPlugin';
import { PixiPlugin } from 'gsap/PixiPlugin';
import { ScrambleTextPlugin } from 'gsap/ScrambleTextPlugin';
import { ScrollTrigger } from 'gsap/ScrollTrigger';
import { ScrollToPlugin } from 'gsap/ScrollToPlugin';
import { SplitText } from 'gsap/SplitText';
import { TextPlugin } from 'gsap/TextPlugin';
import { RoughEase, ExpoScaleEase, SlowMo } from 'gsap/EasePack';
import { CustomEase } from 'gsap/CustomEase';
import { CustomBounce } from 'gsap/CustomBounce';
import { CustomWiggle } from 'gsap/CustomWiggle';

gsap.registerPlugin(
  Draggable,
  DrawSVGPlugin,
  EaselPlugin,
  Flip,
  GSDevTools,
  InertiaPlugin,
  MotionPathHelper,
  MotionPathPlugin,
  MorphSVGPlugin,
  Observer,
  Physics2DPlugin,
  PhysicsPropsPlugin,
  PixiPlugin,
  ScrambleTextPlugin,
  ScrollTrigger,
  ScrollToPlugin,
  SplitText,
  TextPlugin,
  CustomEase,
  CustomBounce,
  CustomWiggle
);

export * from 'gsap';
export {
  Draggable,
  DrawSVGPlugin,
  EaselPlugin,
  Flip,
  GSDevTools,
  InertiaPlugin,
  MotionPathHelper,
  MotionPathPlugin,
  MorphSVGPlugin,
  Observer,
  Physics2DPlugin,
  PhysicsPropsPlugin,
  PixiPlugin,
  ScrambleTextPlugin,
  ScrollTrigger,
  ScrollToPlugin,
  SplitText,
  TextPlugin,
  RoughEase,
  ExpoScaleEase,
  SlowMo,
  CustomEase,
  CustomBounce,
  CustomWiggle,
};
</file>

<file path="packages/frontend/src/srcs/ai/AITypes.ts">
// packages/frontend/src/ai/AITypes.ts

import { GameEntity } from './GameEntity';

export type AIEntity = GameEntity;

export interface ITelegram {
  sender: number;
  receiver: number;
  message: string;
  dispatchTime: number;
  extraInfo?: any;
}
</file>

<file path="packages/frontend/src/stores/layoutStore.ts">
// packages/frontend/src/stores/layoutStore.ts
import { create } from 'zustand';
import { Layouts } from 'react-grid-layout';

interface LayoutState {
  layouts: Layouts;
  setLayouts: (layouts: Layouts) => void;
}

const defaultLayouts: Layouts = {
  lg: [
    { i: 'main-content', x: 0, y: 0, w: 8, h: 10, static: false },
    { i: 'chat', x: 8, y: 0, w: 4, h: 5, static: false },
    { i: 'friends', x: 8, y: 5, w: 4, h: 5, static: false },
  ],
};

export const useLayoutStore = create<LayoutState>((set) => ({
  layouts: defaultLayouts,
  setLayouts: (newLayouts) => set({ layouts: newLayouts }),
}));
</file>

<file path="packages/frontend/src/test/setup.ts">
import { vi } from 'vitest';

// Mock window.matchMedia for GSAP
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock ResizeObserver
const ResizeObserverMock = vi.fn(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));
vi.stubGlobal('ResizeObserver', ResizeObserverMock);
</file>

<file path="packages/frontend/src/types/chat.ts">
export interface ChatMessage {
  message: string;
  timestamp: number;
  isResponse: boolean;
  originalMessage?: string;
  username?: string;
  displayName?: string;
  isError?: boolean;
}

export interface Player {
  id: string;
  twitchUsername: string;
  displayName: string;
  avatar: string;
  position: { x: number; y: number };
  class: string;
  stats: { hp: number; maxHp: number; attack: number; defense: number; speed: number };
  level: number;
  experience: number;
  inventory: any[];
  equipment: any;
  achievements: string[];
  titles: string[];
  isAlive: boolean;
  lastMoveTime: number;
  spawnTime: number;
}
</file>

<file path="packages/frontend/src/utils/boundaryTracing.test.ts">
import { BoundaryTracer } from './boundaryTracing';

describe('BoundaryTracer', () => {
  let tracer: BoundaryTracer;

  beforeEach(() => {
    tracer = new BoundaryTracer();
  });

  it('should correctly handle marching squares case 9', () => {
    const cells = [
      { x: 0, y: 0 },
      { x: 0, y: 1 },
    ];
    const grid = [
      [1, 0],
      [1, 0],
    ];

    // @ts-ignore - private method
    const segments = tracer.getSegmentsForCell(9, 0, 0);
    expect(segments).toEqual([{ p1: { x: 0.5, y: 0 }, p2: { x: 1, y: 0.5 } }]);
  });
});
</file>

<file path="packages/frontend/src/utils/boundaryTracing.ts">
import { Position } from 'shared';
import simplify from 'simplify-js';

type Point = { x: number; y: number };

export class BoundaryTracer {
  public march(cells: Position[], cellSize: number): number[][] {
    if (cells.length === 0) {
      return [];
    }

    const { grid, offsetX, offsetY } = this.createGrid(cells);
    const contours = this.traceContours(grid);

    if (contours.length === 0) {
      return [];
    }

    const worldContours = this.convertToWorldCoordinates(contours, cellSize, offsetX, offsetY);

    const simplifiedContours = worldContours.map(contour => {
      const pointsToSimplify = contour.map(p => ({ x: p[0], y: p[1] }));
      const simplified = this.simplify(pointsToSimplify, cellSize / 4, true); // Tolerance based on cell size
      return simplified.map(p => [p.x, p.y]);
    });

    // This logic assumes a single, continuous biome boundary. For biomes with holes or multiple separate areas,
    // this would need to be more sophisticated (e.g., using path winding rules to determine inner/outer paths).
    // For now, we return the longest contour found.
    if (simplifiedContours.length === 0) return [];
    simplifiedContours.sort((a, b) => b.length - a.length);
    return simplifiedContours[0];
  }

  private createGrid(cells: Position[]): { grid: number[][]; offsetX: number; offsetY: number } {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const cell of cells) {
      minX = Math.min(minX, cell.x);
      minY = Math.min(minY, cell.y);
      maxX = Math.max(maxX, cell.x);
      maxY = Math.max(maxY, cell.y);
    }

    const gridWidth = maxX - minX + 3;
    const gridHeight = maxY - minY + 3;
    const grid = Array.from({ length: gridHeight }, () => Array(gridWidth).fill(0));

    const offsetX = minX - 1;
    const offsetY = minY - 1;

    for (const cell of cells) {
      grid[cell.y - offsetY][cell.x - offsetX] = 1;
    }

    return { grid, offsetX, offsetY };
  }

  private traceContours(grid: number[][]): Point[][] {
    const segments: {p1: Point, p2: Point}[] = [];
    const height = grid.length;
    const width = grid[0].length;

    for (let y = 0; y < height - 1; y++) {
      for (let x = 0; x < width - 1; x++) {
        const val =
          (grid[y][x]     * 1) | // top-left
          (grid[y][x+1]   * 2) | // top-right
          (grid[y+1][x+1] * 4) | // bottom-right
          (grid[y+1][x]   * 8);  // bottom-left

        this.getSegmentsForCell(val, x, y).forEach(seg => segments.push(seg));
      }
    }

    return this.linkSegments(segments);
  }

  private getSegmentsForCell(val: number, x: number, y: number): {p1: Point, p2: Point}[] {
    const top = { x: x + 0.5, y: y };
    const bottom = { x: x + 0.5, y: y + 1 };
    const left = { x: x, y: y + 0.5 };
    const right = { x: x + 1, y: y + 0.5 };

    switch(val) {
      case 0: return [];
      case 1: return [{ p1: top, p2: left }];
      case 2: return [{ p1: top, p2: right }];
      case 3: return [{ p1: left, p2: right }];
      case 4: return [{ p1: right, p2: bottom }];
      case 5: return [{ p1: top, p2: left }, { p1: right, p2: bottom }]; // Swapped with case 10
      case 6: return [{ p1: top, p2: bottom }];
      case 7: return [{ p1: left, p2: bottom }];
      case 8: return [{ p1: left, p2: bottom }];
      case 9: return [{ p1: top, p2: right }];
      case 10: return [{ p1: top, p2: right }, { p1: left, p2: bottom }]; // Swapped with case 5
      case 11: return [{ p1: right, p2: bottom }];
      case 12: return [{ p1: left, p2: right }];
      case 13: return [{ p1: top, p2: right }];
      case 14: return [{ p1: top, p2: left }];
      case 15: return [];
      default: return [];
    }
  }

  private linkSegments(segments: {p1: Point, p2: Point}[]): Point[][] {
    if (segments.length === 0) return [];

    const contours: Point[][] = [];
    const segmentPool = [...segments];

    while(segmentPool.length > 0) {
      let currentContour: Point[] = [];
      let currentSegment = segmentPool.pop()!;
      currentContour.push(currentSegment.p1, currentSegment.p2);

      let closed = false;
      while(!closed && segmentPool.length > 0) {
        const lastPoint = currentContour[currentContour.length - 1];
        let foundNext = false;
        for (let i = segmentPool.length - 1; i >= 0; i--) {
          const next = segmentPool[i];
          if (this.pointsAreEqual(next.p1, lastPoint)) {
            currentContour.push(next.p2);
            segmentPool.splice(i, 1);
            foundNext = true;
            break;
          }
          if (this.pointsAreEqual(next.p2, lastPoint)) {
            currentContour.push(next.p1);
            segmentPool.splice(i, 1);
            foundNext = true;
            break;
          }
        }

        if (!foundNext) {
          // Contour ended without closing, or it's just one segment
          break;
        }

        if (this.pointsAreEqual(currentContour[0], currentContour[currentContour.length-1])) {
          closed = true;
          // remove last point because it's same as first
          currentContour.pop();
        }
      }
      contours.push(currentContour);
    }

    return contours;
  }

  private pointsAreEqual(p1: Point, p2: Point): boolean {
    // Use a small epsilon for float comparison safety
    const epsilon = 1e-5;
    return Math.abs(p1.x - p2.x) < epsilon && Math.abs(p1.y - p2.y) < epsilon;
  }

  private convertToWorldCoordinates(contours: Point[][], cellSize: number, offsetX: number, offsetY: number): number[][][] {
    return contours.map(contour =>
      contour.map(point => [
        (point.x + offsetX) * cellSize,
        (point.y + offsetY) * cellSize
      ])
    );
  }

  private simplify(points: Point[], tolerance: number, highQuality: boolean): Point[] {
    return simplify(points, tolerance, highQuality);
  }
}
</file>

<file path="packages/frontend/src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import { ThemeProvider } from '@mui/material/styles'
import CssBaseline from '@mui/material/CssBaseline'
import { createMaterialTheme } from './utils/materialTheme'
import App from './App.tsx'
import './index.css'

const theme = createMaterialTheme()

// Development-only: capture unhandled promise rejections with extra context
// determine dev mode safely (works in Vite and non-Vite environments)
const _isDev = typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production'
  ? process.env.NODE_ENV !== 'production'
  : typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')

if (_isDev) {
  window.addEventListener('unhandledrejection', (ev: PromiseRejectionEvent) => {
    try {
      // Print a compact, consistent grouping so we can copy/paste the stack
      // and quickly identify origin (extension vs app code).
      // Avoid throwing from the handler.
      // eslint-disable-next-line no-console
      console.groupCollapsed('[DEV] Unhandled rejection captured')
      // eslint-disable-next-line no-console
      console.log('reason:', ev.reason)
      // eslint-disable-next-line no-console
      console.log('stack:', ev.reason && ev.reason.stack)
      // eslint-disable-next-line no-console
      console.log('promise:', ev.promise)
      // eslint-disable-next-line no-console
      console.log('event:', ev)
      // eslint-disable-next-line no-console
      console.groupEnd()
    } catch (e) {
      // swallow any error from logging
    }
  })
}

import { ErrorBoundary } from './components/ErrorBoundary';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <ErrorBoundary>
        <App />
      </ErrorBoundary>
    </ThemeProvider>
  </React.StrictMode>,
)
</file>

<file path="packages/frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */

// Centralized color tokens (moved from src/constants/colors.js)
const { colorTokens } = require('../../shared/src/constants/colorConstants.ts');

export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Keep the original tokens for static references
        ...colorTokens,
        // Add aliases that map to CSS variables so Tailwind utilities can use runtime theme values
        'background-primary': 'var(--color-background-primary)',
        'background-secondary': 'var(--color-background-secondary)',
        'background-tertiary': 'var(--color-background-tertiary)',
        'surface': 'var(--color-surface)',
        'surface-variant': 'var(--color-surface-variant)',

        'text-primary': 'var(--color-text-primary)',
        'text-secondary': 'var(--color-text-secondary)',
        'text-tertiary': 'var(--color-text-tertiary)',

        'primary': 'var(--color-primary)',
        'primary-container': 'var(--color-primary-container)',
        'on-primary': 'var(--color-on-primary)',

        'secondary': 'var(--color-secondary)',
        'secondary-container': 'var(--color-secondary-container)',
        'on-secondary': 'var(--color-on-secondary)',

        'tertiary': 'var(--color-tertiary)',
        'tertiary-container': 'var(--color-tertiary-container)',

        'error': 'var(--color-error)',
        'error-container': 'var(--color-error-container)',

        'success': 'var(--color-success)',
        'success-container': 'var(--color-success-container)',

        'warning': 'var(--color-warning)',
        'warning-container': 'var(--color-warning-container)',

        'outline': 'var(--color-outline)',

        'legend-knight': 'var(--color-legend-knight)',
        'legend-rogue': 'var(--color-legend-rogue)',
        'legend-mage': 'var(--color-legend-mage)',
        'legend-npc': 'var(--color-legend-npc)',
        'legend-item': 'var(--color-legend-item)',

        // Health and status
        'health-healthy': 'var(--color-health-healthy)',
        'health-wounded': 'var(--color-health-wounded)',
        'health-critical': 'var(--color-health-critical)',
        'health-dying': 'var(--color-health-dying)',

        'status-active-bg': 'var(--color-status-active-bg)',
        'status-active-text': 'var(--color-status-active-text)',
        'status-active-border': 'var(--color-status-active-border)',
        'status-negative-bg': 'var(--color-status-negative-bg)',
        'status-negative-text': 'var(--color-status-negative-text)',
        'status-negative-border': 'var(--color-status-negative-border)',
      },
      fontFamily: {
        'jetbrains': ['JetBrains Mono', 'monospace'],
        inter: ['Inter', 'sans-serif'],
      },
      spacing: {
        xs: 'var(--spacing-xs)',
        sm: 'var(--spacing-sm)',
        md: 'var(--spacing-md)',
        lg: 'var(--spacing-lg)',
        xl: 'var(--spacing-xl)',
      },
      borderRadius: {
        sm: 'var(--radius-sm)',
        md: 'var(--radius-md)',
        lg: 'var(--radius-lg)',
        xl: 'var(--radius-xl)',
        full: 'var(--radius-full)',
      },
      boxShadow: {
        sm: 'var(--shadow-sm)',
        md: 'var(--shadow-md)',
        lg: 'var(--shadow-lg)',
        xl: 'var(--shadow-xl)',
      },
      transitionProperty: {
        fast: 'var(--transition-fast)',
        normal: 'var(--transition-normal)',
        slow: 'var(--transition-slow)',
      },
    },
  },
  plugins: [],
};
</file>

<file path="packages/frontend/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      'shared': path.resolve(__dirname, '../shared/src'),
      '~': path.resolve(__dirname, './src')
    }
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://127.0.0.1:8081',
        changeOrigin: true,
      },
      '/socket.io': {
        target: 'http://127.0.0.1:8081',
        ws: true,
      }
    }
  }
})
</file>

<file path="packages/frontend/vitest.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    environmentOptions: {
      jsdom: {
        resources: 'usable',
      },
    },
  },
  resolve: {
    alias: {
      'shared': path.resolve(__dirname, '../shared/src'),
      '~': path.resolve(__dirname, './src')
    }
  }
})
</file>

<file path="packages/shared/src/constants/colorConstants.ts">
export const colorTokens = {
  primary: '#31748f',
  'primary-container': '#1e40af',
  'on-primary': '#1f1d2e',
  secondary: '#9ccfd8',
  'secondary-container': '#334155',
  'on-secondary': '#1f1d2e',
  surface: '#1f1d2e',
  'surface-variant': '#2a2a3e',
  'on-surface': '#e0def4',
  'on-surface-variant': '#908caa',
  outline: '#6e6a86',
  background: '#191724',
  'on-background': '#e0def4',
  error: '#dc2626',
  'on-error': '#1f1d2e',
  'error-container': '#7f1d1d',
  'on-error-container': '#fef2f2',
  text: {
    primary: '#e0def4',
    secondary: '#908caa',
    tertiary: '#6e6a86',
  },
  health: {
    healthy: '#a3e635',
    wounded: '#fbbf24',
    critical: '#f97316',
    dying: '#dc2626',
  },
  status: {
    active: {
      bg: 'rgba(163, 230, 53, 0.2)',
      text: '#a3e635',
      border: '#84cc16',
    },
    negative: {
      bg: 'rgba(220, 38, 38, 0.2)',
      text: '#dc2626',
      border: '#b91c1c',
    },
  },
  backgroundDark: '#191724',
  backgroundMedium: '#1f1d2e',
  textLight: '#e0def4',
  accentPurple: '#c4a7e7',
  primaryBlue: '#31748f',
  secondaryBlue: '#9ccfd8',
  accentDarkPurple: '#9b59b6',
  legendKnight: '#FFD700',
  legendRogue: '#8B0000',
  legendMage: '#4B0082',
  legendNPC: '#DC143C',
  legendItem: '#F59E0B',
  tabSettings: '#17a2b8',
  healthFillHealthyStart: '#22c55e',
  healthFillHealthyEnd: '#16a34a',
  healthFillWoundedStart: '#fbbf24',
  healthFillWoundedEnd: '#f59e0b',
  healthFillCriticalStart: '#f97316',
  healthFillCriticalEnd: '#ea580c',
  healthFillDyingStart: '#dc2626',
  healthFillDyingEnd: '#b91c1c',
  expFillStart: '#f6c177',
  expFillEnd: '#ebbcba',
  expValue: '#f6c177',
  textLightAlt: '#ecf0f1',
  textMedium: '#bdc3c7',
  borderGray: '#6e6a86',
  textDark: '#908caa',
};

export const RARITY_COLORS = {
  common: '#9CA3AF',
  uncommon: '#10B981',
  rare: '#3B82F6',
  epic: '#8B5CF6',
  legendary: '#F59E0B'
};
</file>

<file path="packages/shared/src/constants/gameConstants.ts">
import { PlayerClass, GameSettings } from '../types/game';
import { BiomeType } from '../types/biomes';

// Game Configuration Constants
export const GAME_CONFIG: GameSettings = {
  gridWidth: 20,
  gridHeight: 15,
  tileSize: 32, // Standard tile size in pixels for UI rendering (increased from 20px for larger canvas)
  maxPlayers: 50,
  cataclysmDuration: 300000, // 5 minutes in milliseconds
  spawnCost: 100, // channel points to spawn
  autoWanderCost: 50, // channel points for auto-wander
  nightMode: false, // Default to day mode
  // Tarkov-style looting settings
  lootingEnabled: true,
  itemRevealTimes: {
    common: 2000, // 2 seconds
    uncommon: 4000, // 4 seconds
    rare: 8000, // 8 seconds
    epic: 15000, // 15 seconds
    legendary: 30000 // 30 seconds
  },
  maxItemsPerTile: 4, // Increased from 3
  itemSpawnRate: 0.20, // Increased from 0.15 (20% chance when terrain regenerates)
  lootInteractionRadius: 1, // Adjacent tiles
  baseStats: {
    [PlayerClass.KNIGHT]: {
      hp: 120,
      maxHp: 120,
      attack: 15,
      defense: 20,
      speed: 8
    },
    [PlayerClass.ROGUE]: {
      hp: 90,
      maxHp: 90,
      attack: 25,
      defense: 10,
      speed: 15
    },
    [PlayerClass.MAGE]: {
      hp: 80,
      maxHp: 80,
      attack: 30,
      defense: 5,
      speed: 10
    }
  },
  terrainConfig: {
    [BiomeType.PLAIN]: { movementCost: 1, defenseBonus: 0, visibilityModifier: 0, spawnChance: 0.3 },
    [BiomeType.FOREST]: { movementCost: 2, defenseBonus: 5, visibilityModifier: -2, spawnChance: 0.18 },
    [BiomeType.MOUNTAIN]: { movementCost: 3, defenseBonus: 15, visibilityModifier: 3, spawnChance: 0.1 },
    [BiomeType.WATER]: { movementCost: 1.5, defenseBonus: 0, visibilityModifier: 0, spawnChance: 0.05 },
    [BiomeType.OCEAN]: { movementCost: 2.0, defenseBonus: 0, visibilityModifier: 0, spawnChance: 0.02 },
    [BiomeType.RIVER]: { movementCost: 1.2, defenseBonus: 0, visibilityModifier: 0, spawnChance: 0.03 },
    [BiomeType.MOUNTAIN_PEAK]: { movementCost: 4, defenseBonus: 20, visibilityModifier: 4, spawnChance: 0.02 },
    [BiomeType.HILLS]: { movementCost: 1.2, defenseBonus: 2, visibilityModifier: 0, spawnChance: 0.08 },
    [BiomeType.SNOW]: { movementCost: 1.8, defenseBonus: 5, visibilityModifier: -1, spawnChance: 0.01 },
    [BiomeType.ICE]: { movementCost: 2.5, defenseBonus: 0, visibilityModifier: -1.5, spawnChance: 0.01 },
    [BiomeType.SNOWY_HILLS]: { movementCost: 2.0, defenseBonus: 7, visibilityModifier: 0, spawnChance: 0.03 },
    [BiomeType.DUNES]: { movementCost: 1.5, defenseBonus: 0, visibilityModifier: 0.5, spawnChance: 0.02 },
    [BiomeType.OASIS]: { movementCost: 1.0, defenseBonus: 1, visibilityModifier: 0, spawnChance: 0.005 },
    [BiomeType.SAND]: { movementCost: 1.3, defenseBonus: 0, visibilityModifier: 0.3, spawnChance: 0.04 },
    [BiomeType.DENSE_JUNGLE]: { movementCost: 3.0, defenseBonus: 10, visibilityModifier: -3, spawnChance: 0.02 },
    [BiomeType.JUNGLE]: { movementCost: 2.5, defenseBonus: 8, visibilityModifier: -2.5, spawnChance: 0.04 },
    [BiomeType.DEEP_WATER]: { movementCost: 3.0, defenseBonus: 0, visibilityModifier: -1, spawnChance: 0.01 },
    [BiomeType.MARSH]: { movementCost: 2.0, defenseBonus: 3, visibilityModifier: -1, spawnChance: 0.02 },
    [BiomeType.SWAMP]: { movementCost: 2.2, defenseBonus: 5, visibilityModifier: -1.5, spawnChance: 0.02 },
    [BiomeType.DENSE_FOREST]: { movementCost: 2.8, defenseBonus: 12, visibilityModifier: -2.5, spawnChance: 0.03 },
    [BiomeType.CLEARING]: { movementCost: 1.0, defenseBonus: 0, visibilityModifier: 0, spawnChance: 0.02 },
    [BiomeType.ROLLING_HILLS]: { movementCost: 1.3, defenseBonus: 3, visibilityModifier: 0, spawnChance: 0.06 },
    [BiomeType.FLOWER_FIELD]: { movementCost: 1.0, defenseBonus: 1, visibilityModifier: 0, spawnChance: 0.01 },
    [BiomeType.GRASSLAND]: { movementCost: 1.0, defenseBonus: 0, visibilityModifier: 0, spawnChance: 0.08 },
    [BiomeType.ROUGH_TERRAIN]: { movementCost: 2.0, defenseBonus: 5, visibilityModifier: 0, spawnChance: 0.03 },
    [BiomeType.ANCIENT_RUINS]: { movementCost: 1.5, defenseBonus: 8, visibilityModifier: 1, spawnChance: 0.008 },
    [BiomeType.DESERT]: { movementCost: 1.5, defenseBonus: 0, visibilityModifier: 2, spawnChance: 0.02 },
    [BiomeType.WASTELAND]: { movementCost: 2.5, defenseBonus: 2, visibilityModifier: 1, spawnChance: 0.01 },
    [BiomeType.TOXIC_ZONE]: { movementCost: 3, defenseBonus: -5, visibilityModifier: -1, spawnChance: 0.005 },
    [BiomeType.RADIATION_FIELD]: { movementCost: 3, defenseBonus: -5, visibilityModifier: -1, spawnChance: 0.005 },
    [BiomeType.CRYSTAL_GARDEN]: { movementCost: 1.5, defenseBonus: 5, visibilityModifier: 2, spawnChance: 0.001 },
    [BiomeType.URBAN_RUINS]: { movementCost: 1.8, defenseBonus: 3, visibilityModifier: 0, spawnChance: 0.008 },
    [BiomeType.INFECTED_NORMAL]: { movementCost: 2, defenseBonus: 0, visibilityModifier: -1, spawnChance: 0.01 },
    [BiomeType.INFECTED_HEAVY]: { movementCost: 2.5, defenseBonus: -2, visibilityModifier: -2, spawnChance: 0.005 },
    [BiomeType.INFECTED_CORE]: { movementCost: 4, defenseBonus: -10, visibilityModifier: -3, spawnChance: 0.001 },
  }
};

// Game Balance Constants
export const COMBAT_CONSTANTS = {
  BASE_DAMAGE_MULTIPLIER: 1.2,
  CRITICAL_HIT_CHANCE: 0.1,
  CRITICAL_DAMAGE_MULTIPLIER: 2.0,
  MIN_DAMAGE: 5,
  MAX_DAMAGE: 50,
  EXPERIENCE_PER_LEVEL: 100,
  LEVEL_SCALING_FACTOR: 1.15
};

export const MOVEMENT_CONSTANTS = {
  BASE_MOVE_COOLDOWN: 1000, // 1 second
  AUTO_WANDER_INTERVAL: 5000, // 5 seconds
  MAX_MOVE_DISTANCE: 1,
  MAX_ADJACENT_MOUNTAINS: 2 // Maximum number of adjacent mountain tiles for a valid spawn position
};

export const WORLD_CONSTANTS = {
  NPC_SPAWN_CHANCE: 0.025, // Increased from 0.02
  ITEM_DROP_CHANCE: 0.18, // Increased from 0.15
  WORLD_RESET_DURATION: 30000, // 30 seconds
  MAX_ITEMS_PER_TILE: 4, // Increased from 3
  CATACLYSM_SHRINK_RATE: 0.5, // tiles per minute
  BUILDING_LOOT_BONUS: 1.5, // Multiplier for loot found in buildings
  TERRAIN_LOOT_QUALITY_ZONES: true, // Enable quality zone system
  HOTSPOT_LOOT_MULTIPLIER: 2.5, // Multiplier for loot hotspots
  CATACLYSM_LOOT_BONUS: 2.0, // Enhanced loot in cataclysm zones
  EXTREMELY_MOUNTAIN_THRESHOLD: 70 // Threshold (percentage) above which map is considered extremely mountainous for spawn fallback
};

// Class-specific abilities and descriptions
export const CLASS_INFO = {
  [PlayerClass.KNIGHT]: {
    name: 'Knight',
    description: 'High defense and HP, excels at tanking damage',
    abilities: ['Shield Bash', 'Taunt', 'Heavy Armor'],
    emoji: 'âš”ï¸'
  },
  [PlayerClass.ROGUE]: {
    name: 'Rogue',
    description: 'High attack and speed, masters of quick strikes',
    abilities: ['Backstab', 'Stealth', 'Poison Blade'],
    emoji: 'ðŸ—¡ï¸'
  },
  [PlayerClass.MAGE]: {
    name: 'Mage',
    description: 'High magic damage, controls the battlefield',
    abilities: ['Fireball', 'Teleport', 'Heal'],
    emoji: 'ðŸ”®'
  }
};

// Chat command prefixes
export const CHAT_COMMANDS = {
  SPAWN: '!spawn',
  MOVE: '!move',
  CLAIM: '!claim',
  STATUS: '!status',
  INVENTORY: '!inv',
  HELP: '!help',
  WANDER: '!wander'
};

// Terrain emojis for visual representation
export const TERRAIN_EMOJIS = {
  [BiomeType.PLAIN]: 'ðŸŒ±',
  [BiomeType.FOREST]: 'ðŸŒ²',
  [BiomeType.MOUNTAIN]: 'â›°ï¸',
  [BiomeType.WATER]: 'ðŸŒŠ',
  [BiomeType.OCEAN]: 'ðŸŒŠ',
  [BiomeType.RIVER]: 'ðŸ’§',
  [BiomeType.MOUNTAIN_PEAK]: 'ðŸ”ï¸',
  [BiomeType.HILLS]: 'ðŸŒ„',
  [BiomeType.SNOW]: 'â„ï¸',
  [BiomeType.ICE]: 'ðŸ§Š',
  [BiomeType.SNOWY_HILLS]: 'ðŸŒ¨ï¸',
  [BiomeType.DUNES]: 'ðŸœï¸',
  [BiomeType.OASIS]: 'ðŸï¸',
  [BiomeType.SAND]: 'ðŸ–ï¸',
  [BiomeType.DENSE_JUNGLE]: 'ðŸŒ³',
  [BiomeType.JUNGLE]: 'ðŸŒ´',
  [BiomeType.DEEP_WATER]: 'ðŸŒŠ',
  [BiomeType.MARSH]: 'ðŸ¸',
  [BiomeType.SWAMP]: 'ðŸŠ',
  [BiomeType.DENSE_FOREST]: 'ðŸŒ²',
  [BiomeType.CLEARING]: 'â˜€ï¸',
  [BiomeType.ROLLING_HILLS]: 'ðŸžï¸',
  [BiomeType.FLOWER_FIELD]: 'ðŸŒ¸',
  [BiomeType.GRASSLAND]: 'ðŸŒ¾',
  [BiomeType.ROUGH_TERRAIN]: 'ðŸª¨',
  [BiomeType.ANCIENT_RUINS]: 'ðŸº',
  [BiomeType.DESERT]: 'ðŸŒµ',
  [BiomeType.WASTELAND]: 'â˜¢ï¸',
  [BiomeType.TOXIC_ZONE]: 'â˜£ï¸',
  [BiomeType.RADIATION_FIELD]: 'â˜¢ï¸',
  [BiomeType.CRYSTAL_GARDEN]: 'ðŸ’Ž',
  [BiomeType.URBAN_RUINS]: 'ðŸšï¸',
  [BiomeType.INFECTED_NORMAL]: 'ðŸ¤¢',
  [BiomeType.INFECTED_HEAVY]: 'ðŸ¤®',
  [BiomeType.INFECTED_CORE]: 'ðŸ’€',
};

// Achievement definitions
export const ACHIEVEMENTS = {
  FIRST_BLOOD: {
    id: 'first_blood',
    name: 'First Blood',
    description: 'Win your first battle',
    title: '[Warrior]'
  },
  SURVIVOR: {
    id: 'survivor',
    name: 'Survivor',
    description: 'Survive a cataclysm',
    title: '[Survivor]'
  },
  GLADIATOR: {
    id: 'gladiator',
    name: 'Gladiator',
    description: 'Win 10 battles',
    title: '[Gladiator]'
  },
  EXPLORER: {
    id: 'explorer',
    name: 'Explorer',
    description: 'Visit every terrain type',
    title: '[Explorer]'
  }
};

// Default world configuration
export const DEFAULT_WORLD_CONFIG = {
  cataclysmCircle: {
    center: { x: 10, y: 8 }, // center of 20x15 grid
    radius: 20,
    isActive: false,
    shrinkRate: 1,
    nextShrinkTime: 0
  },
  worldAge: 0,
  lastResetTime: Date.now(),
  phase: 'exploration' as const
};

export const ENHANCED_RENDER_CONFIG = {
  animation: {
    enabled: true,
    frameRate: 60,
    breathingIntensity: 0.1,
    colorPulseSpeed: 0.02
  },
  performance: {
    maxBiomesPerFrame: 50,
    textureDetailDistance: 200,
    animationDistance: 300
  },
  quality: {
    roughnessQuality: 'high' as 'low' | 'medium' | 'high',
    textureDetail: 'medium' as 'low' | 'medium' | 'high',
    antiAliasing: true
  }
};
</file>

<file path="packages/shared/src/types/commands.ts">
import { z } from 'zod';

// Define command schemas
export const MoveCommandSchema = z.object({
  command: z.literal('move'),
  direction: z.enum(['north', 'south', 'east', 'west']),
  distance: z.number().optional()
});

export const TradeCommandSchema = z.object({
  command: z.literal('trade'),
  targetPlayer: z.string(),
  offerItems: z.array(z.object({
    itemId: z.string(),
    quantity: z.number()
  })),
  requestItems: z.array(z.object({
    itemId: z.string(),
    quantity: z.number()
  })).optional()
});

export const BuildCommandSchema = z.object({
  command: z.literal('build'),
  structure: z.string(),
  location: z.object({
    x: z.number(),
    y: z.number()
  }),
  rotation: z.number().optional()
});

export const GameCommandSchema = z.discriminatedUnion('command', [
  MoveCommandSchema,
  TradeCommandSchema,
  BuildCommandSchema
]);

export type GameCommand = z.infer<typeof GameCommandSchema>;
</file>

<file path="packages/shared/src/types/moderation.ts">
import { z } from 'zod';

export const ModerationResultSchema = z.object({
  isViolation: z.boolean(),
  severity: z.enum(['none', 'low', 'medium', 'high', 'critical']),
  categories: z.array(z.enum([
    'harassment',
    'hate_speech',
    'sexual_content',
    'violence',
    'spam',
    'self_harm',
    'none'
  ])),
  explanation: z.string(),
  suggestedAction: z.enum(['allow', 'flag', 'filter', 'block', 'ban']),
  filteredMessage: z.string().optional()
});

export type ModerationResult = z.infer<typeof ModerationResultSchema>;
</file>

<file path="packages/shared/src/types/network.ts">
/**
 * Options for configuring the WebSocket rate limiter.
 */
export interface RateLimiterOptions {
  /**
   * The maximum number of events allowed per window.
   * @default 10
   */
  maxEvents?: number;

  /**
   * The time window in milliseconds.
   * @default 1000 (1 second)
   */
  windowMs?: number;
}
</file>

<file path="package.json">
{
  "name": "chatterealm",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev": "pnpm --filter frontend dev & pnpm --filter backend dev",
    "build": "pnpm --filter shared build && pnpm --filter frontend build && pnpm --filter backend build",
    "build:shared": "pnpm --filter shared build",
    "test": "pnpm --filter frontend test && pnpm --filter backend test",
    "lint": "pnpm --filter frontend lint"
  },
  "resolutions": {
    "@types/react": "^18.3.18"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.13"
  }
}
</file>

<file path="README.md">
# ChatterRealm

A real-time multiplayer chat application with game-like features, built with React, TypeScript, Socket.IO, and modern web technologies.

## ðŸ—ï¸ Architecture

ChatterRealm is built as a monorepo with three main packages:

- **Frontend** (`packages/frontend`): React-based UI with Material-UI, Tailwind CSS, and GSAP animations
- **Backend** (`packages/backend`): Express server with Socket.IO for real-time communication
- **Shared** (`packages/shared`): Shared TypeScript types and constants

## ðŸš€ Quick Start

### Prerequisites

- Node.js 20+ 
- pnpm (we use pnpm for package management)

### Installation

1. Install pnpm if you haven't already:
```bash
npm install -g pnpm
```

2. Clone the repository:
```bash
git clone https://github.com/myrqyry/chatterealm.git
cd chatterealm
```

3. Install dependencies:
```bash
pnpm install
```

4. Set up environment variables:
```bash
# Frontend (optional for development)
cp packages/frontend/.env.example packages/frontend/.env.development

# Backend
cp packages/backend/.env.example packages/backend/.env.development
```

### Development

Run both frontend and backend in development mode:

```bash
pnpm dev
```

Or run them separately:

```bash
# Frontend (runs on http://localhost:5173)
pnpm --filter frontend dev

# Backend (runs on http://localhost:8081)
pnpm --filter backend dev
```

### Building

Build all packages:

```bash
pnpm build
```

Build individual packages:

```bash
# Build shared types first (required by other packages)
pnpm build:shared

# Build frontend
pnpm --filter frontend build

# Build backend
pnpm --filter backend build
```

### Testing

Run tests:

```bash
# Run all tests
pnpm test

# Run frontend tests
pnpm --filter frontend test

# Run frontend tests with UI
pnpm --filter frontend test:ui

# Run backend tests
pnpm --filter backend test
```

## ðŸ“ Project Structure

```
chatterealm/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ frontend/          # React frontend application
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/   # React components
â”‚   â”‚   â”‚   â”œâ”€â”€ services/     # API and business logic
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/        # Custom React hooks
â”‚   â”‚   â”‚   â””â”€â”€ utils/        # Utility functions
â”‚   â”‚   â”œâ”€â”€ vite.config.ts    # Vite configuration
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”‚
â”‚   â”œâ”€â”€ backend/           # Express backend server
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ services/     # Business logic services
â”‚   â”‚   â”‚   â””â”€â”€ index.ts      # Server entry point
â”‚   â”‚   â”œâ”€â”€ scripts/          # Utility scripts
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”‚
â”‚   â””â”€â”€ shared/            # Shared types and constants
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ types/        # TypeScript type definitions
â”‚       â”‚   â””â”€â”€ constants/    # Shared constants
â”‚       â””â”€â”€ package.json
â”‚
â”œâ”€â”€ package.json           # Root package.json with workspace config
â”œâ”€â”€ pnpm-workspace.yaml    # pnpm workspace configuration
â””â”€â”€ pnpm-lock.yaml         # Locked dependency versions
```

## ðŸ› ï¸ Technology Stack

### Frontend
- **React 18** - UI framework
- **TypeScript** - Type safety
- **Vite 6** - Build tool and dev server
- **Material-UI (MUI)** - Component library
- **Tailwind CSS 4** - Utility-first CSS
- **Socket.IO Client** - Real-time communication
- **GSAP** - Advanced animations
- **Tone.js** - Audio synthesis
- **Zustand** - State management
- **Vitest** - Testing framework

### Backend
- **Express 4** - Web framework
- **Socket.IO** - WebSocket server
- **TypeScript** - Type safety
- **express-rate-limit** - API rate limiting
- **CORS** - Cross-origin resource sharing
- **Jest** - Testing framework

## ðŸŽ® Features

- Real-time multiplayer chat with game-like mechanics
- Grid-based world with terrain generation
- Player avatars and character classes
- Building and item systems
- NPC interactions
- Sound effects and audio feedback
- Responsive design with modern UI

## ðŸ”§ Development Workflow

### Package Management

We use **pnpm** exclusively for package management. This ensures:
- Faster installation times
- Efficient disk space usage
- Strict dependency resolution
- Better workspace support

**Important:** Always use `pnpm` commands, not `npm` or `yarn`.

### Build Order

The shared package must be built before other packages:

1. `shared` package exports TypeScript types and constants
2. `frontend` and `backend` depend on the compiled `shared` package
3. The build scripts handle this automatically

### Linting

Lint the frontend code:

```bash
pnpm --filter frontend lint
```

### Code Style

- TypeScript strict mode enabled
- ESLint configured for React and TypeScript
- Consistent code formatting

## ðŸŒ Environment Variables

### Frontend

Create `packages/frontend/.env.development` or `.env.production`:

```env
# Optional - uses proxy in development
VITE_API_URL=https://api.chatterealm.com
VITE_WS_URL=wss://api.chatterealm.com
```

### Backend

Create `packages/backend/.env.development` or `.env.production`:

```env
PORT=8081
NODE_ENV=development
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
```

## ðŸ”’ Security

- Rate limiting on API endpoints (100 requests per 15 minutes)
- CORS configured for allowed origins only
- Environment-based configuration for production
- No secrets in source code

## ðŸ“ Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes
4. Run tests and linting
5. Commit your changes (`git commit -m 'Add amazing feature'`)
6. Push to the branch (`git push origin feature/amazing-feature`)
7. Open a Pull Request

### Contribution Guidelines

- Follow the existing code style
- Add tests for new features
- Update documentation as needed
- Keep commits focused and atomic
- Write clear commit messages

## ðŸ“„ License

[Add your license here]

## ðŸ¤ Support

For issues, questions, or contributions, please open an issue on GitHub.

## ðŸ—ºï¸ Roadmap

- [ ] Enhanced error boundaries and error handling
- [ ] Comprehensive test coverage
- [ ] Performance optimization and bundle size reduction
- [ ] API documentation
- [ ] Deployment guides
- [ ] CI/CD pipeline setup

## ðŸ“š Additional Documentation

- [Styling Strategy](packages/frontend/styling-consistency-strategy.md) - Guidelines for using Material-UI and Tailwind CSS together
- [Animation Libraries](packages/frontend/animation-libraries.md) - Overview of GSAP and animation patterns (if exists)

---

Built with â¤ï¸ by the ChatterRealm team
</file>

<file path="packages/backend/src/__tests__/server.test.ts">
import request from 'supertest';
import { app, httpServer } from '../index';

describe('Server Initialization', () => {
  beforeAll((done) => {
    // Wait for the async server start to complete
    setTimeout(done, 1000);
  });

  afterAll((done) => {
    if (httpServer.listening) {
      httpServer.close(done);
    } else {
      done();
    }
  });

  it('should start successfully without Twitch credentials', async () => {
    const response = await request(app).get('/');
    expect(response.status).toBe(200);
    expect(response.body.status).toBe('ok');
  });
});
</file>

<file path="packages/backend/src/handlers/CharacterHandler.ts">
import { Server, Socket } from 'socket.io';
import { gameService } from '../services/GameService';
import { Player, PlayerClass, CHARACTER_CLASSES } from '@chatterealm/shared';

export class CharacterHandler {
  constructor(
    private io: Server
  ) {}

  public async handleCreateCharacter(socket: Socket, data: any): Promise<void> {
    try {
      const { characterData } = data;

      if (!this.validateCharacterData(characterData)) {
        socket.emit('error', { message: 'Invalid character data received.' });
        console.error('Invalid character data:', characterData);
        return;
      }

      // The GameStateManager will find a suitable spawn position.
      // We provide a placeholder position here.
      const player: Player = {
        id: characterData.id,
        name: characterData.name,
        displayName: characterData.name,
        avatar: characterData.emoji,
        position: { x: -1, y: -1 },

        // New character class system fields
        characterClass: characterData.characterClass,
        visual: characterData.visual,
        characterStats: { ...characterData.characterClass.baseStats },
        abilities: characterData.characterClass.abilities.filter((a: any) => a.unlockLevel <= 1),
        resources: {
          [characterData.characterClass.primaryResource]: 100
        },

        // Legacy fields for backward compatibility
        class: PlayerClass.KNIGHT, // Default legacy class
        stats: { hp: 100, maxHp: 100, attack: 10, defense: 5, speed: 5 }, // Default legacy stats
        health: 100,
        mana: 50,
        stamina: 100,
        hunger: 100,
        thirst: 100,

        // Standard player fields
        level: 1,
        experience: 0,
        inventory: [],
        equipment: {},
        achievements: [],
        titles: [],
        isAlive: true,
        lastMoveTime: Date.now(),
        spawnTime: Date.now(),
        connected: true,
        lastActive: Date.now(),
        buffs: [],
      };

      // Add the new player to the game world using GameService
      const roomId = 'main_room';
      const room = await gameService.joinRoom(roomId, player);

      if (room) {
        socket.emit('character_created', {
          success: true,
          player: player
        });

        // Make the player's socket join the room's channel
        socket.join(roomId);

        // Notify other players in the room that a new player has joined
        socket.to(roomId).emit('player_joined', { player });

        console.log(`Player ${player.name} (${player.id}) created and joined room ${roomId}.`);
      } else {
        socket.emit('character_created', {
          success: false,
          error: 'Failed to add character to the game world.'
        });
      }
    } catch (error) {
      console.error('An error occurred during character creation:', error);
      socket.emit('error', { message: 'A server error occurred during character creation.' });
    }
  }

  private validateCharacterData(data: any): boolean {
    if (!data || !data.id || !data.name || !data.emoji || !data.characterClass) {
      return false;
    }
    const classExists = CHARACTER_CLASSES.some(c => c.id === data.characterClass.id);
    if (!classExists) {
      return false;
    }
    return true;
  }
}
</file>

<file path="packages/backend/src/services/__tests__/gameStateManager.test.ts">
import { GameStateManager } from '../gameStateManager';

describe('GameStateManager', () => {
  let gameStateManager: GameStateManager;

  beforeEach(async () => {
    gameStateManager = await GameStateManager.create();
  });

  it('should be created', () => {
    expect(gameStateManager).toBeDefined();
  });
});
</file>

<file path="packages/backend/src/services/__tests__/PlayerMovementService.test.ts">
import { PlayerMovementService } from '../PlayerMovementService';
import { createMockGameWorld, createMockPlayer } from '../../testUtils/mockGameWorld';
import { GameWorld, Player, Position } from '@chatterealm/shared';

describe('PlayerMovementService', () => {
  let gameWorld: GameWorld;
  let player: Player;
  let movementService: PlayerMovementService;

  beforeEach(() => {
    gameWorld = createMockGameWorld(100, 100); // Create a large world
    player = createMockPlayer('player-1', 'Test Player', { x: 10, y: 10 });
    gameWorld.players.push(player);
    movementService = new PlayerMovementService(gameWorld);
  });

  describe('requestMoveTo', () => {
    it('should reject distant move requests instantly without expensive pathfinding', () => {
      const target: Position = { x: 80, y: 80 }; // A target far away

      const startTime = performance.now();
      const result = movementService.requestMoveTo(player.id, target, gameWorld);
      const duration = performance.now() - startTime;

      // This will fail initially. The goal is to make it pass.
      expect(result.success).toBe(false);
      expect(result.message).toBe('Target is too far.');
      expect(duration).toBeLessThan(50); // Should be very fast
    });
  });
});
</file>

<file path="packages/backend/src/services/aiProxyService.ts">
import { Request, Response } from 'express';
import { body, validationResult } from 'express-validator';
import GeminiClient from './geminiClient';

const ALLOWED_MODELS = ['gemini-pro'];

class AIProxyService {
  private client = GeminiClient.getInstance();

  validateRequest = [
    body('model').isIn(ALLOWED_MODELS).withMessage('Invalid model specified.'),
    body('contents').isArray({ min: 1, max: 10 }).withMessage('Contents must be a non-empty array with at most 10 elements.'),
    body('config').optional().isObject().withMessage('Config must be an object.'),
  ];

  async handleRequest(req: Request, res: Response) {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      const { model, contents, config } = req.body;
      const generativeModel = this.client.getGenerativeModel({ model });
      const result = await generativeModel.generateContent({ contents, generationConfig: config });
      const responseText = result.response.text();
      const data = JSON.parse(responseText);
      res.json(data);
    } catch (error) {
      console.error('AI Proxy Error:', error);
      res.status(500).json({ error: 'Failed to process AI request' });
    }
  }
}

export default new AIProxyService();
</file>

<file path="packages/backend/src/services/CataclysmService.ts">
import { GameWorld, Position, BiomeType, Player, GAME_CONFIG } from '@chatterealm/shared';
import { LootManager } from './LootManager';
import { NPCManager } from './NPCManager';

export interface GameEvent {
  type: string;
  data?: any;
}

export interface GameActionResult {
  success: boolean;
  message: string;
  data?: any;
}

export class CataclysmService {
  private lootManager: LootManager;
  private npcManager: NPCManager;
  private occupiedPositions: Set<string>;
  private rebirthEndTime: number | null = null;

  constructor(lootManager: LootManager, npcManager: NPCManager, occupiedPositions: Set<string>) {
    this.lootManager = lootManager;
    this.npcManager = npcManager;
    this.occupiedPositions = occupiedPositions;
  }

  /**
   * Start the cataclysm event
   */
  public startCataclysm(gameWorld: GameWorld): { result: GameActionResult, events: GameEvent[] } {
    if (gameWorld.cataclysmCircle.isActive) {
      return { result: { success: false, message: 'Cataclysm is already active.' }, events: [] };
    }

    gameWorld.cataclysmCircle.isActive = true;
    gameWorld.cataclysmCircle.nextShrinkTime = Date.now() + 10000; // Start shrinking in 10 seconds for faster demo
    gameWorld.phase = 'cataclysm';

    const event: GameEvent = { type: 'cataclysm_started', data: { timestamp: Date.now() } };

    return {
      result: {
        success: true,
        message: 'The cataclysm has begun! The world will start changing soon.'
      },
      events: [event]
    };
  }

  /**
   * Update cataclysm mechanics each tick
   */
  public updateCataclysm(gameWorld: GameWorld): void {
    if (!gameWorld.cataclysmCircle.isActive) return;

    const now = Date.now();
    
    if (now >= gameWorld.cataclysmCircle.nextShrinkTime) {
      const oldRadius = gameWorld.cataclysmCircle.radius;
      gameWorld.cataclysmCircle.radius = Math.max(0, gameWorld.cataclysmCircle.radius - 1);

      // Calculate roughness multiplier based on cataclysm progress
      // Start at 1.0 (normal), increase to 4.0 (very chaotic) as radius shrinks
      const initialRadius = Math.max(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight);
      const progress = 1 - (gameWorld.cataclysmCircle.radius / initialRadius);
      gameWorld.cataclysmRoughnessMultiplier = 1.0 + (progress * 3.0); // 1.0 to 4.0

      // Regenerate terrain in the newly affected area (between old and new radius)
      if (oldRadius > gameWorld.cataclysmCircle.radius) {
        this.regenerateTerrainInCataclysmZone(gameWorld, oldRadius, gameWorld.cataclysmCircle.radius);
      }

      // Schedule next shrink
      gameWorld.cataclysmCircle.nextShrinkTime = now + 60000; // Shrink every minute

      // Check if cataclysm should end
      if (gameWorld.cataclysmCircle.radius <= 0) {
        this.endCataclysm(gameWorld);
      }
    }
  }

  /**
   * Regenerate terrain in the cataclysm zone
   */
  private regenerateTerrainInCataclysmZone(gameWorld: GameWorld, oldRadius: number, newRadius: number): void {
    const center = gameWorld.cataclysmCircle.center;

    // Regenerate terrain in the ring between oldRadius and newRadius
    for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
      for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
        const distance = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));

        // If this tile is in the affected zone (between old and new radius)
        if (distance <= oldRadius && distance > newRadius) {
          // Regenerate terrain with some cataclysm effects
          const terrainType = this.generateBiomeType();
          const config = GAME_CONFIG.terrainConfig[terrainType];

          // Apply cataclysm transformation - make terrain more chaotic
          let transformedType = terrainType;
          if (Math.random() < 0.3) { // 30% chance of transformation
            // Transform some terrain types to more dangerous/chaotic versions
            switch (terrainType) {
              case BiomeType.FOREST:
                transformedType = Math.random() < 0.5 ? BiomeType.DENSE_FOREST : BiomeType.ANCIENT_RUINS;
                break;
              case BiomeType.PLAIN:
                transformedType = Math.random() < 0.4 ? BiomeType.ROUGH_TERRAIN : BiomeType.ANCIENT_RUINS;
                break;
              case BiomeType.GRASSLAND:
                transformedType = Math.random() < 0.3 ? BiomeType.SWAMP : BiomeType.FLOWER_FIELD;
                break;
              case BiomeType.MOUNTAIN:
                transformedType = Math.random() < 0.5 ? BiomeType.MOUNTAIN_PEAK : BiomeType.ROUGH_TERRAIN;
                break;
            }
          }

          const transformedConfig = GAME_CONFIG.terrainConfig[transformedType];
          gameWorld.grid[y][x] = {
            type: transformedType,
            position: { x, y },
            movementCost: transformedConfig.movementCost,
            defenseBonus: transformedConfig.defenseBonus,
            visibilityModifier: transformedConfig.visibilityModifier
          } as any;
        }
      }
    }

    // Generate new NPCs in the regenerated area
    const newNPCs = this.npcManager.generateNPCsInZone(
      center, 
      newRadius, 
      oldRadius, 
      GAME_CONFIG.gridWidth, 
      GAME_CONFIG.gridHeight, 
      gameWorld.grid
    );
    gameWorld.npcs.push(...newNPCs);
    
    // Generate enhanced loot in the regenerated zone
    this.generateCataclysmZoneLoot(gameWorld, newRadius, oldRadius);
  }

  /**
   * Generate enhanced loot in cataclysm regenerated zones
   */
  private generateCataclysmZoneLoot(gameWorld: GameWorld, innerRadius: number, outerRadius: number): void {
    const center = gameWorld.cataclysmCircle.center;
    const areaSize = Math.PI * (outerRadius * outerRadius - innerRadius * innerRadius);
    
    // Increase loot spawn rate in cataclysm zones (2x base rate)
    const lootCount = Math.floor(areaSize * GAME_CONFIG.itemSpawnRate * 2);

    for (let i = 0; i < lootCount; i++) {
      let attempts = 0;
      let position: Position | null = null;

      while (attempts < 30 && !position) {
        const angle = Math.random() * Math.PI * 2;
        const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
        const x = Math.round(center.x + Math.cos(angle) * distance);
        const y = Math.round(center.y + Math.sin(angle) * distance);

        if (x >= 0 && x < GAME_CONFIG.gridWidth && y >= 0 && y < GAME_CONFIG.gridHeight &&
            !this.occupiedPositions.has(`${x},${y}`)) {
          position = { x, y };
        }
        attempts++;
      }

      if (position) {
        const terrain = gameWorld.grid[position.y][position.x];
        const item = this.lootManager.generateTerrainBasedLoot(position, terrain.type, true); // Enhanced cataclysm loot
        if (item) {
          gameWorld.items.push(item);
        }
      }
    }
  }

  /**
   * End the cataclysm and enter rebirth phase
   */
  private endCataclysm(gameWorld: GameWorld): void {
    gameWorld.cataclysmCircle.isActive = false;
    gameWorld.cataclysmCircle.radius = Math.max(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight);
    gameWorld.cataclysmCircle.nextShrinkTime = 0;
    gameWorld.cataclysmRoughnessMultiplier = 1.0;
    gameWorld.phase = 'rebirth';

    // Set the end time for the rebirth phase
    this.rebirthEndTime = Date.now() + 5000; // 5 seconds rebirth phase
  }

  /**
   * Reset the world after cataclysm
   */
  private resetWorld(gameWorld: GameWorld): void {
    gameWorld.cataclysmCircle.isActive = false;
    gameWorld.cataclysmCircle.radius = Math.max(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight);
    gameWorld.cataclysmCircle.nextShrinkTime = 0;
    gameWorld.cataclysmRoughnessMultiplier = 1.0;
    gameWorld.phase = 'rebirth';

    // Regenerate terrain
    this.regenerateTerrain(gameWorld);

    // Respawn defeated players
    gameWorld.players.forEach(player => {
      if (!player.isAlive) {
        player.isAlive = true;
        player.stats.hp = player.stats.maxHp;
        // Position will be set when they spawn
      }
    });

    // The phase will be transitioned back to 'exploration' in the update loop
  }

  /**
   * Regenerate terrain for world reset
   */
  private regenerateTerrain(gameWorld: GameWorld): void {
    // Clear existing items and NPCs
    gameWorld.items = [];
    gameWorld.npcs = [];

    // Regenerate terrain grid
    for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
      for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
        const terrainType = this.generateBiomeType();
        const config = GAME_CONFIG.terrainConfig[terrainType];
        gameWorld.grid[y][x] = {
          type: terrainType,
          position: { x, y },
          movementCost: config.movementCost,
          defenseBonus: config.defenseBonus,
          visibilityModifier: config.visibilityModifier
        } as any;
      }
    }

    // Generate new NPCs
    const newNPCs = this.npcManager.generateNPCs(
      GAME_CONFIG.gridWidth, 
      GAME_CONFIG.gridHeight, 
      gameWorld.grid
    );
    gameWorld.npcs = newNPCs;
  }

  /**
   * Generate a random terrain type based on spawn chances
   */
  private generateBiomeType(): BiomeType {
    const rand = Math.random();
    let cumulative = 0;
    
    for (const [terrainType, config] of Object.entries(GAME_CONFIG.terrainConfig)) {
      cumulative += config.spawnChance;
      if (rand <= cumulative) {
        return terrainType as BiomeType;
      }
    }
    
    return BiomeType.PLAIN;
  }

  /**
   * Check if a position is in the cataclysm circle
   */
  public isInCataclysmCircle(position: Position, gameWorld: GameWorld): boolean {
    if (!gameWorld.cataclysmCircle.isActive) return false;
    
    const center = gameWorld.cataclysmCircle.center;
    const distance = Math.sqrt(Math.pow(position.x - center.x, 2) + Math.pow(position.y - center.y, 2));
    return distance >= gameWorld.cataclysmCircle.radius;
  }

  /**
   * Get cataclysm status information
   */
  public getCataclysmStatus(gameWorld: GameWorld): {
    isActive: boolean;
    radius: number;
    center: Position;
    nextShrinkTime: number;
    phase: string;
  } {
    return {
      isActive: gameWorld.cataclysmCircle.isActive,
      radius: gameWorld.cataclysmCircle.radius,
      center: gameWorld.cataclysmCircle.center,
      nextShrinkTime: gameWorld.cataclysmCircle.nextShrinkTime,
      phase: gameWorld.phase
    };
  }

  /**
   * Force trigger world regeneration (admin command)
   */
  public regenerateWorld(gameWorld: GameWorld): GameActionResult {
    // Clear all existing entities
    gameWorld.players = [];
    gameWorld.npcs = [];
    gameWorld.items = [];

    // Reset occupied positions
    this.occupiedPositions.clear();

    // Regenerate terrain
    this.regenerateTerrain(gameWorld);

    // Reset cataclysm
    gameWorld.cataclysmCircle.isActive = false;
    gameWorld.cataclysmCircle.radius = Math.max(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight);
    gameWorld.cataclysmCircle.nextShrinkTime = 0;
    gameWorld.cataclysmRoughnessMultiplier = 1.0;
    gameWorld.phase = 'exploration';

    // Reset world age
    gameWorld.worldAge = 0;
    gameWorld.lastResetTime = Date.now();

    return {
      success: true,
      message: 'World has been completely regenerated.',
      data: { worldAge: gameWorld.worldAge }
    };
  }

  /**
   * Update occupied positions reference
   */
  public updateOccupiedPositions(occupiedPositions: Set<string>): void {
    this.occupiedPositions = occupiedPositions;
  }
}
</file>

<file path="packages/backend/src/services/CombatService.ts">
import { Player, NPC, Position, Stats, Item, ItemType, ItemRarity, COMBAT_CONSTANTS, GAME_CONFIG } from '@chatterealm/shared';

export interface CombatResult {
  success: boolean;
  message: string;
  damage?: number;
  experienceGained?: number;
  levelUp?: boolean;
  lootDropped?: Item[];
}

export class CombatService {
  /**
   * Process an attack between a player and an enemy NPC
   */
  public processAttack(
    attacker: Player,
    defender: NPC,
    attackerPosition: Position,
    defenderPosition: Position
  ): CombatResult {
    // Check if attacker and defender are adjacent
    if (!this.areAdjacent(attackerPosition, defenderPosition)) {
      return {
        success: false,
        message: 'Target is not adjacent. Move closer to attack.',
      };
    }

    // Check if defender is alive
    if (!defender.isAlive) {
      return {
        success: false,
        message: 'Target is already defeated.',
      };
    }

    // Calculate damage
    const damage = this.calculateDamage(attacker.stats, defender.stats);
    
    // Apply damage
    defender.stats.hp = Math.max(0, defender.stats.hp - damage);
    
    // Check if defender is defeated
    const isDefeated = defender.stats.hp <= 0;
    if (isDefeated) {
      defender.isAlive = false;
    }

    // Calculate experience gain
    const experienceGained = this.calculateExperienceGain(defender, isDefeated);
    attacker.experience += experienceGained;

    // Check for level up
    const levelUpResult = this.checkLevelUp(attacker);

    // Generate loot if enemy was defeated
    const lootDropped = isDefeated ? this.generateLoot(defender) : undefined;

    return {
      success: true,
      message: isDefeated 
        ? `Defeated ${defender.name} for ${experienceGained} experience!`
        : `Attacked ${defender.name} for ${damage} damage. ${defender.stats.hp}/${defender.stats.maxHp} HP remaining.`,
      damage,
      experienceGained,
      levelUp: levelUpResult.levelUp,
      lootDropped
    };
  }

  /**
   * Calculate damage dealt in combat
   */
  private calculateDamage(attackerStats: Stats, defenderStats: Stats): number {
    const baseDamage = attackerStats.attack;
    const defense = defenderStats.defense;
    
    // Apply defense reduction
    let damage = Math.max(COMBAT_CONSTANTS.MIN_DAMAGE, baseDamage - defense);
    
    // Apply base damage multiplier
    damage *= COMBAT_CONSTANTS.BASE_DAMAGE_MULTIPLIER;
    
    // Random variance (Â±20%)
    const variance = 0.8 + Math.random() * 0.4;
    damage *= variance;
    
    // Check for critical hit
    if (Math.random() < COMBAT_CONSTANTS.CRITICAL_HIT_CHANCE) {
      damage *= COMBAT_CONSTANTS.CRITICAL_DAMAGE_MULTIPLIER;
    }
    
    // Cap damage
    damage = Math.min(damage, COMBAT_CONSTANTS.MAX_DAMAGE);
    
    return Math.floor(damage);
  }

  /**
   * Calculate experience gained from combat
   */
  private calculateExperienceGain(enemy: NPC, wasDefeated: boolean): number {
    const baseExp = enemy.stats.maxHp + enemy.stats.attack + enemy.stats.defense;
    const multiplier = wasDefeated ? 1.0 : 0.1; // Full XP for defeat, small amount for damage
    return Math.floor(baseExp * multiplier);
  }

  /**
   * Check if player should level up and apply level benefits
   */
  private checkLevelUp(player: Player): { levelUp: boolean; newLevel?: number } {
    const requiredExp = COMBAT_CONSTANTS.EXPERIENCE_PER_LEVEL * Math.pow(COMBAT_CONSTANTS.LEVEL_SCALING_FACTOR, player.level - 1);
    
    if (player.experience >= requiredExp) {
      const oldLevel = player.level;
      player.level++;
      player.experience -= requiredExp;
      
      // Apply level up benefits
      this.applyLevelUpBenefits(player);
      
      return { levelUp: true, newLevel: player.level };
    }
    
    return { levelUp: false };
  }

  /**
   * Apply stat increases when player levels up
   */
  private applyLevelUpBenefits(player: Player): void {
    const statIncrease = Math.floor(2 + player.level * 0.5);
    
    player.stats.attack += statIncrease;
    player.stats.defense += statIncrease;
    player.stats.maxHp += statIncrease * 5;
    player.stats.hp = Math.min(player.stats.hp + statIncrease * 5, player.stats.maxHp);
    player.stats.speed += Math.floor(statIncrease * 0.5);
  }

  /**
   * Generate loot drops from defeated enemies
   */
  private generateLoot(defeated: NPC): Item[] {
    const loot: Item[] = [];
    
    // Base drop chance
    if (Math.random() < 0.15) { // 15% drop chance
      const itemTypes = ['weapon', 'armor', 'consumable'] as const;
      const rarities = ['common', 'uncommon', 'rare'] as const;
      
      const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
      const rarity = rarities[Math.floor(Math.random() * rarities.length)];
      
      const item: Item = {
        id: `loot_${defeated.id}_${Date.now()}`,
        name: this.generateItemName(itemType as string, rarity as string),
        type: itemType as ItemType,
        rarity: rarity as ItemRarity,
        description: `A ${rarity} ${itemType} dropped by ${defeated.name}`,
        position: { ...defeated.position },
        stats: this.generateItemStats(itemType as string, rarity as string),
        isHidden: true,
        revealDuration: GAME_CONFIG.itemRevealTimes[rarity as ItemRarity],
        revealProgress: 0.0,
        canBeLooted: false
      };
      
      loot.push(item);
    }
    
    return loot;
  }

  /**
   * Generate a random item name
   */
  private generateItemName(type: string, rarity: string): string {
    const prefixes: Record<string, string[]> = {
      common: ['Basic', 'Simple', 'Plain'],
      uncommon: ['Good', 'Quality', 'Enhanced'],
      rare: ['Superior', 'Excellent', 'Masterwork']
    };
    
    const typeNames: Record<string, string[]> = {
      weapon: ['Sword', 'Dagger', 'Axe', 'Staff', 'Bow'],
      armor: ['Shield', 'Helmet', 'Armor', 'Boots', 'Gloves'],
      consumable: ['Potion', 'Elixir', 'Scroll', 'Herb']
    };
    
    const prefix = prefixes[rarity]?.[Math.floor(Math.random() * prefixes[rarity].length)] || 'Basic';
    const typeName = typeNames[type]?.[Math.floor(Math.random() * typeNames[type].length)] || 'Item';
    
    return `${prefix} ${typeName}`;
  }

  /**
   * Generate item stats based on type and rarity
   */
  private generateItemStats(type: string, rarity: string): any {
    const rarityMultipliers: Record<string, number> = {
      common: 1,
      uncommon: 1.5,
      rare: 2.5
    };
    
    const multiplier = rarityMultipliers[rarity] ?? 1;
    
    switch (type) {
      case 'weapon':
        return { attack: Math.floor(5 * multiplier) };
      case 'armor':
        return { defense: Math.floor(3 * multiplier) };
      case 'consumable':
        return { hp: Math.floor(20 * multiplier) };
      default:
        return {};
    }
  }

  /**
   * Check if two positions are adjacent (including diagonals)
   */
  private areAdjacent(pos1: Position, pos2: Position): boolean {
    const dx = Math.abs(pos1.x - pos2.x);
    const dy = Math.abs(pos1.y - pos2.y);
    return dx <= 1 && dy <= 1 && (dx + dy > 0);
  }

  /**
   * Get the enemy NPC at a specific position
   */
  public getEnemyAtPosition(npcs: NPC[], position: Position): NPC | null {
    return npcs.find(npc => 
      npc.isAlive && 
      npc.position.x === position.x && 
      npc.position.y === position.y
    ) || null;
  }
}
</file>

<file path="packages/backend/src/services/GameWorldManager.ts">
import { GameWorld, Player, NPC, Item, Building, BiomeType, Position, GAME_CONFIG, DEFAULT_WORLD_CONFIG } from '@chatterealm/shared';
import { NPCManager } from './NPCManager';

export class GameWorldManager {
  private npcManager: NPCManager;

  constructor(npcManager: NPCManager) {
    this.npcManager = npcManager;
  }

  /**
   * Initialize a new game world
   */
  public initializeGameWorld(options?: { generateNPCs?: boolean; worldType?: 'test' | 'default' }): GameWorld {
    const grid: any[][] = [];
    const worldType = options?.worldType || 'default';

    // Initialize terrain grid
    for (let y = 0; y < GAME_CONFIG.gridHeight; y++) {
      grid[y] = [];
      for (let x = 0; x < GAME_CONFIG.gridWidth; x++) {
        const terrainType = worldType === 'test' ? BiomeType.PLAIN : this.generateBiomeType();
        const config = GAME_CONFIG.terrainConfig[terrainType];
        
        grid[y][x] = {
          type: terrainType,
          position: { x, y },
          movementCost: config.movementCost,
          defenseBonus: config.defenseBonus,
          visibilityModifier: config.visibilityModifier
        };
      }
    }

    // Generate initial NPCs
    const npcs = (options?.generateNPCs ?? true)
        ? this.npcManager.generateNPCs(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight, grid)
        : [];

    // Create the game world
    const gameWorld: GameWorld = {
      id: `world_${Date.now()}`,
      grid,
      players: [],
      npcs,
      items: [],
      buildings: [],
      cataclysmCircle: {
        center: { 
          x: Math.floor(GAME_CONFIG.gridWidth / 2), 
          y: Math.floor(GAME_CONFIG.gridHeight / 2) 
        },
        radius: Math.max(GAME_CONFIG.gridWidth, GAME_CONFIG.gridHeight),
        isActive: false,
        shrinkRate: 1,
        nextShrinkTime: 0
      },
      cataclysmRoughnessMultiplier: 1.0,
      worldAge: 0,
      lastResetTime: Date.now(),
      phase: 'exploration'
    };

    return gameWorld;
  }

  /**
   * Generate terrain type based on spawn chances
   */
  private generateBiomeType(): BiomeType {
    const rand = Math.random();
    let cumulative = 0;
    
    for (const [terrainType, config] of Object.entries(GAME_CONFIG.terrainConfig)) {
      cumulative += config.spawnChance;
      if (rand <= cumulative) {
        return terrainType as BiomeType;
      }
    }
    
    return BiomeType.PLAIN;
  }

  /**
   * Add a player to the game world
   */
  public addPlayer(gameWorld: GameWorld, player: Player, occupiedPositions: Set<string>, availableSpawnPoints: Set<string>): boolean {
    // Check if player already exists
    if (gameWorld.players.find(p => p.id === player.id)) {
      return false;
    }

    // Use player's position if valid, otherwise find a new spawn point
    let spawnPosition: Position | null = player.position;
    if (!spawnPosition || !this.isValidSpawnPosition(spawnPosition.x, spawnPosition.y, gameWorld.grid, occupiedPositions)) {
        spawnPosition = this.findEmptySpawnPosition(gameWorld.grid, occupiedPositions);
    }

    if (!spawnPosition) {
        return false; // Could not find a valid spawn position
    }

    // Set player position
    player.position = spawnPosition;
    player.isAlive = true;
    player.spawnTime = Date.now();

    // Add to game world
    gameWorld.players.push(player);

    // Update position tracking
    const posKey = `${spawnPosition.x},${spawnPosition.y}`;
    occupiedPositions.add(posKey);
    availableSpawnPoints.delete(posKey);

    return true;
  }

  /**
   * Remove a player from the game world
   */
  public removePlayer(gameWorld: GameWorld, playerId: string, occupiedPositions: Set<string>, availableSpawnPoints: Set<string>): Player | null {
    const playerIndex = gameWorld.players.findIndex(p => p.id === playerId);
    if (playerIndex === -1) {
      return null;
    }

    const player = gameWorld.players[playerIndex];
    
    // Update position tracking
    const posKey = `${player.position.x},${player.position.y}`;
    occupiedPositions.delete(posKey);
    availableSpawnPoints.add(posKey);

    // Remove from game world
    gameWorld.players.splice(playerIndex, 1);

    return player;
  }

  /**
   * Find an empty spawn position
   */
  private findEmptySpawnPosition(grid: any[][], occupiedPositions: Set<string>): Position | null {
    let attempts = 0;
    const maxAttempts = 100;

    while (attempts < maxAttempts) {
      const x = Math.floor(Math.random() * grid[0].length);
      const y = Math.floor(Math.random() * grid.length);

      if (this.isValidSpawnPosition(x, y, grid, occupiedPositions)) {
        return { x, y };
      }
      attempts++;
    }

    return null;
  }

  /**
   * Validate if a spawn position is valid
   */
  private isValidSpawnPosition(x: number, y: number, grid: any[][], occupiedPositions: Set<string>): boolean {
    // Check bounds
    if (x < 0 || x >= grid[0].length || y < 0 || y >= grid.length) {
      return false;
    }

    // Check if position is already occupied
    if (occupiedPositions.has(`${x},${y}`)) {
      return false;
    }

    // Check terrain
    const terrain = grid[y][x];
    if (terrain.type === BiomeType.MOUNTAIN) {
      return false;
    }

    // Check for adjacent mountains (avoid spawning surrounded by mountains)
    let adjacentMountains = 0;
    const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
    
    for (const [dx, dy] of directions) {
      const checkX = x + dx;
      const checkY = y + dy;
      
      if (checkX >= 0 && checkX < grid[0].length && checkY >= 0 && checkY < grid.length) {
        if (grid[checkY][checkX].type === BiomeType.MOUNTAIN) {
          adjacentMountains++;
        }
      }
    }

    return adjacentMountains <= 2; // Don't spawn if surrounded by too many mountains
  }

  /**
   * Add an item to the game world
   */
  public addItem(gameWorld: GameWorld, item: Item): void {
    gameWorld.items.push(item);
  }

  /**
   * Remove an item from the game world
   */
  public removeItem(gameWorld: GameWorld, itemId: string): boolean {
    const itemIndex = gameWorld.items.findIndex(item => item.id === itemId);
    if (itemIndex === -1) {
      return false;
    }

    gameWorld.items.splice(itemIndex, 1);
    return true;
  }

  /**
   * Add a building to the game world
   */
  public addBuilding(gameWorld: GameWorld, building: Building): void {
    gameWorld.buildings.push(building);
  }

  /**
   * Get terrain at specific position
   */
  public getTerrainAt(gameWorld: GameWorld, position: Position): any | null {
    if (position.x < 0 || position.x >= gameWorld.grid[0]?.length || 
        position.y < 0 || position.y >= gameWorld.grid.length) {
      return null;
    }

    return gameWorld.grid[position.y][position.x];
  }

  /**
   * Update world age
   */
  public updateWorldAge(gameWorld: GameWorld): void {
    gameWorld.worldAge = Date.now() - gameWorld.lastResetTime;
  }

  /**
   * Get world statistics
   */
  public getWorldStats(gameWorld: GameWorld): {
    totalPlayers: number;
    alivePlayers: number;
    totalNPCs: number;
    aliveNPCs: number;
    totalItems: number;
    totalBuildings: number;
    worldAge: number;
    phase: string;
  } {
    return {
      totalPlayers: gameWorld.players.length,
      alivePlayers: gameWorld.players.filter(p => p.isAlive).length,
      totalNPCs: gameWorld.npcs.length,
      aliveNPCs: gameWorld.npcs.filter(npc => npc.isAlive).length,
      totalItems: gameWorld.items.length,
      totalBuildings: gameWorld.buildings.length,
      worldAge: gameWorld.worldAge,
      phase: gameWorld.phase
    };
  }

  /**
   * Analyze terrain distribution for debugging
   */
  public analyzeTerrainDistribution(gameWorld: GameWorld): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    for (let y = 0; y < gameWorld.grid.length; y++) {
      for (let x = 0; x < gameWorld.grid[y].length; x++) {
        const terrainType = gameWorld.grid[y][x].type;
        distribution[terrainType] = (distribution[terrainType] || 0) + 1;
      }
    }
    
    return distribution;
  }

  /**
   * Get all players at a specific position
   */
  public getPlayersAtPosition(gameWorld: GameWorld, position: Position): Player[] {
    return gameWorld.players.filter(player => 
      player.position.x === position.x && 
      player.position.y === position.y
    );
  }

  /**
   * Get all NPCs at a specific position
   */
  public getNPCsAtPosition(gameWorld: GameWorld, position: Position): NPC[] {
    return gameWorld.npcs.filter(npc => 
      npc.position.x === position.x && 
      npc.position.y === position.y &&
      npc.isAlive
    );
  }

  /**
   * Get all items at a specific position
   */
  public getItemsAtPosition(gameWorld: GameWorld, position: Position): Item[] {
    return gameWorld.items.filter(item => 
      item.position && 
      item.position.x === position.x && 
      item.position.y === position.y
    );
  }

  /**
   * Check if a position is within world bounds
   */
  public isWithinBounds(gameWorld: GameWorld, position: Position): boolean {
    return position.x >= 0 && 
           position.x < gameWorld.grid[0]?.length && 
           position.y >= 0 && 
           position.y < gameWorld.grid.length;
  }

  /**
   * Get adjacent positions to a given position
   */
  public getAdjacentPositions(position: Position): Position[] {
    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];

    return directions.map(([dx, dy]) => ({
      x: position.x + dx,
      y: position.y + dy
    }));
  }

  /**
   * Calculate distance between two positions
   */
  public getDistance(pos1: Position, pos2: Position): number {
    return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
  }

  /**
   * Get Manhattan distance between two positions
   */
  public getManhattanDistance(pos1: Position, pos2: Position): number {
    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
  }

  /**
   * Check if two positions are adjacent (including diagonals)
   */
  public areAdjacent(pos1: Position, pos2: Position): boolean {
    const dx = Math.abs(pos1.x - pos2.x);
    const dy = Math.abs(pos1.y - pos2.y);
    return dx <= 1 && dy <= 1 && (dx + dy > 0);
  }

  /**
   * Get all positions within a radius from a center point
   */
  public getPositionsInRadius(center: Position, radius: number): Position[] {
    const positions: Position[] = [];
    
    for (let x = center.x - radius; x <= center.x + radius; x++) {
      for (let y = center.y - radius; y <= center.y + radius; y++) {
        const distance = this.getDistance(center, { x, y });
        if (distance <= radius) {
          positions.push({ x, y });
        }
      }
    }
    
    return positions;
  }

  /**
   * Validate game world integrity
   */
  public validateWorld(gameWorld: GameWorld): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check grid integrity
    if (!gameWorld.grid || gameWorld.grid.length === 0) {
      errors.push('Grid is empty or invalid');
    }

    // Check players have valid positions
    gameWorld.players.forEach(player => {
      if (!this.isWithinBounds(gameWorld, player.position)) {
        errors.push(`Player ${player.id} has invalid position`);
      }
    });

    // Check NPCs have valid positions
    gameWorld.npcs.forEach(npc => {
      if (!this.isWithinBounds(gameWorld, npc.position)) {
        errors.push(`NPC ${npc.id} has invalid position`);
      }
    });

    // Check items have valid positions (if positioned)
    gameWorld.items.forEach(item => {
      if (item.position && !this.isWithinBounds(gameWorld, item.position)) {
        errors.push(`Item ${item.id} has invalid position`);
      }
    });

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
</file>

<file path="packages/backend/src/services/geminiClient.ts">
import { GoogleGenAI } from '@google/genai';

class GeminiClient {
  private static instance: GoogleGenAI;

  private constructor() {}

  public static getInstance(): GoogleGenAI {
    if (!GeminiClient.instance) {
      if (!process.env.GEMINI_API_KEY) {
        throw new Error('GEMINI_API_KEY is not set');
      }
      GeminiClient.instance = new GoogleGenAI({apiKey: process.env.GEMINI_API_KEY});
    }
    return GeminiClient.instance;
  }
}

export default GeminiClient;
</file>

<file path="packages/backend/src/services/LootManager.ts">
import { Item, ItemType, ItemRarity, Position, BiomeType, Player, NPC, GAME_CONFIG } from '@chatterealm/shared';

export interface ItemResult {
  success: boolean;
  message: string;
  item?: Item;
}

export class LootManager {
  /**
   * Generate terrain-based loot with enhanced properties
   */
  public generateTerrainBasedLoot(position: Position, terrainType: BiomeType, isCataclysmLoot: boolean = false): Item | null {
    const rarityChances: Record<string, number> = isCataclysmLoot ? 
      { common: 30, uncommon: 35, rare: 25, epic: 8, legendary: 2 } : // Enhanced for cataclysm
      { common: 60, uncommon: 30, rare: 9, epic: 1 }; // Normal terrain loot

    const itemTypes = [ItemType.WEAPON, ItemType.ARMOR, ItemType.CONSUMABLE];
    const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
    const rarity = this.selectItemRarity(rarityChances);

    const item: Item = {
      id: `terrain_loot_${position.x}_${position.y}_${Date.now()}_${Math.random()}`,
      name: this.generateEnhancedItemName(itemType, rarity, terrainType),
      type: itemType,
      rarity,
      description: this.generateTerrainItemDescription(itemType, rarity, terrainType),
      position: { ...position },
      stats: this.generateEnhancedItemStats(itemType, rarity, terrainType, isCataclysmLoot),
      isHidden: true,
      revealStartTime: Date.now(),
      revealDuration: GAME_CONFIG.itemRevealTimes[rarity],
      revealProgress: 0.0,
      canBeLooted: false
    };

    return item;
  }

  /**
   * Generate enhanced item name with terrain context
   */
  private generateEnhancedItemName(type: ItemType, rarity: ItemRarity, terrainType: BiomeType): string {
    const terrainModifiers: Record<BiomeType, string[]> = {
      [BiomeType.ANCIENT_RUINS]: ['Ancient', 'Ruined', 'Lost', 'Forgotten'],
      [BiomeType.FOREST]: ['Wooden', 'Natural', 'Forest', 'Wild'],
      [BiomeType.MOUNTAIN]: ['Stone', 'Mountain', 'Rocky', 'Dwarven'],
      [BiomeType.SWAMP]: ['Murky', 'Bog', 'Swamp', 'Poisonous'],
      [BiomeType.ICE]: ['Frozen', 'Ice', 'Crystal', 'Arctic'],
      [BiomeType.SNOW]: ['Snow-touched', 'Frigid', 'Winter', 'Frost'],
      [BiomeType.SAND]: ['Desert', 'Sand-worn', 'Nomad', 'Sun-bleached'],
      [BiomeType.DEEP_WATER]: ['Sunken', 'Waterlogged', 'Coral', 'Deep'],
      [BiomeType.RIVER]: ['River-blessed', 'Flowing', 'Current-touched', 'Stream']
    } as Record<BiomeType, string[]>;

    const rarityPrefixes: Record<ItemRarity, string[]> = {
      [ItemRarity.COMMON]: ['Worn', 'Simple', 'Basic', 'Crude'],
      [ItemRarity.UNCOMMON]: ['Quality', 'Fine', 'Enhanced', 'Polished'],
      [ItemRarity.RARE]: ['Superior', 'Excellent', 'Masterwork', 'Pristine'],
      [ItemRarity.EPIC]: ['Legendary', 'Mythical', 'Ancient', 'Heroic'],
      [ItemRarity.LEGENDARY]: ['Divine', 'Immortal', 'Godly', 'Eternal']
    };

    const typeNames: Partial<Record<ItemType, string[]>> = {
      [ItemType.WEAPON]: ['Blade', 'Sword', 'Axe', 'Staff', 'Bow', 'Dagger', 'Mace'],
      [ItemType.ARMOR]: ['Shield', 'Helm', 'Armor', 'Boots', 'Gauntlets', 'Cloak'],
      [ItemType.CONSUMABLE]: ['Potion', 'Elixir', 'Herb', 'Essence', 'Extract', 'Tonic']
    };

    const terrainMods = terrainModifiers[terrainType] || ['Mysterious'];
    const terrainMod = terrainMods[Math.floor(Math.random() * terrainMods.length)];
    const rarityPrefix = rarityPrefixes[rarity][Math.floor(Math.random() * rarityPrefixes[rarity].length)];
    const typeNamesList = typeNames[type] || ['Item'];
    const typeName = typeNamesList[Math.floor(Math.random() * typeNamesList.length)];

    return `${rarityPrefix} ${terrainMod} ${typeName}`;
  }

  /**
   * Generate terrain-specific item descriptions
   */
  private generateTerrainItemDescription(type: ItemType, rarity: ItemRarity, terrainType: BiomeType): string {
    const terrainContext: Record<BiomeType, string> = {
      [BiomeType.ANCIENT_RUINS]: 'discovered among ancient ruins',
      [BiomeType.FOREST]: 'found deep in the forest',
      [BiomeType.MOUNTAIN]: 'carved from mountain stone',
      [BiomeType.SWAMP]: 'recovered from murky swamplands',
      [BiomeType.ICE]: 'preserved in eternal ice',
      [BiomeType.SAND]: 'buried in desert sands'
    } as Record<BiomeType, string>;

    const context = terrainContext[terrainType] || 'found in the wilderness';
    return `A ${rarity} ${type} ${context}.`;
  }

  /**
   * Generate enhanced item stats with terrain and cataclysm bonuses
   */
  private generateEnhancedItemStats(type: ItemType, rarity: ItemRarity, terrainType: BiomeType, isCataclysmLoot: boolean): any {
    const rarityMultipliers: Record<ItemRarity, number> = {
      [ItemRarity.COMMON]: 1,
      [ItemRarity.UNCOMMON]: 1.5,
      [ItemRarity.RARE]: 2.5,
      [ItemRarity.EPIC]: 4,
      [ItemRarity.LEGENDARY]: 6
    };

    let multiplier = rarityMultipliers[rarity];
    
    // Terrain bonuses
    const terrainBonuses: Record<BiomeType, number> = {
      [BiomeType.ANCIENT_RUINS]: 1.3,
      [BiomeType.MOUNTAIN]: 1.1,
      [BiomeType.MOUNTAIN_PEAK]: 1.2
    } as Record<BiomeType, number>;

    multiplier *= (terrainBonuses[terrainType] || 1.0);
    
    // Cataclysm bonus
    if (isCataclysmLoot) {
      multiplier *= 1.25;
    }

    switch (type) {
      case ItemType.WEAPON:
        return { attack: Math.floor(5 * multiplier + Math.random() * 3) };
      case ItemType.ARMOR:
        return { defense: Math.floor(3 * multiplier + Math.random() * 2) };
      case ItemType.CONSUMABLE:
        return { hp: Math.floor(20 * multiplier + Math.random() * 10) };
      default:
        return {};
    }
  }

  /**
   * Select item rarity based on weighted chances
   */
  private selectItemRarity(rarityWeights: Record<string, number>): ItemRarity {
    const totalWeight = Object.values(rarityWeights).reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const [rarity, weight] of Object.entries(rarityWeights)) {
      random -= weight;
      if (random <= 0) {
        return rarity as ItemRarity;
      }
    }
    
    return ItemRarity.COMMON;
  }

  /**
   * Generate basic loot from defeated NPCs
   */
  public generateLoot(defeated: NPC): Item[] {
    const loot: Item[] = [];
    
    if (Math.random() < 0.15) { // 15% drop chance
      const itemTypes = ['weapon', 'armor', 'consumable'] as const;
      const rarities = ['common', 'uncommon', 'rare'] as const;
      const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
      const rarity = rarities[Math.floor(Math.random() * rarities.length)];
      
      const item: Item = {
        id: `loot_${defeated.id}_${Date.now()}`,
        name: this.generateItemName(itemType as string, rarity as string),
        type: itemType as ItemType,
        rarity: rarity as ItemRarity,
        description: `A ${rarity} ${itemType} dropped by ${defeated.name}`,
        position: { ...defeated.position },
        stats: this.generateItemStats(itemType as string, rarity as string),
        isHidden: true,
        revealStartTime: Date.now(),
        revealDuration: GAME_CONFIG.itemRevealTimes[rarity as ItemRarity],
        revealProgress: 0.0,
        canBeLooted: false
      };
      
      loot.push(item);
    }
    
    return loot;
  }

  /**
   * Generate basic item name
   */
  private generateItemName(type: string, rarity: string): string {
    const prefixes: Record<string, string[]> = {
      common: ['Basic', 'Simple', 'Plain'],
      uncommon: ['Good', 'Quality', 'Enhanced'],
      rare: ['Superior', 'Excellent', 'Masterwork']
    };
    
    const typeNames: Record<string, string[]> = {
      weapon: ['Sword', 'Dagger', 'Axe', 'Staff', 'Bow'],
      armor: ['Shield', 'Helmet', 'Armor', 'Boots', 'Gloves'],
      consumable: ['Potion', 'Elixir', 'Scroll', 'Herb']
    };
    
    const prefix = prefixes[rarity]?.[Math.floor(Math.random() * prefixes[rarity].length)] || 'Basic';
    const typeName = typeNames[type]?.[Math.floor(Math.random() * typeNames[type].length)] || 'Item';
    
    return `${prefix} ${typeName}`;
  }

  /**
   * Generate basic item stats
   */
  private generateItemStats(type: string, rarity: string): any {
    const rarityMultipliers: Record<string, number> = {
      common: 1,
      uncommon: 1.5,
      rare: 2.5
    };
    
    const multiplier = rarityMultipliers[rarity] ?? 1;
    
    switch (type) {
      case 'weapon':
        return { attack: Math.floor(5 * multiplier) };
      case 'armor':
        return { defense: Math.floor(3 * multiplier) };
      case 'consumable':
        return { hp: Math.floor(20 * multiplier) };
      default:
        return {};
    }
  }

  /**
   * Process item pickup
   */
  public pickupItem(playerId: string, itemId: string, items: Item[], players: Player[]): ItemResult {
    const player = players.find(p => p.id === playerId);
    if (!player) {
      return { success: false, message: 'Player not found.' };
    }

    if (!player.isAlive) {
      return { success: false, message: 'Cannot pick up items while defeated.' };
    }

    const itemIndex = items.findIndex(item => item.id === itemId);
    if (itemIndex === -1) {
      return { success: false, message: 'Item not found.' };
    }

    const item = items[itemIndex];
    
    // Check if item is within pickup range
    if (!item.position || !this.isWithinPickupRange(player.position, item.position)) {
      return { success: false, message: 'Item is too far away.' };
    }

    // Check if item can be looted
    if (!item.canBeLooted) {
      return { success: false, message: 'Item is not ready to be picked up yet.' };
    }

    // Add to player inventory
    player.inventory.push(item);
    item.ownerId = player.id;
    item.position = undefined;
    
    // Remove from world items
    items.splice(itemIndex, 1);

    return {
      success: true,
      message: `Picked up ${item.name}!`,
      item
    };
  }

  /**
   * Process item inspection
   */
  public inspectItem(playerId: string, itemId: string, items: Item[], players: Player[]): ItemResult {
    const player = players.find(p => p.id === playerId);
    if (!player) {
      return { success: false, message: 'Player not found.' };
    }

    const item = items.find(item => item.id === itemId);
    if (!item) {
      return { success: false, message: 'Item not found.' };
    }

    // Check if item is within inspection range
    if (!item.position || !this.isWithinPickupRange(player.position, item.position)) {
      return { success: false, message: 'Item is too far away to inspect.' };
    }

    // Reveal the item if it's hidden
    if (item.isHidden) {
      item.isHidden = false;
      item.revealProgress = 0.0;
    }

    return {
      success: true,
      message: `Inspecting ${item.name}: ${item.description}`,
      item
    };
  }

  /**
   * Process Tarkov-style item looting
   */
  public lootItem(playerId: string, itemId: string, items: Item[], players: Player[]): ItemResult {
    const player = players.find(p => p.id === playerId);
    if (!player) {
      return { success: false, message: 'Player not found.' };
    }

    if (!player.isAlive) {
      return { success: false, message: 'Cannot loot items while defeated.' };
    }

    const itemIndex = items.findIndex(item => item.id === itemId);
    if (itemIndex === -1) {
      return { success: false, message: 'Item not found.' };
    }

    const item = items[itemIndex];
    
    // Check if item is within loot range
    if (!item.position || !this.isWithinPickupRange(player.position, item.position)) {
      return { success: false, message: 'Item is too far away.' };
    }

    // Check if item is ready to be looted
    if (item.revealProgress < 1.0) {
      return { success: false, message: 'Item is still being revealed. Wait for the process to complete.' };
    }

    if (!item.canBeLooted) {
      return { success: false, message: 'Item cannot be looted yet.' };
    }

    // Add to player inventory
    player.inventory.push(item);
    item.ownerId = player.id;
    item.position = undefined;
    
    // Remove from world items
    items.splice(itemIndex, 1);

    return {
      success: true,
      message: `Successfully looted ${item.name}!`,
      item
    };
  }

  /**
   * Update item reveal progress for Tarkov-style looting
   */
  public updateItemReveals(items: Item[]): void {
    const now = Date.now();
    
    items.forEach(item => {
      if (item.isHidden && item.revealProgress < 1.0) {
        const elapsedTime = now - (item.revealStartTime || now);
        item.revealProgress = Math.min(1.0, elapsedTime / item.revealDuration);
        
        if (item.revealProgress >= 1.0) {
          item.canBeLooted = true;
        }
      }
    });
  }

  /**
   * Check if position is within pickup/loot range
   */
  private isWithinPickupRange(playerPos: Position, itemPos: Position): boolean {
    const distance = Math.max(Math.abs(playerPos.x - itemPos.x), Math.abs(playerPos.y - itemPos.y));
    return distance <= GAME_CONFIG.lootInteractionRadius;
  }

  /**
   * Use/consume an item from player inventory
   */
  public useItem(playerId: string, itemId: string, players: Player[]): ItemResult {
    const player = players.find(p => p.id === playerId);
    if (!player) {
      return { success: false, message: 'Player not found.' };
    }

    if (!player.isAlive) {
      return { success: false, message: 'Cannot use items while defeated.' };
    }

    const itemIndex = player.inventory.findIndex(item => item.id === itemId);
    if (itemIndex === -1) {
      return { success: false, message: 'Item not found in inventory.' };
    }

    const item = player.inventory[itemIndex];
    
    // Only consumable items can be used
    if (item.type !== ItemType.CONSUMABLE) {
      return { success: false, message: 'This item cannot be consumed.' };
    }

    // Apply item effects
    if (item.stats?.hp) {
      const healAmount = item.stats.hp;
      const oldHp = player.stats.hp;
      player.stats.hp = Math.min(player.stats.maxHp, player.stats.hp + healAmount);
      const actualHeal = player.stats.hp - oldHp;
      
      // Remove item from inventory
      player.inventory.splice(itemIndex, 1);
      
      return {
        success: true,
        message: `Used ${item.name} and restored ${actualHeal} HP.`,
        item
      };
    }

    return { success: false, message: 'Item has no usable effects.' };
  }
}
</file>

<file path="packages/backend/src/services/RateLimiter.ts">
import { RateLimiterOptions } from '@chatterealm/shared';

const DEFAULT_OPTIONS: Required<RateLimiterOptions> = {
  maxEvents: 10, // Max events per window
  windowMs: 1000, // 1 second
};

/**
 * A simple in-memory rate limiter for Socket.IO events.
 */
export class RateLimiter {
  private clients: Map<string, number[]> = new Map();
  private options: Required<RateLimiterOptions>;

  constructor(options: RateLimiterOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  /**
   * Checks if a client is rate-limited.
   * @param socketId The ID of the socket to check.
   * @returns True if the client has exceeded the rate limit, false otherwise.
   */
  public isRateLimited(socketId: string): boolean {
    const now = Date.now();
    const windowStart = now - this.options.windowMs;

    // Get the client's event timestamps, or initialize if not present
    const clientTimestamps = this.clients.get(socketId) || [];

    // Filter out timestamps that are outside the current window
    const recentTimestamps = clientTimestamps.filter(ts => ts > windowStart);

    // If the number of recent events exceeds the max, the client is rate-limited
    if (recentTimestamps.length >= this.options.maxEvents) {
      return true;
    }

    // Add the current timestamp and update the client's record
    recentTimestamps.push(now);
    this.clients.set(socketId, recentTimestamps);

    return false;
  }

  /**
   * Cleans up the timestamp records for a disconnected client.
   * @param socketId The ID of the socket to clean up.
   */
  public cleanup(socketId: string): void {
    this.clients.delete(socketId);
  }
}
</file>

<file path="packages/backend/src/testUtils/mockGameWorld.ts">
import { GameWorld, BiomeType, PlayerClass, Player, GAME_CONFIG } from '@chatterealm/shared';

export const createMockGameWorld = (gridWidth: number, gridHeight: number): GameWorld => {
  const grid: BiomeType[][] = [];
  for (let y = 0; y < gridHeight; y++) {
    grid[y] = [];
    for (let x = 0; x < gridWidth; x++) {
      grid[y][x] = BiomeType.PLAIN;
    }
  }

  return {
    id: 'mock_world',
    grid: grid.map((row, y) => row.map((type, x) => ({
      type,
      position: { x, y },
      movementCost: 1,
      defenseBonus: 0,
      visibilityModifier: 1,
    }))),
    players: [],
    npcs: [],
    items: [],
    buildings: [], // Mock buildings array
    cataclysmCircle: {
      center: { x: Math.floor(gridWidth / 2), y: Math.floor(gridHeight / 2) },
      radius: Math.max(gridWidth, gridHeight),
      isActive: false,
      shrinkRate: 1,
      nextShrinkTime: 0,
    },
    cataclysmRoughnessMultiplier: 1.0,
    worldAge: 0,
    lastResetTime: Date.now(),
    phase: 'exploration',
  };
};

export const createMockPlayer = (id: string, displayName: string, position: { x: number, y: number } = { x: 0, y: 0 }): Player => ({
  id,
  displayName,
  twitchUsername: `twitch_${id}`,
  avatar: 'ðŸ‘¤',
  position,
  class: PlayerClass.KNIGHT,
  health: 100,
  mana: 100,
  stamina: 100,
  hunger: 100,
  thirst: 100,
  stats: {
    hp: 100,
    maxHp: 100,
    attack: 10,
    defense: 5,
    speed: 5,
  },
  level: 1,
  experience: 0,
  inventory: [],
  equipment: {},
  achievements: [],
  titles: [],
  isAlive: true,
  lastMoveTime: 0,
  spawnTime: Date.now(),
  connected: true,
  lastActive: Date.now(),
});

export const createMockNpc = (id: string, name: string, position: { x: number, y: number } = { x: 0, y: 0 }): any => ({
    id,
    name,
    position,
    stats: {
        hp: 50,
        maxHp: 50,
        attack: 5,
        defense: 2,
        speed: 3,
    },
    isAlive: true,
});
</file>

<file path="packages/backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "@chatterealm/shared": ["../shared/src"],
      "@chatterealm/shared/*": ["../shared/src/*"]
    }
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "**/*.old.ts"]
}
</file>

<file path="packages/frontend/src/ai/Time.ts">
// packages/frontend/src/ai/Time.ts

export class Time {
  private static instance: Time;
  private lastTime: number;
  private delta: number;
  public scale: number;

  private constructor() {
    this.lastTime = performance.now();
    this.delta = 0;
    this.scale = 1;
  }

  static getInstance(): Time {
    if (!Time.instance) {
      Time.instance = new Time();
    }
    return Time.instance;
  }

  update(): void {
    const now = performance.now();
    this.delta = (now - this.lastTime) / 1000;
    this.lastTime = now;
  }

  getDelta(): number {
    return this.delta * this.scale;
  }
}
</file>

<file path="packages/frontend/src/components/chat/SmartSuggestions.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { debounce } from 'lodash';

interface SmartSuggestionsProps {
  currentInput: string;
  gameContext: {
    recentMessages: string[];
    activeQuests: string[];
    nearbyPlayers: string[];
    currentActivity: string;
  };
  onSelectSuggestion: (suggestion: string) => void;
}

const SmartSuggestions: React.FC<SmartSuggestionsProps> = ({
  currentInput,
  gameContext,
  onSelectSuggestion
}) => {
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);

  const generateSuggestions = useCallback(
    debounce(async (input: string) => {
      if (input.length < 2) {
        setSuggestions([]);
        return;
      }

      setLoading(true);

      try {
        const prompt = `Generate 3 chat message completions for a multiplayer game.

Current input: "${input}"
Game context:
- Recent messages: ${gameContext.recentMessages.slice(-3).join('; ')}
- Active quests: ${gameContext.activeQuests.join(', ')}
- Nearby players: ${gameContext.nearbyPlayers.join(', ')}
- Current activity: ${gameContext.currentActivity}

Suggestions should:
1. Complete or enhance the current input
2. Be contextually relevant to the game state
3. Be concise (max 100 characters)
4. Use appropriate gaming terminology
5. Include common actions like coordinating, greeting, asking for help

Return only the 3 suggestions as a JSON array of strings.`;

        const response = await fetch('/api/ai-proxy', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'gemini-pro',
            contents: [{ role: 'user', parts: [{ text: prompt }] }],
            config: {
              responseMimeType: 'application/json',
              responseSchema: {
                type: 'object',
                properties: {
                  suggestions: {
                    type: 'array',
                    items: { type: 'string' },
                    minItems: 3,
                    maxItems: 3,
                  },
                },
                required: ['suggestions'],
              },
              temperature: 0.8,
              maxOutputTokens: 200,
            },
          }),
        });

        const parsed = await response.json();
        setSuggestions(parsed.suggestions);
      } catch (error) {
        console.error('Failed to generate suggestions:', error);
        setSuggestions([]);
      } finally {
        setLoading(false);
      }
    }, 500),
    [gameContext]
  );

  useEffect(() => {
    generateSuggestions(currentInput);
  }, [currentInput, generateSuggestions]);

  if (suggestions.length === 0 && !loading) return null;

  return (
    <div className="absolute bottom-full left-0 right-0 mb-2 bg-gray-800 rounded-lg shadow-xl border border-gray-700">
      {loading ? (
        <div className="p-3 text-gray-400 text-sm">Generating suggestions...</div>
      ) : (
        suggestions.map((suggestion, index) => (
          <button
            key={index}
            onClick={() => onSelectSuggestion(suggestion)}
            className="w-full px-4 py-2 text-left text-sm text-gray-200 hover:bg-gray-700 transition-colors first:rounded-t-lg last:rounded-b-lg"
          >
            <span className="text-blue-400 mr-2">Tab {index + 1}:</span>
            {suggestion}
          </button>
        ))
      )}
    </div>
  );
};

export default SmartSuggestions;
</file>

<file path="packages/frontend/src/components/layout/BaseLayout.tsx">
import React, { useEffect } from 'react';
import AppHeader from './AppHeader';
import GameLegend from './GameLegend';
import Sidebar from '../sidebar/Sidebar';
import { useGameStore } from '../../stores/gameStore';
import { LAYOUT, COMMON_STYLES, Z_INDEX, BREAKPOINTS } from '../../utils/designSystem';
import useResponsive from '../../hooks/useResponsive'; // Import the new hook
import PanelSystem from './PanelSystem';

interface BaseLayoutProps {
  mode: 'play' | 'spectate' | 'dev';
  showLegend?: boolean;
  legendPosition?: 'bottom' | 'top' | 'left' | 'right';
  headerContent?: React.ReactNode;
  sidebar?: React.ReactNode;
  children: React.ReactNode;
  className?: string;
}

const BaseLayout: React.FC<BaseLayoutProps> = ({
  mode,
  showLegend = true,
  legendPosition = 'bottom',
  headerContent,
  sidebar,
  children,
  className = '',
}) => {
  const { isMobile, isTablet, isDesktop } = useResponsive();
  const sidebarCollapsed = useGameStore(state => state.sidebarCollapsed);
  const setSidebarCollapsed = useGameStore(state => state.setSidebarCollapsed);

  const getSidebarWidth = () => {
    if (isMobile) return LAYOUT.sidebarWidth.sm;
    if (isTablet) return LAYOUT.sidebarWidth.md;
    return LAYOUT.sidebarWidth.lg;
  };

  const getGameCanvasMaxWidth = () => {
    if (sidebar) {
      if (isMobile) return `calc(100vw - ${LAYOUT.sidebarWidth.sm})`;
      if (isTablet) return `calc(100vw - ${LAYOUT.sidebarWidth.md})`;
      return LAYOUT.gameCanvas.maxWidth; // Use default for desktop
    }
    return '100vw';
  };

  useEffect(() => {
    const onKeyDown = (e: KeyboardEvent) => {
      // Toggle sidebar with Ctrl+B (Windows/Linux) or Meta+B (Mac)
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'b') {
        // avoid toggling when user is typing
        const active = document.activeElement as HTMLElement | null;
        if (active) {
          const tag = active.tagName?.toLowerCase();
          if (tag === 'input' || tag === 'textarea' || active.isContentEditable) return;
        }
        // toggle via the store setter
        setSidebarCollapsed(prev => !prev);
        e.preventDefault();
      }
    };

    window.addEventListener('keydown', onKeyDown);
    return () => window.removeEventListener('keydown', onKeyDown);
  }, [setSidebarCollapsed]);

  return (
    <div
      className={`base-layout ${className}`}
      style={{
        display: 'flex',
        flexDirection: 'column',
        height: '100vh',
        width: '100vw',
        padding: 0,
        margin: 0,
        background: 'var(--color-background-primary)',
        fontFamily: 'var(--font-family-primary)',
        color: 'var(--color-text-primary)',
        overflow: 'hidden',
        boxSizing: 'border-box',
      }}
    >
      {/* Header */}
      <AppHeader mode={mode}>
        {headerContent}
      </AppHeader>

      {/* Main Content Area */}
      <div
        style={{
          display: 'flex',
          flex: 1,
          overflow: 'hidden',
          flexDirection: isMobile ? 'column' : 'row', // Stack vertically on mobile
        }}
      >
        {/* Primary Content */}
        <main
          style={{
            flex: 1,
            background: 'var(--color-surface)',
            overflow: 'hidden',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            position: 'relative',
          }}
        >
          {/* Game Content Container */}
          <div
            style={{
              width: '100%',
              height: '100%',
              maxWidth: getGameCanvasMaxWidth(),
              maxHeight: '100vh',
              overflow: 'hidden',
              position: 'relative',
            }}
          >
            <PanelSystem>{children}</PanelSystem>
          </div>

          {/* Game Legend */}
          {showLegend && (
            <GameLegend position={isMobile ? 'bottom' : legendPosition} />
          )}
        </main>

        {/* Sidebar - use explicitly passed sidebar if provided; otherwise render the default Sidebar for the current mode */}
        <aside
          id="app-sidebar"
          role="complementary"
          aria-label="Main sidebar"
          style={{
            width: isMobile ? '100%' : getSidebarWidth(), // Full width on mobile, dynamic on others
            height: isMobile ? LAYOUT.sidebarHeight.mobile : 'auto', // Fixed height on mobile
            background: 'var(--color-surface-variant)',
            borderLeft: isMobile ? 'none' : '1px solid var(--color-outline)',
            borderTop: isMobile ? '1px solid var(--color-outline)' : 'none', // Top border on mobile
            overflow: 'auto',
            order: isMobile ? 1 : 0, // Order sidebar below main content on mobile
          }}
        >
          {sidebarCollapsed ? (
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '8px' }}>
              <button
                aria-label="Open sidebar (Ctrl+B)"
                aria-controls="app-sidebar"
                aria-expanded={false}
                aria-keyshortcuts="Ctrl+B"
                onClick={() => setSidebarCollapsed(false)}
                style={{ background: 'transparent', border: 'none', color: 'var(--color-text-primary)', fontSize: '1.1rem', cursor: 'pointer' }}
              >
                â–¶
              </button>
            </div>
          ) : (
            <div>
              <div style={{ display: 'flex', justifyContent: 'flex-end', padding: '6px 8px' }}>
                <button
                  aria-label="Collapse sidebar (Ctrl+B)"
                  aria-controls="app-sidebar"
                  aria-expanded={true}
                  aria-keyshortcuts="Ctrl+B"
                  onClick={() => setSidebarCollapsed(true)}
                  style={{ background: 'transparent', border: 'none', color: 'var(--color-text-secondary)', fontSize: '0.9rem', cursor: 'pointer' }}
                >
                  â‡¤
                </button>
              </div>
              {sidebar || <Sidebar mode={mode} />}
            </div>
          )}
        </aside>
      </div>
    </div>
  );
};

export default BaseLayout;
</file>

<file path="packages/frontend/src/components/layout/BottomSettingsBar.tsx">
import React, { useState } from 'react';
import { useGameStore } from '../../stores/gameStore';
import { PlayerClass } from 'shared';

const BottomSettingsBar: React.FC = () => {
  const {
    currentPlayer,
    joinGame,
  handleRegenerateWorld,
    startCataclysm,
    movePlayer,
    gameMessage
  } = useGameStore();

  const [showSettings, setShowSettings] = useState(false);

  const handleJoin = () => {
    joinGame({
      id: `player_${Date.now()}`,
      displayName: 'Player' + Math.floor(Math.random() * 1000),
      class: PlayerClass.KNIGHT,
      avatar: 'ðŸ™‚'
    });
  };

  const handleRegenerate = () => {
    handleRegenerateWorld();
  };

  const handleCataclysm = () => {
    startCataclysm();
  };

  const handleMove = (direction: 'up' | 'down' | 'left' | 'right') => {
    movePlayer(direction);
  };

  return (
    <>
      {/* Bottom Settings Bar */}
      <div className="fixed inset-x-0 bottom-0 z-[1000] flex justify-center items-center gap-3 px-4 py-2 backdrop-blur-sm bg-[rgba(25,23,36,0.95)] border-t border-t-[rgba(196,167,231,0.2)]">
        {/* Join Game */}
        <button
          onClick={handleJoin}
          className="flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-transform transform hover:scale-105 bg-primary text-on-primary"
        >
          ðŸ”Œ Join
        </button>

        {/* Movement Controls */}
        {currentPlayer && (
          <>
            <div className="flex gap-1">
              <button
                onClick={() => handleMove('up')}
                className="w-9 h-9 flex items-center justify-center text-lg rounded-sm border border-outline bg-surface-variant text-text-primary transition-colors hover:bg-primary-container"
              >
                â†‘
              </button>
            </div>

            <div className="flex gap-1">
              <button
                onClick={() => handleMove('left')}
                className="w-9 h-9 flex items-center justify-center text-lg rounded-sm border border-outline bg-surface-variant text-text-primary transition-colors hover:bg-primary-container"
              >
                â†
              </button>

              <button
                onClick={() => handleMove('down')}
                className="w-9 h-9 flex items-center justify-center text-lg rounded-sm border border-outline bg-surface-variant text-text-primary transition-colors hover:bg-primary-container"
              >
                â†“
              </button>

              <button
                onClick={() => handleMove('right')}
                className="w-9 h-9 flex items-center justify-center text-lg rounded-sm border border-outline bg-surface-variant text-text-primary transition-colors hover:bg-primary-container"
              >
                â†’
              </button>
            </div>
          </>
        )}

        {/* World Controls */}
        <button
          onClick={handleRegenerate}
          className="flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-transform transform hover:scale-105 bg-secondary text-on-secondary"
        >
          ðŸŒ Regen
        </button>

        <button
          onClick={handleCataclysm}
          className="flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-transform transform hover:scale-105 bg-error text-on-error"
        >
          âš¡ Cataclysm
        </button>

        {/* Settings Toggle */}
        <button
          onClick={() => setShowSettings(!showSettings)}
          className="flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-colors bg-surface-variant text-text-primary border border-outline hover:bg-primary-container"
        >
          âš™ï¸ Settings
        </button>
      </div>

      {/* Settings Modal */}
      {showSettings && (
        <div className="fixed inset-0 z-[2000] flex items-center justify-center bg-black/50">
          <div className="bg-surface border border-outline rounded-xl p-6 max-w-md w-[90%] max-h-[80vh] overflow-auto">
            <div className="flex items-center justify-between mb-4">
              <h3 className="m-0 text-text-primary">Quick Settings</h3>
              <button onClick={() => setShowSettings(false)} className="text-text-secondary text-lg p-1">Ã—</button>
            </div>

            <div className="flex flex-col gap-3">
              <div>
                <label className="block mb-1 text-text-primary">Show Grid</label>
                <input type="checkbox" defaultChecked />
              </div>

              <div>
                <label className="block mb-1 text-text-primary">Show Particles</label>
                <input type="checkbox" defaultChecked />
              </div>

              <div>
                <label className="block mb-1 text-text-primary">Animation Speed</label>
                <input type="range" min="0.1" max="3" step="0.1" defaultValue="1" className="w-full" />
              </div>

              <div>
                <label className="block mb-1 text-text-primary">Volume</label>
                <input type="range" min="0" max="100" defaultValue="80" className="w-full" />
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Game Message */}
      {gameMessage && (
        <div className="fixed bottom-[80px] left-1/2 -translate-x-1/2 z-[1500] px-4 py-2 rounded-md text-sm bg-primary-container text-on-primary-container shadow-lg">
          {gameMessage}
        </div>
      )}
    </>
  );
};

export default BottomSettingsBar;
</file>

<file path="packages/frontend/src/components/layout/RightSidebar.tsx">
import React, { useState } from 'react';
import { useGameStore } from '../../stores/gameStore';
import { PlayerClass } from 'shared';
import {
  CategoryNavigation,
  OverviewPanel,
  // Player specific overview panel
  PlayerSummaryPanel,
  GameplaySettings,
  AudioSettings,
  VisualSettings,
  WorldSettings,
  ActionsPanel,
  PlayerStatusPanel
} from '../sidebar';
import { MaterialCard, MaterialChip, MaterialPaper } from './index';

const RightSidebar: React.FC = () => {
  const {
  currentPlayer,
  joinGame,
  handleRegenerateWorld,
    startCataclysm,
    movePlayer,
    pickupItem,
    gameMessage,
    gameWorld,
    unifiedSettings,
    updateGameSettings,
    updateAudioSettings,
    updateNotificationSettings,
    updateVisualSettings,
    updateWorldSettings,
    updateAnimationSettings,
  } = useGameStore();

  const [activeCategory, setActiveCategory] = useState<string>('overview');

  const categories = [
    { id: 'overview', label: 'Overview', icon: 'ðŸ§­' },
    { id: 'player', label: 'Player', icon: 'ðŸ§‘' },
    { id: 'gameplay', label: 'Gameplay', icon: 'ðŸŽ®' },
    { id: 'audio', label: 'Audio', icon: 'ðŸŽµ' },
    { id: 'visual', label: 'Visual', icon: 'ðŸ‘ï¸' },
    { id: 'world', label: 'World', icon: 'ðŸŒ' },
    { id: 'actions', label: 'Actions', icon: 'âš”ï¸' },
  ];

  const handleJoin = () => {
    joinGame({
      id: `player_${Date.now()}`,
      displayName: 'Player' + Math.floor(Math.random() * 1000),
      class: PlayerClass.KNIGHT,
      avatar: 'ðŸ™‚'
    });
  };

  const handleRegenerate = () => {
    handleRegenerateWorld();
  };

  const handleCataclysm = () => {
    startCataclysm();
  };

  const handleMove = (direction: 'up' | 'down' | 'left' | 'right') => {
    movePlayer(direction);
  };

  const handlePickup = () => {
    pickupItem('nearest');
  };

  const renderCategoryContent = () => {
    switch (activeCategory) {
      case 'overview':
        return (
          <OverviewPanel
            gameWorld={gameWorld}
            currentPlayer={currentPlayer}
            gameMessage={gameMessage}
          />
        );

      case 'player':
        return (
          <PlayerSummaryPanel
            player={currentPlayer}
          />
        );

      case 'gameplay':
        return (
          <GameplaySettings
            unifiedSettings={unifiedSettings}
            updateGameSettings={updateGameSettings}
          />
        );

      case 'audio':
        return (
          <AudioSettings
            unifiedSettings={unifiedSettings}
            updateAudioSettings={updateAudioSettings}
          />
        );

      case 'visual':
        return (
          <VisualSettings
            unifiedSettings={unifiedSettings}
            updateVisualSettings={updateVisualSettings}
            updateAnimationSettings={updateAnimationSettings}
          />
        );

      case 'world':
        return (
          <WorldSettings
            unifiedSettings={unifiedSettings}
            updateWorldSettings={updateWorldSettings}
          />
        );

      case 'actions':
        return (
          <ActionsPanel
            currentPlayer={currentPlayer}
            onJoin={handleJoin}
            onMove={handleMove}
            onPickup={handlePickup}
            onRegenerate={handleRegenerate}
            onCataclysm={handleCataclysm}
          />
        );

      default:
        return null;
    }
  };

  return (
    <div className="w-[320px] h-screen flex flex-col overflow-hidden shadow-[ -4px_0_20px_rgba(0,0,0,0.15) ] backdrop-blur-[20px] bg-[linear-gradient(145deg,var(--color-background-paper)_0%,rgba(31,29,46,0.95)_100%)] border-l border-[var(--color-divider)]">
      {/* Header */}
      <div className="p-5 border-b border-[var(--color-outline)] bg-[linear-gradient(135deg,rgba(196,167,231,0.05)_0%,rgba(156,207,216,0.05)_100%)]">
        <h1 className="font-serif text-xl font-extrabold text-text-primary m-0 uppercase tracking-widest text-center header-gradient">chatterealm</h1>
      </div>

      {/* Category Icons Row */}
  <div className="px-5 py-3 border-b flex justify-between items-center gap-1 border-[var(--color-outline)]">
        {categories.map(category => (
          <button
            key={category.id}
            onClick={() => setActiveCategory(category.id)}
            className={`flex-1 rounded-lg px-2 py-2 flex flex-col items-center gap-1 min-h-[50px] transition-all duration-200 ${activeCategory === category.id ? 'bg-[rgba(196,167,231,0.2)] border border-[rgba(196,167,231,0.4)]' : 'bg-transparent border border-transparent hover:bg-[rgba(196,167,231,0.1)]'}`}
          >
            <span className="text-lg block mb-0.5">{category.icon}</span>
            <span className={`text-[0.7rem] ${activeCategory === category.id ? 'text-primary font-semibold' : 'text-text-secondary font-normal'}`}>{category.label}</span>
          </button>
        ))}
      </div>

      {/* Content Area */}
      <div className="flex-1 overflow-auto scrollbar-thin">
        {renderCategoryContent()}
      </div>

      {/* Player Status - Always visible at bottom */}
      {currentPlayer && (
        <div className="p-4 border-t border-[var(--color-outline)] bg-[var(--color-surface-variant)]/80">
          <PlayerStatusPanel currentPlayer={currentPlayer} />
        </div>
      )}
    </div>
  );
};

export default RightSidebar;
</file>

<file path="packages/frontend/src/components/settings/UnifiedSettingsMenu.tsx">
import React, { useState } from 'react';
import { useGameStore } from '../../stores/gameStore';
import {
  SettingSlider,
  SettingCheckbox,
  SettingDropdown,
  SettingGroup,
  MaterialMultiSelect,
} from '../shared/settings';
import { DropdownOption } from './shared/settings/SettingDropdown';
import { MovementStyle, Theme, PlayerClass } from 'shared';

/**
 * UnifiedSettingsMenu
 * A consolidated menu that merges: Gameplay Settings, Audio, Visual/Display, World/Advanced,
 * Actions (movement / join / cataclysm / pickup / regenerate), and World Info/Dev diagnostics.
 *
 * This replaces the separate tabs previously spread across: GameControls, WorldControls,
 * AnimationControls, and SettingsPanel. It keeps the same underlying store update functions
 * (so all state continuity is preserved) while providing a single coherent navigation model.
 *
 * Structure:
 *  - High-level primary tabs: Overview, Gameplay, Audio, Visual, World & Advanced, Actions & Debug
 *  - Each tab internally groups related settings via SettingGroup for clarity
 */
const UnifiedSettingsMenu: React.FC = () => {
  const {
    unifiedSettings,
    updateGameSettings,
    updateAudioSettings,
    updateNotificationSettings,
    updateVisualSettings,
    updateWorldSettings,
    updateAnimationSettings,
    gameWorld,
    currentPlayer,
    joinGame,
    movePlayer,
    startCataclysm,
    pickupItem,
  handleRegenerateWorld,
    gameMessage,
  } = useGameStore();

  const [activeTab, setActiveTab] = useState<string>('overview');
  const [importText, setImportText] = useState('');
  const [showImportExport, setShowImportExport] = useState(false);

  const exportSettings = useGameStore(s => s.exportSettings);
  const importSettings = useGameStore(s => s.importSettings);
  const resetAllSettings = useGameStore(s => s.resetAllSettings);

  // Dropdown option definitions
  const movementStyleOptions: DropdownOption[] = [
    { value: MovementStyle.GRID, label: 'Grid Movement' },
    { value: MovementStyle.FREE, label: 'Free Movement' },
    { value: MovementStyle.HYBRID, label: 'Hybrid Movement' },
  ];

  const themeOptions: DropdownOption[] = [
    { value: Theme.DARK, label: 'ðŸŒ™ Dark Theme', icon: 'ðŸŒ™' },
    { value: Theme.LIGHT, label: 'â˜€ï¸ Light Theme', icon: 'â˜€ï¸' },
    { value: Theme.AUTO, label: 'ðŸ¤– Auto (System)', icon: 'ðŸ¤–' },
  ];

  const languageOptions: DropdownOption[] = [
    { value: 'en', label: 'ðŸ‡ºðŸ‡¸ English', icon: 'ðŸ‡ºðŸ‡¸' },
    { value: 'es', label: 'ðŸ‡ªðŸ‡¸ EspaÃ±ol', icon: 'ðŸ‡ªðŸ‡¸' },
    { value: 'fr', label: 'ðŸ‡«ðŸ‡· FranÃ§ais', icon: 'ðŸ‡«ðŸ‡·' },
    { value: 'de', label: 'ðŸ‡©ðŸ‡ª Deutsch', icon: 'ðŸ‡©ðŸ‡ª' },
    { value: 'jp', label: 'ðŸ‡¯ðŸ‡µ æ—¥æœ¬èªž', icon: 'ðŸ‡¯ðŸ‡µ' },
  ];

  const fillStyleOptions: DropdownOption[] = [
    { value: 'hachure', label: 'Hachure' },
    { value: 'solid', label: 'Solid' },
    { value: 'zigzag', label: 'Zigzag' },
    { value: 'cross-hatch', label: 'Cross-Hatch' },
    { value: 'dots', label: 'Dots' },
    { value: 'sunburst', label: 'Sunburst' },
    { value: 'dashed', label: 'Dashed' },
    { value: 'scrawl', label: 'Scrawl' },
  ];

  // Import / Export handlers (reuse logic from SettingsPanel)
  const handleExport = () => {
    const data = exportSettings();
    navigator.clipboard.writeText(data);
    alert('Settings exported to clipboard!');
  };

  const handleImport = () => {
    if (importText.trim()) {
      const success = importSettings(importText.trim());
      if (success) {
        alert('Settings imported successfully!');
        setImportText('');
        setShowImportExport(false);
      } else {
        alert('Import failed. Check JSON format.');
      }
    }
  };

  const handleResetAll = () => {
    if (confirm('Reset ALL settings to defaults?')) {
      resetAllSettings();
      alert('All settings reset.');
    }
  };

  // Action handlers mapped to store actions
  const handleJoin = () => joinGame({
    id: `player_${Date.now()}`,
    displayName: 'Player' + Math.floor(Math.random() * 1000),
    class: PlayerClass.KNIGHT,
    avatar: 'ðŸ™‚'
  });
  const handleMove = (dir: 'up' | 'down' | 'left' | 'right') => movePlayer(dir);
  const handlePickup = () => pickupItem('nearest'); // Assuming backend interprets 'nearest'
  const handleCataclysm = () => startCataclysm();
  const handleRegenerate = () => handleRegenerateWorld();

  const notificationTypeOptions = [
    { value: 'desktop', label: 'Desktop' },
    { value: 'sound', label: 'Sound' },
    { value: 'ingame', label: 'In-Game' },
  ];

  return (
    <div className="h-full flex flex-col font-inter">
      <div className="flex justify-between items-center mb-2 pb-1.5 border-b border-outline">
        <h3 className="text-text-primary text-sm font-semibold m-0">
          âš™ï¸ Settings
        </h3>
        <div className="flex gap-1.5">
          <button
            className="px-1.5 py-0.5 bg-secondary-container text-on-secondary-container border border-outline rounded cursor-pointer text-xs font-medium transition-all duration-200 hover:bg-secondary"
            onClick={() => setShowImportExport(v => !v)}
          >
            {showImportExport ? 'Hide' : 'I/E'}
          </button>
          <button
            className="px-1.5 py-0.5 bg-error-container text-on-error-container border border-error rounded cursor-pointer text-xs font-medium transition-all duration-200 hover:bg-error"
            onClick={handleResetAll}
          >
            Reset
          </button>
        </div>
      </div>

      {showImportExport && (
        <div className="mb-4 p-3 bg-surface-variant rounded-lg border border-outline-variant">
          <div className="mb-3">
            <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={handleExport}>ðŸ“¤ Export Settings</button>
          </div>
          <div className="mb-2">
            <label className="block text-text-primary mb-1">Import Settings JSON</label>
            <textarea
              className="w-full min-h-20 p-2 bg-background-paper border border-outline rounded text-text-primary font-mono text-sm resize-y"
              rows={4}
              placeholder="Paste exported JSON here..."
              value={importText}
              onChange={(e) => setImportText(e.target.value)}
            />
            <button className="btn-primary mt-2" onClick={handleImport}>ðŸ“¥ Import</button>
          </div>
        </div>
      )}

      <div className="flex gap-1.5 mb-4 flex-wrap justify-center">
        {[
          { id: 'overview', label: 'ðŸ§­ Overview' },
          { id: 'rendering', label: 'âœï¸ Rendering' },
          { id: 'audio', label: 'ðŸŽµ Audio' },
          { id: 'gameplay', label: 'ðŸŽ® Gameplay' },
          { id: 'world', label: 'ðŸŒ World' },
          { id: 'actions', label: 'âš”ï¸ Actions' },
        ].map(t => (
          <button
            key={t.id}
            className={`px-4 py-2 rounded-lg min-w-[120px] text-sm font-medium transition-all duration-200 text-center ${activeTab === t.id ? 'bg-primary text-on-primary border border-primary' : 'bg-surface-variant text-text-secondary border border-outline'}`}
            onClick={() => setActiveTab(t.id)}
          >
            {t.label}
          </button>
        ))}
      </div>

      <div className="flex-1 min-h-0 overflow-y-auto py-2">
        {activeTab === 'overview' && (
          <div className="px-2">
            <div className="bg-surface-variant rounded-lg p-3 mb-3 border border-outline-variant">
              <h4 className="text-text-primary text-sm font-semibold mb-2 flex items-center gap-1">ðŸ—ºï¸ World Snapshot</h4>
              <div className="grid grid-cols-2 gap-2 text-sm">
                <div className="text-text-secondary"><strong>Phase:</strong> {gameWorld?.phase || 'N/A'}</div>
                <div className="text-text-secondary"><strong>Players:</strong> {gameWorld ? gameWorld.players.length : 0}</div>
                <div className="text-text-secondary"><strong>NPCs:</strong> {gameWorld ? gameWorld.npcs.length : 0}</div>
                <div className="text-text-secondary"><strong>Items:</strong> {gameWorld ? gameWorld.items.length : 0}</div>
                <div className="text-text-secondary col-span-2"><strong>World Age:</strong> {gameWorld?.worldAge || 0} cycles</div>
              </div>
            </div>
            {currentPlayer && (
              <div className="bg-surface-variant rounded-lg p-3 mb-3 border border-outline-variant">
                <h4 className="text-text-primary text-sm font-semibold mb-2 flex items-center gap-1">ðŸ§‘ Current Player</h4>
                <div className="grid grid-cols-2 gap-2 text-sm">
                  <div className="text-text-secondary"><strong>Name:</strong> {currentPlayer.name}</div>
                  <div className="text-text-secondary"><strong>Health:</strong> {currentPlayer.health}</div>
                  <div className="text-text-secondary"><strong>Level:</strong> {currentPlayer.level}</div>
                  <div className="text-text-secondary"><strong>Pos:</strong> {currentPlayer.position.x},{currentPlayer.position.y}</div>
                </div>
              </div>
            )}
            {gameMessage && (
              <div className="bg-warning-container text-on-warning-container rounded-lg p-3 border border-warning text-sm">
                {gameMessage}
              </div>
            )}
          </div>
        )}

        {activeTab === 'gameplay' && (
          <div className="px-2 space-y-4">
            <SettingGroup title="Gameplay" icon="ðŸŽ¯">
              <SettingCheckbox
                label="Enable Auto-Save"
                checked={unifiedSettings.game.autoSaveEnabled}
                onChange={(c) => updateGameSettings({ autoSaveEnabled: c })}
                description="Automatically save progress periodically"
              />
              <SettingCheckbox
                label="Show Tutorials"
                checked={unifiedSettings.game.tutorialEnabled}
                onChange={(c) => updateGameSettings({ tutorialEnabled: c })}
                description="Display tutorial hints"
              />
              <SettingCheckbox
                label="Show Mini-map"
                checked={unifiedSettings.game.minimapEnabled}
                onChange={(c) => updateGameSettings({ minimapEnabled: c })}
                description="Toggle mini-map display"
              />
              <SettingDropdown
                label="Movement Style"
                value={unifiedSettings.game.movementStyle}
                options={movementStyleOptions}
                onChange={(v) => updateGameSettings({ movementStyle: v as MovementStyle })}
                description="How the player traverses the world"
              />
            </SettingGroup>
            <SettingGroup title="Combat" icon="âš”ï¸">
              <SettingCheckbox
                label="Show Damage Numbers"
                checked={unifiedSettings.game.showDamageNumbers}
                onChange={(c) => updateGameSettings({ showDamageNumbers: c })}
                description="Visual floating damage indicators"
              />
              <SettingCheckbox
                label="Enable Auto-Combat"
                checked={unifiedSettings.game.autoCombatEnabled}
                onChange={(c) => updateGameSettings({ autoCombatEnabled: c })}
                description="Auto retaliate when attacked"
              />
            </SettingGroup>
          </div>
        )}

        {activeTab === 'audio' && (
          <div className="px-2 space-y-4">
            <SettingGroup title="Volume" icon="ðŸ”Š">
              <SettingSlider
                label="Master Volume"
                value={unifiedSettings.audio.audioMasterVolume}
                min={0} max={100} step={5}
                onChange={(v) => updateAudioSettings({ audioMasterVolume: v })}
                unit="%" showReset resetValue={80}
                description="Global mix level"
              />
              <SettingSlider
                label="SFX Volume"
                value={unifiedSettings.audio.sfxVolume}
                min={0} max={100} step={5}
                onChange={(v) => updateAudioSettings({ sfxVolume: v })}
                unit="%" showReset resetValue={70}
                description="Sound effects loudness"
              />
              <SettingSlider
                label="Music Volume"
                value={unifiedSettings.audio.musicVolume}
                min={0} max={100} step={5}
                onChange={(v) => updateAudioSettings({ musicVolume: v })}
                unit="%" showReset resetValue={60}
                description="Background soundtrack volume"
              />
            </SettingGroup>
            <SettingGroup title="Audio Toggles" icon="ðŸ”ˆ">
              <SettingCheckbox
                label="Enable SFX"
                checked={unifiedSettings.audio.soundEnabled}
                onChange={(c) => updateAudioSettings({ soundEnabled: c })}
                description="Play sound effects"
              />
              <SettingCheckbox
                label="Enable Music"
                checked={unifiedSettings.audio.musicEnabled}
                onChange={(c) => updateAudioSettings({ musicEnabled: c })}
                description="Play background music"
              />
            </SettingGroup>
            <SettingGroup title="Notifications" icon="ðŸ””">
              <SettingCheckbox
                label="Desktop Notifications"
                checked={unifiedSettings.notifications.desktopNotifications}
                onChange={(c) => updateNotificationSettings({ desktopNotifications: c })}
                description="Show desktop notifications"
              />
              <SettingCheckbox
                label="Sound Notifications"
                checked={unifiedSettings.notifications.soundNotifications}
                onChange={(c) => updateNotificationSettings({ soundNotifications: c })}
                description="Play sound on notifications"
              />
              <SettingCheckbox
                label="Battle Notifications"
                checked={unifiedSettings.notifications.battleNotifications}
                onChange={(c) => updateNotificationSettings({ battleNotifications: c })}
                description="Notify on battle events"
              />
              <SettingCheckbox
                label="System Notifications"
                checked={unifiedSettings.notifications.systemNotifications}
                onChange={(c) => updateNotificationSettings({ systemNotifications: c })}
                description="General system notifications"
              />
              {/* Multi-select event notification types */}
              <MaterialMultiSelect
                label="Player Join Notifications"
                value={unifiedSettings.notifications.playerJoinNotifications}
                options={notificationTypeOptions}
                onChange={(vals) => updateNotificationSettings({ playerJoinNotifications: vals as any })}
                description="Notification channels when players join"
              />
              <MaterialMultiSelect
                label="Item Drop Notifications"
                value={unifiedSettings.notifications.itemDropNotifications}
                options={notificationTypeOptions}
                onChange={(vals) => updateNotificationSettings({ itemDropNotifications: vals as any })}
                description="Notification channels for item drops"
              />
              <MaterialMultiSelect
                label="Level Up Notifications"
                value={unifiedSettings.notifications.levelUpNotifications}
                options={notificationTypeOptions}
                onChange={(vals) => updateNotificationSettings({ levelUpNotifications: vals as any })}
                description="Notification channels on level up"
              />
              <MaterialMultiSelect
                label="Cataclysm Notifications"
                value={unifiedSettings.notifications.cataclysmNotifications}
                options={notificationTypeOptions}
                onChange={(vals) => updateNotificationSettings({ cataclysmNotifications: vals as any })}
                description="Notification channels when cataclysm starts"
              />
            </SettingGroup>
          </div>
        )}

        {activeTab === 'rendering' && (
          <div className="px-2 space-y-4">
            <SettingGroup title="Drawing Style" icon="âœï¸">
              <SettingSlider
                label="Roughness"
                value={unifiedSettings.animations.roughness}
                min={0} max={5} step={0.1}
                onChange={(v) => updateAnimationSettings({ roughness: v })}
                showReset resetValue={1.5}
                description="Hand-drawn sketchiness level"
              />
              <SettingSlider
                label="Bowing"
                value={unifiedSettings.animations.bowing}
                min={0} max={5} step={0.1}
                onChange={(v) => updateAnimationSettings({ bowing: v })}
                showReset resetValue={1.2}
                description="Line curvature and waviness"
              />
              <SettingDropdown
                label="Fill Style"
                value={unifiedSettings.animations.fillStyle || 'hachure'}
                options={fillStyleOptions}
                onChange={(v) => updateAnimationSettings({ fillStyle: String(v) })}
                description="Pattern used for filled areas"
              />
              <SettingSlider
                label="Stroke Width"
                value={unifiedSettings.animations.strokeWidth || 1.5}
                min={0.5} max={4} step={0.1}
                onChange={(v) => updateAnimationSettings({ strokeWidth: v })}
                showReset resetValue={1.5}
                description="Thickness of all outlines"
              />
            </SettingGroup>
            <SettingGroup title="Advanced Drawing" icon="ðŸŽ¨">
              <SettingSlider
                label="Fill Weight"
                value={unifiedSettings.animations.fillWeight}
                min={0} max={5} step={0.1}
                onChange={(v) => updateAnimationSettings({ fillWeight: v })}
                showReset resetValue={1.5}
                description="Thickness of fill patterns"
              />
              <SettingSlider
                label="Hachure Angle"
                value={unifiedSettings.animations.hachureAngle}
                min={0} max={180} step={15}
                onChange={(v) => updateAnimationSettings({ hachureAngle: v })}
                unit="Â°" showReset resetValue={45}
                description="Angle for hatching patterns"
              />
              <SettingSlider
                label="Hachure Gap"
                value={unifiedSettings.animations.hachureGap}
                min={1} max={20} step={1}
                onChange={(v) => updateAnimationSettings({ hachureGap: v })}
                showReset resetValue={4}
                description="Spacing between hatch lines"
              />
              <SettingSlider
                label="Random Seed"
                value={unifiedSettings.animations.seed || 1}
                min={1} max={10000} step={1}
                onChange={(v) => updateAnimationSettings({ seed: v })}
                showReset resetValue={1}
                description="Seed for deterministic randomness"
              />
            </SettingGroup>
            <SettingGroup title="Animation & Effects" icon="ðŸŽžï¸">
              <SettingSlider
                label="Animation Speed"
                value={unifiedSettings.animations.animationSpeed}
                min={0.1} max={3} step={0.1}
                onChange={(v) => updateAnimationSettings({ animationSpeed: v })}
                unit="x" showReset resetValue={1.0}
                description="Global animation speed multiplier"
              />
              <SettingSlider
                label="Particle Count"
                value={unifiedSettings.animations.particleCount}
                min={0} max={20} step={1}
                onChange={(v) => updateAnimationSettings({ particleCount: v })}
                showReset resetValue={5}
                description="Number of effect particles"
              />
            </SettingGroup>
            <SettingGroup title="Display Options" icon="ðŸ‘ï¸">
              <SettingDropdown
                label="Theme"
                value={unifiedSettings.visual.theme}
                options={themeOptions}
                onChange={(v) => updateVisualSettings({ theme: v as Theme })}
                description="Color scheme preference"
              />
              <SettingSlider
                label="Font Size"
                value={unifiedSettings.visual.fontSize}
                min={75} max={150} step={5}
                onChange={(v) => updateVisualSettings({ fontSize: v })}
                unit="%" showReset resetValue={100}
                description="Global UI text scaling"
              />
              <SettingDropdown
                label="Language"
                value={unifiedSettings.visual.language}
                options={languageOptions}
                onChange={(v) => updateVisualSettings({ language: String(v) })}
                description="Interface language"
              />
              <SettingCheckbox
                label="High Contrast"
                checked={unifiedSettings.visual.highContrast}
                onChange={(c) => updateVisualSettings({ highContrast: c })}
                description="Increase contrast for readability"
              />
              <SettingCheckbox
                label="Reduce Motion"
                checked={unifiedSettings.visual.reduceMotion}
                onChange={(c) => updateVisualSettings({ reduceMotion: c })}
                description="Minimize non-essential animations"
              />
              <SettingCheckbox
                label="Show Grid"
                checked={unifiedSettings.visual.showGrid}
                onChange={(c) => updateVisualSettings({ showGrid: c })}
                description="Debug/display coordinate grid"
              />
              <SettingCheckbox
                label="Show Particles"
                checked={unifiedSettings.visual.showParticles}
                onChange={(c) => updateVisualSettings({ showParticles: c })}
                description="Enable particle effects"
              />
              <SettingCheckbox
                label="Show Health Bars"
                checked={unifiedSettings.visual.showHealthBars}
                onChange={(c) => updateVisualSettings({ showHealthBars: c })}
                description="Display entity health bars"
              />
            </SettingGroup>
          </div>
        )}

        {activeTab === 'world' && (
          <div className="px-2 space-y-4">
            <SettingGroup title="World Dimensions" icon="ðŸ“">
              <SettingSlider
                label="World Width"
                value={unifiedSettings.world.worldWidth}
                min={20} max={100} step={5}
                onChange={(v) => updateWorldSettings({ worldWidth: v })}
                unit=" tiles" showReset resetValue={40}
                description="Horizontal size"
              />
              <SettingSlider
                label="World Height"
                value={unifiedSettings.world.worldHeight}
                min={15} max={75} step={3}
                onChange={(v) => updateWorldSettings({ worldHeight: v })}
                unit=" tiles" showReset resetValue={30}
                description="Vertical size"
              />
            </SettingGroup>
            <SettingGroup title="Environment Animation" icon="ðŸŒ¿">
              <SettingSlider
                label="Grass Wave Speed"
                value={unifiedSettings.world.grassWaveSpeed}
                min={0} max={1} step={0.1}
                onChange={(v) => updateWorldSettings({ grassWaveSpeed: v })}
                showReset resetValue={0.1}
                description="Grass sway speed"
              />
              <SettingSlider
                label="Tree Sway Speed"
                value={unifiedSettings.world.treeSwaySpeed}
                min={0} max={1} step={0.1}
                onChange={(v) => updateWorldSettings({ treeSwaySpeed: v })}
                showReset resetValue={0.03}
                description="Tree movement speed"
              />
              <SettingSlider
                label="Flower Spawn Rate"
                value={unifiedSettings.world.flowerSpawnRate}
                min={0} max={1} step={0.1}
                onChange={(v) => updateWorldSettings({ flowerSpawnRate: v })}
                showReset resetValue={0.01}
                description="Spawn rate of flowers"
              />
              <SettingSlider
                label="Wind Speed"
                value={unifiedSettings.world.windSpeed}
                min={0} max={1} step={0.1}
                onChange={(v) => updateWorldSettings({ windSpeed: v })}
                showReset resetValue={0.02}
                description="Global wind agitation"
              />
            </SettingGroup>
          </div>
        )}

        {activeTab === 'actions' && (
          <div className="px-2 space-y-4">
            <SettingGroup title="Player Actions" icon="ðŸ•¹ï¸">
              <div className="flex flex-wrap gap-2">
                <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={handleJoin}>ðŸ”Œ Join Game</button>
                <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={() => handleMove('up')}>â†‘</button>
                <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={() => handleMove('down')}>â†“</button>
                <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={() => handleMove('left')}>â†</button>
                <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={() => handleMove('right')}>â†’</button>
                <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={handlePickup}>ðŸŽ’ Pick Up</button>
              </div>
            </SettingGroup>
            <SettingGroup title="World / Events" icon="ðŸŒ©ï¸">
              <div className="flex flex-wrap gap-2">
                <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={handleRegenerate}>ðŸŒ Regenerate World</button>
                <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={handleCataclysm}>âš¡ Start Cataclysm</button>
              </div>
              {gameWorld && (
                <ul className="space-y-1 text-sm text-text-secondary">
                  <li>Cataclysm Active: {gameWorld.cataclysmCircle.isActive ? 'Yes' : 'No'}</li>
                  {gameWorld.cataclysmCircle.isActive && (
                    <li>Radius: {gameWorld.cataclysmCircle.radius.toFixed(1)}</li>
                  )}
                  <li>Last Reset: {new Date(gameWorld.lastResetTime).toLocaleTimeString()}</li>
                </ul>
              )}
            </SettingGroup>
          </div>
        )}
      </div>
    </div>
  );
};

export default UnifiedSettingsMenu;
</file>

<file path="packages/frontend/src/components/settings/UnifiedSettingsMenuModal.tsx">
import React, { useState, useRef } from 'react';
import { useGameStore } from '../../stores/gameStore';
import { MaterialButton, MaterialPopover, MaterialCard } from '../index';
import CategoryButton from './shared/CategoryButton';
import {
  Info as InfoIcon,
  VideogameAsset as GameIcon,
  VolumeUp as AudioIcon,
  Visibility as VisualIcon,
  Public as WorldIcon,
  SportsEsports as ActionsIcon,
} from '@mui/icons-material';

import { MaterialMultiSelect } from './shared/settings';

// Import individual modal components
import OverviewModal from './settings/OverviewModal';
import GameplayModal from './settings/GameplayModal';
import AudioModal from './settings/AudioModal';
import VisualModal from './settings/VisualModal';
import WorldModal from './settings/WorldModal';
import ActionsModal from './settings/ActionsModal';

/**
 * UnifiedSettingsMenuModal
 * A modal-based settings menu that opens full-height popovers for each category.
 * This replaces the tabbed interface with a more spacious modal experience.
 */
const UnifiedSettingsMenuModal: React.FC = () => {
  const {
    unifiedSettings,
    updateGameSettings,
    updateAudioSettings,
    updateNotificationSettings,
    updateVisualSettings,
    updateWorldSettings,
    updateAnimationSettings,
    gameWorld,
    currentPlayer,
    joinGame,
    movePlayer,
    startCataclysm,
    pickupItem,
  handleRegenerateWorld,
    gameMessage,
  } = useGameStore();

  const [activeModal, setActiveModal] = useState<string | null>(null);
  const [importText, setImportText] = useState('');
  const [showImportExport, setShowImportExport] = useState(false);
  const buttonRefs = useRef<{ [key: string]: HTMLButtonElement | null }>({});

  const exportSettings = useGameStore(s => s.exportSettings);
  const importSettings = useGameStore(s => s.importSettings);
  const resetAllSettings = useGameStore(s => s.resetAllSettings);

  // Import / Export handlers
  const handleExport = () => {
    const data = exportSettings();
    navigator.clipboard.writeText(data);
    alert('Settings exported to clipboard!');
  };

  const handleImport = () => {
    if (importText.trim()) {
      const success = importSettings(importText.trim());
      if (success) {
        alert('Settings imported successfully!');
        setImportText('');
        setShowImportExport(false);
      } else {
        alert('Import failed. Check JSON format.');
      }
    }
  };

  const handleResetAll = () => {
    if (confirm('Reset ALL settings to defaults?')) {
      resetAllSettings();
      alert('All settings reset.');
    }
  };

  const notificationTypeOptions = [
    { value: 'desktop', label: 'Desktop' },
    { value: 'sound', label: 'Sound' },
    { value: 'ingame', label: 'In-Game' },
  ];

  const openModal = (modalId: string) => {
    setActiveModal(modalId);
  };

  const closeModal = () => {
    setActiveModal(null);
  };

  const categories = [
    { id: 'overview', label: 'Overview', icon: InfoIcon, token: 'primary' },
    { id: 'gameplay', label: 'Gameplay', icon: GameIcon, token: 'health.healthy' },
    { id: 'audio', label: 'Audio', icon: AudioIcon, token: 'accentPurple' },
    { id: 'visual', label: 'Visual', icon: VisualIcon, token: 'accentDarkPurple' },
    { id: 'world', label: 'World', icon: WorldIcon, token: 'secondary' },
    { id: 'actions', label: 'Actions', icon: ActionsIcon, token: 'error' },
  ];

  return (
    <div className="h-full flex flex-col font-inter">
      {/* Header */}
      <div className="flex justify-between items-center mb-4 pb-3 border-b border-divider">
        <h3 className="text-text-primary text-sm font-semibold m-0">âš™ï¸ Settings</h3>
        <div className="flex gap-2">
          <MaterialButton size="small" onClick={() => setShowImportExport(v => !v)} sx={{ minHeight: '32px', px: 2, fontSize: '0.8rem' }}>{showImportExport ? 'Hide' : 'I/E'}</MaterialButton>
          <MaterialButton size="small" color="error" onClick={handleResetAll} sx={{ minHeight: '32px', px: 2, fontSize: '0.8rem' }}>Reset</MaterialButton>
        </div>
      </div>

      {/* Import/Export Panel */}
      {showImportExport && (
        <MaterialCard sx={{ mb: 2, p: 2, backgroundColor: 'var(--color-surface-variant)' }}>
          <div className="mb-3">
            <MaterialButton onClick={handleExport} sx={{ mr: 1 }}>ðŸ“¤ Export Settings</MaterialButton>
          </div>
          <div className="mb-2">
            <label className="block font-mono text-sm text-text-primary mb-1">Import Settings JSON</label>
            <textarea
              className="w-full min-h-[80px] p-2 bg-background-paper border border-divider rounded text-text-primary font-mono text-sm resize-y"
              placeholder="Paste exported JSON here..."
              value={importText}
              onChange={(e) => setImportText(e.target.value)}
            />
          </div>
          <MaterialButton onClick={handleImport}>ðŸ“¥ Import</MaterialButton>
        </MaterialCard>
      )}

  {/* Notifications panel (quick access in modal) */}
  <MaterialCard sx={{ mb: 2, p: 2, backgroundColor: 'var(--color-surface-variant)' }}>
        <h3 className="m-0 mb-2">ðŸ”” Notifications</h3>
        <div className="flex flex-col gap-2">
          <div className="flex gap-2">
            <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={() => updateNotificationSettings({ desktopNotifications: !unifiedSettings.notifications.desktopNotifications })}>Toggle Desktop</button>
            <button className="px-3 py-1.5 bg-primary text-on-primary border border-primary rounded text-sm font-medium transition-colors hover:bg-primary-container" onClick={() => updateNotificationSettings({ soundNotifications: !unifiedSettings.notifications.soundNotifications })}>Toggle Sound</button>
          </div>
          <div>
            <MaterialMultiSelect label="Player Join Notifications" value={unifiedSettings.notifications.playerJoinNotifications} options={notificationTypeOptions} onChange={(vals) => updateNotificationSettings({ playerJoinNotifications: vals as any })} />
            <MaterialMultiSelect label="Cataclysm Notifications" value={unifiedSettings.notifications.cataclysmNotifications} options={notificationTypeOptions} onChange={(vals) => updateNotificationSettings({ cataclysmNotifications: vals as any })} />
          </div>
        </div>
      </MaterialCard>

      {/* Category Buttons - Compact Single Row */}
      <div className="flex gap-1.5 mb-4 justify-center flex-wrap">
        {categories.map(category => {
          const IconComponent = category.icon;
          return (
            <CategoryButton
              key={category.id}
              id={category.id}
              Icon={IconComponent}
              onClick={() => openModal(category.id)}
              buttonRef={(el) => buttonRefs.current[category.id] = el}
              colorToken={category.token}
            />
          );
        })}
      </div>

      {/* Overview Modal */}
      <MaterialPopover
        open={activeModal === 'overview'}
        onClose={closeModal}
        anchorEl={buttonRefs.current.overview}
        fullHeight={true}
        anchorOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'left',
        }}
      >
        <OverviewModal onClose={closeModal} />
      </MaterialPopover>

      {/* Gameplay Modal */}
      <MaterialPopover
        open={activeModal === 'gameplay'}
        onClose={closeModal}
        anchorEl={buttonRefs.current.gameplay}
        fullHeight={true}
        anchorOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'left',
        }}
      >
        <GameplayModal onClose={closeModal} />
      </MaterialPopover>

      {/* Audio Modal */}
      <MaterialPopover
        open={activeModal === 'audio'}
        onClose={closeModal}
        anchorEl={buttonRefs.current.audio}
        fullHeight={true}
        anchorOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'left',
        }}
      >
        <AudioModal onClose={closeModal} />
      </MaterialPopover>

      {/* Visual Modal */}
      <MaterialPopover
        open={activeModal === 'visual'}
        onClose={closeModal}
        anchorEl={buttonRefs.current.visual}
        fullHeight={true}
        anchorOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'left',
        }}
      >
        <VisualModal onClose={closeModal} />
      </MaterialPopover>

      {/* World Modal */}
      <MaterialPopover
        open={activeModal === 'world'}
        onClose={closeModal}
        anchorEl={buttonRefs.current.world}
        fullHeight={true}
        anchorOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'left',
        }}
      >
        <WorldModal onClose={closeModal} />
      </MaterialPopover>

      {/* Actions Modal */}
      <MaterialPopover
        open={activeModal === 'actions'}
        onClose={closeModal}
        anchorEl={buttonRefs.current.actions}
        fullHeight={true}
        anchorOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'left',
        }}
      >
        <ActionsModal onClose={closeModal} />
      </MaterialPopover>
    </div>
  );
};

export default UnifiedSettingsMenuModal;
</file>

<file path="packages/frontend/src/components/sidebar/SpectatorSidebar.tsx">
import React from 'react';
import { Link } from 'react-router-dom';
import { useGameStore } from '../../stores/gameStore';
import { COLORS } from '../../utils/tokens';

interface SpectatorSidebarProps {
  className?: string;
}

const SpectatorSidebar: React.FC<SpectatorSidebarProps> = ({ className }) => {
  const { gameWorld, currentPlayer } = useGameStore();

  return (
    <div className={[className || '', 'h-full flex flex-col overflow-auto font-inter'].join(' ').trim()}>
      {/* Header */}
      <div className="p-4 border-b border-[rgba(196,167,231,0.2)] bg-[rgba(25,23,36,0.8)]">
        <h2 className="text-text-primary text-lg font-semibold m-0 flex items-center gap-2">ðŸ‘ï¸ Spectate Mode</h2>
        <p className="text-text-secondary text-sm mt-1">Watching all players and world activity</p>
      </div>

      {/* World Overview */}
      <div className="p-4 space-y-4">
        <div className="bg-[rgba(25,23,36,0.8)] backdrop-blur-md border border-[rgba(196,167,231,0.2)] rounded-lg mb-4">
          <div className="p-4">
            <h3 className="text-text-primary text-sm font-semibold mb-3 flex items-center gap-2">ðŸŒ World Status</h3>
            <div className="grid grid-cols-2 gap-2 text-sm">
              <div className="text-text-secondary"><strong>Phase:</strong> {gameWorld?.phase || 'Unknown'}</div>
              <div className="text-text-secondary"><strong>Players:</strong> {gameWorld?.players?.length || 0}</div>
              <div className="text-text-secondary"><strong>NPCs:</strong> {gameWorld?.npcs?.length || 0}</div>
              <div className="text-text-secondary"><strong>Items:</strong> {gameWorld?.items?.length || 0}</div>
              <div className="text-text-secondary col-span-2"><strong>World Age:</strong> {gameWorld?.worldAge || 0} cycles</div>
              <div className="text-text-secondary col-span-2"><strong>Cataclysm:</strong> {gameWorld?.cataclysmCircle?.isActive ? 'Active' : 'Inactive'}</div>
            </div>
          </div>
        </div>

        {/* All Players */}
        <div className="bg-[rgba(25,23,36,0.8)] backdrop-blur-md border border-[rgba(196,167,231,0.2)] rounded-lg mb-4">
          <div className="p-4">
            <h3 className="text-text-primary text-sm font-semibold mb-3 flex items-center gap-2">ðŸ‘¥ All Players ({gameWorld?.players?.length || 0})</h3>
            <div className="flex flex-col gap-2">
              {gameWorld?.players?.map(player => (
                <Link to={`/profile/${player.id}`} key={player.id} className={
                  `rounded-md p-3 border text-sm ` +
                  (currentPlayer?.id === player.id
                    ? 'bg-[rgba(196,167,231,0.1)] border-[rgba(196,167,231,0.3)]'
                    : 'bg-[rgba(255,255,255,0.03)] border-[rgba(255,255,255,0.06)]')
                }>
                  <div className="flex items-center gap-2 mb-2">
                    <span className="text-lg">{player.avatar}</span>
                    <div>
                      <div className="text-text-primary font-medium text-sm">
                        {player.name}
                        {currentPlayer?.id === player.id && (
                          <span className="ml-2 text-[0.7rem] h-4 inline-flex items-center px-2 rounded bg-[rgba(196,167,231,0.2)] text-text-primary">You</span>
                        )}
                      </div>
                      <div className="text-text-secondary text-xs">Level {player.level} {player.class}</div>
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-1 text-xs">
                    <div className="text-text-secondary"><strong>HP:</strong> {player.health}/{player.stats?.maxHp || 100}</div>
                    <div className="text-text-secondary"><strong>Pos:</strong> {player.position.x},{player.position.y}</div>
                    <div className="text-text-secondary"><strong>XP:</strong> {player.experience}</div>
                    <div className="text-text-secondary"><strong>Buffs:</strong> {player.buffs?.length ? player.buffs.join(', ') : 'None'}</div>
                  </div>
                </Link>
              )) || (
                <div className="text-text-secondary text-center p-5 text-sm">No players in game</div>
              )}
            </div>
          </div>
        </div>

        {/* NPCs */}
        <div className="bg-[rgba(25,23,36,0.8)] backdrop-blur-md border border-[rgba(196,167,231,0.2)] rounded-lg mb-4">
          <div className="p-4">
            <h3 className="text-text-primary text-sm font-semibold mb-3 flex items-center gap-2">ðŸ¤– NPCs ({gameWorld?.npcs?.length || 0})</h3>
            <div className="flex flex-col gap-2">
              {gameWorld?.npcs?.slice(0, 10).map(npc => (
                <div key={npc.id} className="bg-[rgba(255,255,255,0.03)] rounded-md p-2 text-xs">
                  <div className="text-text-primary font-medium">{npc.name} ({npc.type})</div>
                  <div className="text-text-secondary">Pos: {npc.position.x},{npc.position.y} | HP: {npc.stats.hp}</div>
                </div>
              )) || (
                <div className="text-text-secondary text-center p-2 text-xs">No NPCs</div>
              )}
              {(gameWorld?.npcs?.length || 0) > 10 && (
                <div className="text-text-secondary text-center text-xs mt-2">... and {(gameWorld?.npcs?.length || 0) - 10} more</div>
              )}
            </div>
          </div>
        </div>

        {/* Items */}
        <div className="bg-[rgba(25,23,36,0.8)] backdrop-blur-md border border-[rgba(196,167,231,0.2)] rounded-lg">
          <div className="p-4">
            <h3 className="text-text-primary text-sm font-semibold mb-3 flex items-center gap-2">ðŸŽ’ Items ({gameWorld?.items?.length || 0})</h3>
            <div className="flex flex-col gap-2">
              {gameWorld?.items?.slice(0, 15).map(item => (
                <div key={item.id} className="bg-[rgba(255,255,255,0.03)] rounded-md p-2 text-xs">
                  <div className="text-text-primary font-medium">{item.name} ({item.type})</div>
                  <div className="text-text-secondary">Pos: {item.position.x},{item.position.y} | Rarity: {item.rarity}</div>
                </div>
              )) || (
                <div className="text-text-secondary text-center p-2 text-xs">No items</div>
              )}
              {(gameWorld?.items?.length || 0) > 15 && (
                <div className="text-text-secondary text-center text-xs mt-2">... and {(gameWorld?.items?.length || 0) - 15} more</div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SpectatorSidebar;
</file>

<file path="packages/frontend/src/components/CharacterBuilder.tsx">
import React, { useState, useEffect } from 'react';
import { PlayerClass, Stats } from 'shared';
import { CLASS_INFO, GAME_CONFIG } from 'shared';
import { MaterialCard, MaterialButton, MaterialDialog } from './index';
import SVGAvatarUpload from './character/SVGAvatarUpload';
// EmojiPicker removed per request: full svgmoji handling will be used via server
import { gsap } from 'gsap';
import { useRef } from 'react';
import { assetConverter } from '../services/assetConverter';
import { COLORS } from '../utils/tokens';
import isUnicodeSupported from 'is-unicode-supported';

interface CharacterBuilderProps {
  isOpen: boolean;
  onClose: () => void;
  onJoinGame: (characterData: {
    displayName: string;
    class: PlayerClass;
    avatar: string;
  }) => void;
  currentPlayer?: {
    displayName: string;
    class: PlayerClass;
    avatar: string;
  } | null;
}

const CharacterBuilder: React.FC<CharacterBuilderProps> = ({
  isOpen,
  onClose,
  onJoinGame,
  currentPlayer
}) => {
  const [selectedClass, setSelectedClass] = useState<PlayerClass>(currentPlayer?.class || PlayerClass.KNIGHT);
  const [selectedAvatar, setSelectedAvatar] = useState<string>(
    currentPlayer?.avatar || 'ðŸ‘¤'
  );
  const [displayName, setDisplayName] = useState<string>(
    currentPlayer?.displayName || ''
  );
  const [customAvatar, setCustomAvatar] = useState<{
    original: string;
    rough: string;
  } | null>(null);

  const [nameError, setNameError] = useState<string>('');
  const [isAnimating, setIsAnimating] = useState(false);
  const [useHandDrawn, setUseHandDrawn] = useState(false);
  const [isConvertingEmoji, setIsConvertingEmoji] = useState(false);
  const avatarRef = useRef<HTMLDivElement | null>(null);
  const previewRef = useRef<HTMLDivElement | null>(null);
  const [roughPreset, setRoughPreset] = useState<'sketch' | 'cartoon' | 'technical' | 'wild' | null>(null);
  const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null);
  const [showUploadModal, setShowUploadModal] = useState(false);

  // Validate name input
  const validateName = (name: string): string => {
    if (!name.trim()) {
      return 'Character name is required';
    }
    if (name.length < 2) {
      return 'Name must be at least 2 characters';
    }
    if (name.length > 20) {
      return 'Name must be less than 20 characters';
    }
    if (!/^[a-zA-Z0-9\s\-_]+$/.test(name)) {
      return 'Name can only contain letters, numbers, spaces, hyphens, and underscores';
    }
    return '';
  };

  // Handle name change with validation
  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newName = e.target.value;
    setDisplayName(newName);
    const error = validateName(newName);
    setNameError(error);
  };

  // Persist hand-drawn preference and preset in localStorage
  useEffect(() => {
    try {
      const storedHand = localStorage.getItem('chatterealm:handdrawn');
      const storedPreset = localStorage.getItem('chatterealm:handdrawn:preset');
      if (storedHand !== null) setUseHandDrawn(storedHand === 'true');
      if (storedPreset) setRoughPreset(storedPreset as any);
    } catch (e) {
      // ignore
    }
  }, []);

  useEffect(() => {
    try {
      localStorage.setItem('chatterealm:handdrawn', String(useHandDrawn));
    } catch (e) {}
  }, [useHandDrawn]);

  useEffect(() => {
    try {
      if (roughPreset) localStorage.setItem('chatterealm:handdrawn:preset', roughPreset);
      else localStorage.removeItem('chatterealm:handdrawn:preset');
    } catch (e) {}
  }, [roughPreset]);

  // Get stats for selected class
  const getClassStats = (playerClass: PlayerClass): Stats => {
    return GAME_CONFIG.baseStats[playerClass];
  };

  // Handle class selection with animation
  const handleClassSelect = (playerClass: PlayerClass) => {
    if (playerClass === selectedClass) return;

    setIsAnimating(true);
    gsap.to(previewRef.current, {
      scale: 0.9,
      duration: 0.2,
      yoyo: true,
      repeat: 1,
      ease: 'power2.inOut',
      onComplete: () => {
        setSelectedClass(playerClass);
        setIsAnimating(false);
      }
    });
  };

  // Handle custom avatar selection
  const handleCustomAvatarSelect = (originalSvg: string, roughSvg: string) => {
    setCustomAvatar({ original: originalSvg, rough: roughSvg });
    setSelectedAvatar('custom');
  };

  // Convert emoji to hand-drawn SVG with improved error handling
  useEffect(() => {
    let mounted = true;
    let timeoutId: NodeJS.Timeout;

    const convertClientRough = async (emoji: string) => {
      if (!useHandDrawn || emoji === 'custom') return;

      setIsConvertingEmoji(true);

      try {
        // Set a timeout for the conversion
        timeoutId = setTimeout(() => {
          if (mounted) {
            console.warn('Emoji conversion timed out');
            setIsConvertingEmoji(false);
          }
        }, 10000); // 10 second timeout

        // Try to get SVG from svgmoji
        const svgmoji = await import('@svgmoji/noto');
        let rawSvg: string | null = null;

        // Try different access patterns for svgmoji
        try {
          if (typeof (svgmoji as any).get === 'function') {
            rawSvg = (svgmoji as any).get(emoji);
          }
        } catch {}

        if (!rawSvg) {
          try {
            rawSvg = (svgmoji as any).toSvg?.(emoji);
          } catch {}
        }

        if (!rawSvg) {
          const def = (svgmoji as any).default || (svgmoji as any);
          const codepoints = Array.from(emoji).map(c => c.codePointAt(0)!.toString(16).toLowerCase());
          const key = `u${codepoints.join('_')}`;
          rawSvg = def?.[key] || def?.[codepoints.join('_')];
        }

        if (!rawSvg) {
          throw new Error('SVG not found for emoji');
        }

        if (!mounted) return;

        // Convert SVG to rough version
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(rawSvg, 'image/svg+xml');
        const svgElement = svgDoc.documentElement as unknown as SVGSVGElement;

        if (!svgElement || svgElement.tagName !== 'svg') {
          throw new Error('Invalid SVG format');
        }

        const container = document.createElement('div');
        const { Svg2Roughjs, OutputType } = await import('svg2roughjs');
        const converter = new (Svg2Roughjs as any)(container, OutputType.SVG);

        converter.svg = svgElement;

        // Apply preset-based roughness
        if (roughPreset === 'sketch') converter.roughConfig.roughness = 1.2;
        else if (roughPreset === 'cartoon') converter.roughConfig.roughness = 0.6;
        else if (roughPreset === 'technical') converter.roughConfig.roughness = 0.2;
        else if (roughPreset === 'wild') converter.roughConfig.roughness = 1.8;
        else converter.roughConfig.roughness = 1.0; // default

        const result: any = await converter.sketch();
        let resultSvg = '';

        if (result && result instanceof SVGSVGElement) {
          resultSvg = new XMLSerializer().serializeToString(result);
        } else if (container.innerHTML) {
          resultSvg = container.innerHTML;
        }

        if (!mounted) return;

        if (resultSvg) {
          setCustomAvatar({ original: rawSvg, rough: resultSvg });
          setSelectedAvatar('custom');
        } else {
          throw new Error('Conversion failed to produce SVG');
        }

      } catch (err) {
        console.warn('Client-side hand-drawn conversion failed for emoji', emoji, err);
        // Fallback: use original emoji if conversion fails
        if (mounted) {
          setSelectedAvatar(emoji);
        }
      } finally {
        if (mounted) {
          setIsConvertingEmoji(false);
          clearTimeout(timeoutId);
        }
      }
    };

    // Run conversion when conditions change
    if (useHandDrawn && selectedAvatar && selectedAvatar !== 'custom') {
      convertClientRough(selectedAvatar);
    }

    return () => {
      mounted = false;
      clearTimeout(timeoutId);
    };
  }, [useHandDrawn, selectedAvatar, roughPreset]);

  // Re-fetch converted SVG when preset changes (if hand-drawn is active)
  useEffect(() => {
    if (!useHandDrawn) return;
    if (!selectedAvatar || selectedAvatar === 'custom') return;

    const reFetchWithPreset = async () => {
      setIsConvertingEmoji(true);
      try {
        const svg = await assetConverter.fetchEmojiSvg(selectedAvatar, 'svgmoji', {
          rough: true,
          preset: roughPreset || undefined
        });

        if (svg) {
          setCustomAvatar({ original: svg, rough: svg });
          setSelectedAvatar('custom');
        }
      } catch (err) {
        console.warn('Preset re-fetch failed', err);
        // Keep current avatar if re-fetch fails
      } finally {
        setIsConvertingEmoji(false);
      }
    };

    reFetchWithPreset();
  }, [roughPreset]);

  // Animate avatar swaps
  useEffect(() => {
    const el = avatarRef.current;
    if (!el) return;

    const tl = gsap.timeline();
    tl.to(el, { duration: 0.18, scale: 0.85, rotation: -6, opacity: 0.4, ease: 'power2.in' });
    tl.to(el, { duration: 0.45, scale: 1, rotation: 0, opacity: 1, ease: 'elastic.out(1, 0.6)' });

    return () => { tl.kill(); };
  }, [selectedAvatar, customAvatar]);

  // Handle joining game
  const handleJoinGame = () => {
    const nameValidationError = validateName(displayName);
    if (nameValidationError) {
      setNameError(nameValidationError);
      return;
    }

    onJoinGame({
      displayName: displayName.trim(),
      class: selectedClass,
      avatar: selectedAvatar === 'custom' && customAvatar ? customAvatar.rough : selectedAvatar
    });
  };

  const selectedClassInfo = CLASS_INFO[selectedClass];
  const selectedStats = getClassStats(selectedClass);

// Emoji popover state handled inline below; no block-level picker to avoid expanding modal

  return (
    <MaterialDialog
      open={isOpen}
      onClose={onClose}
      title="Create Your Character"
      maxWidth="md"
      fullWidth
    >
      <div className="character-builder p-3 max-w-4xl w-full" style={{
        background: 'linear-gradient(135deg, rgba(32,28,36,0.95) 0%, rgba(42,38,46,0.95) 100%)',
        borderRadius: '16px'
      }}>
        {/* Header */}
        <div className="text-center mb-3">
          <h2 className="text-2xl font-bold text-white mb-2">âš”ï¸ Create Your Character</h2>
          <p className="text-gray-400 text-sm">Choose your class, customize your appearance, and join the adventure</p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
          {/* Left Column - Character Preview */}
          <div className="space-y-4">
            <MaterialCard sx={{
              padding: '12px',
              borderRadius: '12px',
              background: 'rgba(32,28,36,0.8)',
              boxShadow: '0 8px 30px rgba(0,0,0,0.3)'
            }}>
              <div className="flex flex-col items-center gap-4">
                {/* Avatar Preview */}
                <div
                  ref={avatarRef}
                  className={`w-40 h-40 rounded-full flex items-center justify-center bg-gradient-to-br from-purple-500/20 to-blue-500/20 border-2 border-purple-400/50 emoji-font transition-all duration-200 ${isAnimating ? 'scale-105' : ''}`}
                >
                  {selectedAvatar === 'custom' && customAvatar ? (
                    <div className="w-full h-full flex items-center justify-center" dangerouslySetInnerHTML={{ __html: (useHandDrawn && customAvatar.rough) ? customAvatar.rough : customAvatar.original }} />
                  ) : (
                    <span className="text-5xl leading-none">{selectedAvatar}</span>
                  )}
                </div>

                {/* Character Info */}
                <div className="text-center">
                  <div className="text-lg font-semibold text-white">{displayName || 'Your Name'}</div>
                  <div className="text-sm text-purple-300">{selectedClassInfo.name}</div>
                  <div className="text-xs text-gray-400 mt-1">{selectedClassInfo.description}</div>
                </div>

                {/* Conversion status */}
                {isConvertingEmoji && (
                  <div className="flex items-center gap-2 text-xs text-gray-300">
                    <div className="w-3 h-3 rounded-full border-2 border-white/60 animate-spin" />
                    <div>Converting previewâ€¦</div>
                  </div>
                )}
              </div>
            </MaterialCard>

            {/* Stats Preview */}
            <MaterialCard sx={{
              padding: '12px',
              borderRadius: '12px',
              background: 'rgba(32,28,36,0.6)',
              boxShadow: '0 4px 20px rgba(0,0,0,0.2)'
            }}>
              <h3 className="text-sm font-semibold text-white mb-3">Base Stats</h3>
              <div className="grid grid-cols-2 gap-2 text-xs">
                <div className="flex justify-between">
                  <span className="text-gray-300">HP:</span>
                  <span className="text-green-400">{selectedStats.hp}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-300">Attack:</span>
                  <span className="text-red-400">{selectedStats.attack}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-300">Defense:</span>
                  <span className="text-blue-400">{selectedStats.defense}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-300">Speed:</span>
                  <span className="text-yellow-400">{selectedStats.speed}</span>
                </div>
              </div>
            </MaterialCard>
          </div>

          {/* Right Column - Customization Options */}
          <div className="space-y-4">
            {/* Name Input */}
            <MaterialCard sx={{
              padding: '12px',
              borderRadius: '12px',
              background: 'rgba(32,28,36,0.6)',
              boxShadow: '0 4px 20px rgba(0,0,0,0.2)'
            }}>
              <label className="block text-sm font-medium mb-2" style={{ color: COLORS.text.primary }}>Character Name</label>
              <input
                type="text"
                value={displayName}
                onChange={handleNameChange}
                placeholder="Enter your character name"
                className={`w-full px-4 py-3 border-2 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 transition-all duration-200 ${
                  nameError ? 'border-red-500/60 focus:border-red-400 focus:ring-red-500/30' : 'border-gray-600/60 hover:border-gray-500/60 focus:ring-purple-500/50 focus:border-purple-400'
                }`}
                style={{
                  backgroundColor: COLORS.backgroundMedium,
                  color: COLORS.text.primary,
                  borderColor: nameError ? COLORS.error : COLORS.borderGray
                }}
                maxLength={20}
              />
              <div className="flex justify-between items-center mt-1">
                <div className={`text-xs ${nameError ? 'text-red-400' : ''}`} style={{ color: nameError ? COLORS.error : COLORS.text.secondary }}>
                  {nameError || `${displayName.length}/20 characters`}
                </div>
                {nameError && (
                  <div className="text-xs text-red-400 flex items-center gap-1">
                    <span>âš ï¸</span>
                    Error
                  </div>
                )}
              </div>
            </MaterialCard>            {/* Class Selection */}
            <MaterialCard sx={{
              padding: '12px',
              borderRadius: '12px',
              background: 'rgba(32,28,36,0.6)',
              boxShadow: '0 4px 20px rgba(0,0,0,0.2)'
            }}>
              <h3 className="text-sm font-semibold text-white mb-3">Choose Your Class</h3>
              <div className="grid grid-cols-1 gap-2">
                {(Object.values(PlayerClass) as PlayerClass[]).map((playerClass) => {
                  const info = CLASS_INFO[playerClass];
                  const active = selectedClass === playerClass;
                  return (
                    <button
                      key={playerClass as string}
                      onClick={() => { setSelectedClass(playerClass); handleClassSelect(playerClass); }}
                      className={`w-full p-4 rounded-lg flex items-center gap-3 text-left transition-all duration-200 border-2 ${
                        active
                          ? 'border-purple-400/60 bg-gradient-to-r from-purple-600/20 to-purple-500/10 shadow-lg'
                          : 'border-gray-600/60 bg-gray-800/40 hover:border-purple-400/40 hover:bg-purple-500/5'
                      }`}
                    >
                      <div className="text-2xl">{info.emoji}</div>
                      <div className="flex-1">
                        <div className="text-sm font-medium text-white">{info.name}</div>
                        <div className="text-xs text-gray-400">{info.description}</div>
                      </div>
                      {active && <div className="text-purple-400">âœ“</div>}
                    </button>
                  );
                })}
              </div>
            </MaterialCard>

            {/* Avatar Selection */}
            <MaterialCard sx={{
              padding: '12px',
              borderRadius: '12px',
              background: 'rgba(32,28,36,0.6)',
              boxShadow: '0 4px 20px rgba(0,0,0,0.2)'
            }}>
              <h3 className="text-sm font-semibold text-white mb-3">Choose Avatar</h3>

              {/* Quick Emojis */}
              <div className="mb-4">
                <div className="text-xs text-gray-400 mb-2">Quick Select</div>
                <div className="grid grid-cols-6 gap-2">
                  {['ðŸ˜€','ðŸ˜Ž','ðŸ§™','ðŸ›¡ï¸','ðŸ‰','âš”ï¸','ðŸ¦„','ðŸ‘‘','ðŸŒŸ','ðŸ”¥'].map((e) => (
                    <button
                      key={e}
                      onClick={() => setSelectedAvatar(e)}
                      className={`w-10 h-10 rounded-lg flex items-center justify-center text-xl transition-all duration-200 border-2 ${
                        selectedAvatar === e
                          ? 'bg-gradient-to-br from-purple-500/20 to-purple-600/10 border-purple-400/60 scale-110 shadow-lg'
                          : 'bg-gray-800/60 border-gray-600/60 hover:border-purple-400/40 hover:bg-purple-500/5 hover:scale-105'
                      }`}
                      aria-label={`Select ${e}`}
                    >{e}</button>
                  ))}
                </div>
              </div>

              {/* Custom Emoji Input */}
              <div className="mb-4">
                <div className="text-xs mb-2" style={{ color: COLORS.text.secondary }}>Or Type Your Own Emoji</div>
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={selectedAvatar}
                    onChange={(e) => {
                      const value = e.target.value;
                      // Allow single emoji or empty string
                      if (isUnicodeSupported(value) || value === '') {
                        setSelectedAvatar(value);
                      }
                    }}
                    placeholder="Type emoji here..."
                    className="flex-1 px-4 py-3 border-2 border-gray-600/60 rounded-lg text-lg font-medium focus:outline-none focus:ring-2 focus:ring-purple-500/50 focus:border-purple-400 hover:border-gray-500/60 transition-all duration-200"
                    style={{
                      backgroundColor: COLORS.backgroundMedium,
                      color: COLORS.text.primary,
                      borderColor: COLORS.borderGray
                    }}
                  />
                  <div className="w-12 h-10 rounded-lg flex items-center justify-center text-xl border-2"
                       style={{
                         backgroundColor: COLORS.backgroundMedium,
                         borderColor: COLORS.borderGray
                       }}>
                    {selectedAvatar || 'ðŸ˜€'}
                  </div>
                </div>
                <div className="text-xs mt-1" style={{ color: COLORS.text.tertiary }}>
                  Type or paste any emoji (max 1 character)
                </div>
              </div>

              {/* Hand-drawn Options */}
              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <label className="text-sm font-medium text-gray-300">Hand-drawn Style</label>
                  <div className="relative">
                    <input
                      type="checkbox"
                      id="hand-drawn-toggle"
                      checked={useHandDrawn}
                      onChange={(e) => setUseHandDrawn(e.target.checked)}
                      className="sr-only"
                    />
                    <label
                      htmlFor="hand-drawn-toggle"
                      className={`w-12 h-6 rounded-full cursor-pointer transition-all duration-200 ${
                        useHandDrawn
                          ? 'bg-gradient-to-r from-purple-500 to-purple-600'
                          : 'bg-gray-600/60 hover:bg-gray-500/60'
                      }`}
                    >
                      <span
                        className={`absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow-md transition-transform duration-200 ${
                          useHandDrawn ? 'translate-x-6' : 'translate-x-0'
                        }`}
                      />
                    </label>
                  </div>
                </div>

                {useHandDrawn && (
                  <div>
                    <div className="text-xs text-gray-400 mb-2">Style Preset</div>
                    <div className="grid grid-cols-2 gap-2">
                      {[
                        { key: 'sketch', label: 'Sketch', emoji: 'âœï¸' },
                        { key: 'cartoon', label: 'Cartoon', emoji: 'ðŸŽ¨' },
                        { key: 'technical', label: 'Technical', emoji: 'ðŸ“' },
                        { key: 'wild', label: 'Wild', emoji: 'ðŸŒªï¸' }
                      ].map((preset) => (
                        <button
                          key={preset.key}
                          onClick={() => setRoughPreset(preset.key as any)}
                          className={`p-3 rounded-lg text-xs font-medium transition-all duration-200 border-2 ${
                            roughPreset === preset.key
                              ? 'bg-gradient-to-br from-purple-500/20 to-purple-600/10 border-purple-400/60 text-purple-200 shadow-lg'
                              : 'bg-gray-800/40 border-gray-600/60 text-gray-300 hover:border-purple-400/40 hover:bg-purple-500/5'
                          }`}
                        >
                          <div className="text-center">
                            <div className="text-lg mb-1">{preset.emoji}</div>
                            <div className="text-white font-semibold">{preset.label}</div>
                          </div>
                        </button>
                      ))}
                    </div>
                  </div>
                )}

                <div className="pt-2 border-t border-gray-600">
                  <MaterialButton
                    onClick={() => setShowUploadModal(true)}
                    variant="outlined"
                    fullWidth
                    sx={{
                      borderColor: 'rgba(255,255,255,0.2)',
                      color: 'white',
                      '&:hover': {
                        borderColor: 'rgba(168,85,247,0.5)',
                        backgroundColor: 'rgba(168,85,247,0.1)'
                      }
                    }}
                  >
                    Upload Custom SVG
                  </MaterialButton>
                </div>
              </div>
            </MaterialCard>
          </div>
        </div>

        {/* Action buttons */}
        <div className="flex justify-end gap-3 mt-4 pt-3 border-t border-gray-600">
          <MaterialButton
            onClick={onClose}
            variant="outlined"
            sx={{
              borderColor: 'rgba(255,255,255,0.2)',
              color: 'white',
              '&:hover': {
                borderColor: 'rgba(255,255,255,0.4)',
                backgroundColor: 'rgba(255,255,255,0.05)'
              }
            }}
          >
            Cancel
          </MaterialButton>
          <MaterialButton
            onClick={handleJoinGame}
            disabled={!displayName.trim() || !!nameError}
            variant="contained"
            sx={{
              background: 'linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%)',
              '&:hover': {
                background: 'linear-gradient(135deg, #7c3aed 0%, #9333ea 100%)'
              },
              '&:disabled': {
                background: 'rgba(107,114,128,0.5)',
                color: 'rgba(255,255,255,0.5)'
              }
            }}
          >
            Join Adventure
          </MaterialButton>
        </div>
      </div>

      {/* Upload modal */}
      {showUploadModal && (
        <MaterialDialog
          open={showUploadModal}
          onClose={() => setShowUploadModal(false)}
          title="Upload Custom SVG Avatar"
          maxWidth="sm"
          fullWidth
        >
          <div className="p-4">
            <SVGAvatarUpload
              onAvatarSelect={(orig, rough) => {
                handleCustomAvatarSelect(orig, rough);
                setShowUploadModal(false);
              }}
            />
          </div>
        </MaterialDialog>
      )}
    </MaterialDialog>
  );
};

export default CharacterBuilder;
</file>

<file path="packages/frontend/src/components/index.ts">
// Material UI Components
export { default as MaterialAppBar } from './layout/MaterialAppBar';
export { default as MaterialDrawer } from './ui/MaterialDrawer';
export { default as MaterialCard } from './ui/MaterialCard';
export { default as MaterialButton } from './ui/MaterialButton';
export { default as MaterialPaper } from './ui/MaterialPaper';
export { default as MaterialDialog } from './ui/MaterialDialog';
export { default as MaterialChip } from './ui/MaterialChip';
export { default as MaterialTooltip } from './ui/MaterialTooltip';
export { default as MaterialPopover } from './ui/MaterialPopover';
export { default as MaterialIcon } from './ui/MaterialIcon';

// Existing components
export { default as ResponsiveLayout } from './layout/ResponsiveLayout';
export { default as GameLayout } from './layout/GameLayout';
export { default as GameCanvas } from './GameCanvas/GameCanvas';
export { default as NotificationSystem } from './notifications/NotificationSystem';
export { default as EnhancedPlayerStatus } from './player/EnhancedPlayerStatus';
export { default as RightSidebar } from './layout/RightSidebar';
export { default as PlayerSidebar } from './sidebar/PlayerSidebar';
export { default as SpectatorSidebar } from './sidebar/SpectatorSidebar';
export { default as DevSidebar } from './sidebar/DevSidebar';
export { default as Sidebar } from './sidebar/Sidebar';
export { default as UnifiedSettingsMenu } from './settings/UnifiedSettingsMenu';
export { default as ModeNavigation } from './layout/ModeNavigation';
export { default as CharacterBuilder } from './CharacterBuilder';
export { default as SVGAssetDemo } from './SVGAssetDemo';
export { default as SVGAvatarUpload } from './character/SVGAvatarUpload';

// Animation Components
export { AnimationDemo } from './AnimationDemo';
export * from './animations';
</file>

<file path="packages/frontend/src/hooks/useChat.ts">
import { useState, useEffect, useRef } from 'react';
import { chatService } from '../services/chat/ChatService';
import { messageHandler } from '../services/chat/MessageHandler';
import { moderationService } from '../services/chat/ModerationService';
import { ChatMessage, Player } from '../types/chat';
import NaturalLanguageCommandParser from '../services/commandParser';

interface UseChatHook {
  messages: ChatMessage[];
  inputMessage: string;
  setInputMessage: (message: string) => void;
  username: string;
  setUsername: (username: string) => void;
  displayName: string;
  setDisplayName: (displayName: string) => void;
  channelPoints: number;
  setChannelPoints: (points: number) => void;
  isConnected: boolean;
  sendChatCommand: () => Promise<void>;
  handleKeyPress: (e: React.KeyboardEvent) => void;
  players: Player[];
  setInputMessageAndFocus: (message: string) => void;
}

/**
 * Custom hook for managing chat functionality in the game.
 *
 * This hook provides a complete chat interface including message handling,
 * user input management, connection status, and player list updates.
 *
 * @param onWorldUpdate - Callback function called when the player list is updated
 * @returns Object containing chat state and control functions
 *
 * @example
 * ```tsx
 * const {
 *   messages,
 *   inputMessage,
 *   setInputMessage,
 *   sendChatCommand,
 *   isConnected
 * } = useChat((players) => {
 *   console.log('Players updated:', players);
 * });
 * ```
 */
export const useChat = (onWorldUpdate: (players: Player[]) => void): UseChatHook => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputMessage, setInputMessage] = useState('');
  const [username, setUsername] = useState('testuser');
  const [displayName, setDisplayName] = useState('Test User');
  const [channelPoints, setChannelPoints] = useState(1000);
  const [isConnected, setIsConnected] = useState(chatService.isConnected);
  const [players, setPlayers] = useState<Player[]>([]);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    messageHandler.setUpdateMessagesCallback(setMessages);
    chatService.setOnMessageReceived(messageHandler.handleNewMessage.bind(messageHandler));
    chatService.setOnWorldUpdateReceived((worldPlayers) => {
      setPlayers(worldPlayers);
      onWorldUpdate(worldPlayers);
    });

    setIsConnected(chatService.isConnected); // Initial connection status
    return () => {
      chatService.closeConnection();
    };
  }, [onWorldUpdate]);

  const sendChatCommand = async () => {
    if (!inputMessage.trim()) return;

    const isFlagged = await moderationService.isMessageFlagged(inputMessage);
    if (isFlagged) {
      messageHandler.addErrorMessage(
        'Your message was flagged as inappropriate and was not sent.',
      );
      return;
    }

    messageHandler.addSentMessage(inputMessage, username, displayName);
    const commandParser = new NaturalLanguageCommandParser();
    const command = await commandParser.parseCommand(inputMessage);
    let success = false;
    if (command) {
      success = await chatService.sendGameCommand(username, displayName, command, channelPoints);
    } else {
      success = await chatService.sendChatCommand(
        username,
        displayName,
        inputMessage,
        channelPoints,
      );
    }

    if (success) {
      setInputMessage('');
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      sendChatCommand();
    }
  };

  const setInputMessageAndFocus = (message: string) => {
    setInputMessage(message);
    // Focus the input field after setting the message
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return {
    messages,
    inputMessage,
    setInputMessage,
    username,
    setUsername,
    displayName,
    setDisplayName,
    channelPoints,
    setChannelPoints,
    isConnected,
    sendChatCommand,
    handleKeyPress,
    players,
    setInputMessageAndFocus,
  };
};
</file>

<file path="packages/frontend/src/services/chat/ChatService.ts">
import { io, Socket } from 'socket.io-client';
import { ChatMessage, Player } from '../../types/chat';
import { GameCommand } from '@chatterealm/shared';

class ChatService {
  private socket: Socket;
  private readonly apiUrl: string;
  private onMessageReceived: ((message: ChatMessage) => void) | null = null;
  private onWorldUpdateReceived: ((players: Player[]) => void) | null = null;
  public isConnected: boolean = false;

  constructor(apiUrl: string = 'http://localhost:3002') {
    this.apiUrl = apiUrl;
    this.socket = io(this.apiUrl);
    this.setupSocketListeners();
  }

  private setupSocketListeners(): void {
    this.socket.on('connect', () => {
      console.log('ðŸŽ® [SOCKET] Connected to backend');
      this.isConnected = true;
    });

    this.socket.on('disconnect', () => {
      console.log('ðŸ”Œ [SOCKET] Disconnected from backend');
      this.isConnected = false;
    });

    this.socket.on('chat_message', (data: ChatMessage) => {
      console.log('ðŸ’¬ [SOCKET] Received chat message:', data);
      if (this.onMessageReceived) {
        this.onMessageReceived(data);
      }
    });

    this.socket.on('world_update', (worldData: any) => {
      console.log('ðŸŒ [SOCKET] Received world update:', {
        players: worldData.players?.length || 0,
        phase: worldData.phase
      });
      if (this.onWorldUpdateReceived) {
        this.onWorldUpdateReceived(worldData.players || []);
      }
    });
  }

  public setOnMessageReceived(callback: (message: ChatMessage) => void): void {
    this.onMessageReceived = callback;
  }

  public setOnWorldUpdateReceived(callback: (players: Player[]) => void): void {
    this.onWorldUpdateReceived = callback;
  }

  public async sendChatCommand(username: string, displayName: string, message: string, channelPoints: number): Promise<boolean> {
    try {
      const response = await fetch(`${this.apiUrl}/api/test/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username,
          displayName,
          message,
          channelPoints
        })
      });

      const data = await response.json();
      return data.success;
    } catch (error) {
      console.error('Error sending chat command:', error);
      return false;
    }
  }

  public async sendGameCommand(username: string, displayName: string, command: GameCommand, channelPoints: number): Promise<boolean> {
    try {
      const response = await fetch(`${this.apiUrl}/api/game/command`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username,
          displayName,
          command,
          channelPoints
        })
      });

      const data = await response.json();
      return data.success;
    } catch (error) {
      console.error('Error sending game command:', error);
      return false;
    }
  }

  public closeConnection(): void {
    this.socket.close();
  }
}

export const chatService = new ChatService();
</file>

<file path="packages/frontend/src/services/commandParser.ts">
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';
import { GameCommand, GameCommandSchema } from '@chatterealm/shared';

class NaturalLanguageCommandParser {
  async parseCommand(naturalLanguageInput: string): Promise<GameCommand | null> {
    try {
      const response = await fetch('/api/ai-proxy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gemini-pro',
          contents: [{
            role: 'user', parts: [{
              text: `Parse this game command: "${naturalLanguageInput}"

          Extract the command type and relevant parameters. Examples:
          - "walk 5 steps north" â†’ move command
          - "trade my 10 wood for 5 stone with PlayerX" â†’ trade command
          - "build a house at coordinates 10, 20 facing east" â†’ build command`}]}],
          config: {
            responseMimeType: 'application/json',
            responseSchema: zodToJsonSchema(GameCommandSchema),
          },
        }),
      });

      const parsedCommand = await response.json();
      return GameCommandSchema.parse(parsedCommand);
    } catch (error) {
      console.error('Failed to parse command:', error);
      return null;
    }
  }
}

export default new NaturalLanguageCommandParser();
</file>

<file path="packages/frontend/src/services/LayoutManagerService.ts">
// packages/frontend/src/services/LayoutManagerService.ts
import { Layouts } from 'react-grid-layout';
import { useLayoutStore } from '../stores/layoutStore';

const LAYOUT_STORAGE_KEY = 'chatter-realm-layout';

class LayoutManagerService {
  constructor() {
    this.loadLayout();

    // Subscribe to the store to save changes to localStorage
    useLayoutStore.subscribe(
      (state) => this.saveLayout(state.layouts)
    );
  }

  private saveLayout(layouts: Layouts) {
    try {
      const layoutsJson = JSON.stringify(layouts);
      localStorage.setItem(LAYOUT_STORAGE_KEY, layoutsJson);
    } catch (error) {
      console.error("Failed to save layout to localStorage", error);
    }
  }

  private loadLayout() {
    try {
      const layoutsJson = localStorage.getItem(LAYOUT_STORAGE_KEY);
      if (layoutsJson) {
        const loadedLayouts = JSON.parse(layoutsJson);
        // Initialize the store with the loaded layout
        useLayoutStore.getState().setLayouts(loadedLayouts);
      }
    } catch (error) {
      console.error("Failed to load layout from localStorage", error);
    }
  }
}

// Initialize the service to set up the persistence logic
export const layoutManagerService = new LayoutManagerService();
</file>

<file path="packages/shared/src/index.ts">
// Export all types
export * from './types/game';
export * from './types/characterClasses';
export * from './types/biomes';
export * from './types/network';
export * from './types/moderation';
export * from './types/commands';

// Export all constants
export * from './constants/gameConstants';
export * from './constants/biomeConfigs';

// Also provide explicit named exports for frequently-imported runtime enums
// (some bundlers/aliases can lose named re-exports in edge cases)
export { MovementStyle, Theme, NotificationType } from './types/game';
export { BiomeType } from './types/biomes';
export { GAME_CONFIG } from './constants/gameConstants';
</file>

<file path="packages/shared/package.json">
{
  "name": "shared",
  "version": "1.0.0",
  "description": "Shared types and constants for Chat Grid Chronicles",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc --listEmittedFiles",
    "dev": "tsc --watch"
  },
  "exports": {
    "./*": "./dist/*",
    "./types/*": "./dist/types/*.js",
    ".": "./dist/index.js"
  },
  "devDependencies": {
    "typescript": "^5.9.2"
  },
  "files": [
    "dist"
  ],
  "dependencies": {
    "zod": "^4.1.12"
  }
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-temporary-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Package manager lock files (use pnpm-lock.yaml only)
package-lock.json
yarn.lock

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.*
.env.local
.env.development.local
.env.test.local
.env.production.local

# parcel-bundler cache (https://parceljs.org/)
.cache

# Next.js build output
.next

# Nuxt.js build output
.nuxt

# VuePress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Mac files
.DS_Store

# Windows files
Thumbs.db

# IDE files
.vscode/
.idea/

# Typescript
*.tsbuildinfo

# Project specific
temp-frontend/
packages/backend/dist/
packages/frontend/dist/
packages/shared/dist/

# Compiled JavaScript and declaration files in src directories
**/src/**/*.js
**/src/**/*.js.map
**/src/**/*.d.ts


jules-scratch/*
</file>

<file path="packages/backend/src/services/__tests__/PlayerService.test.ts">
import { PlayerService } from '../PlayerService';
import { GameWorld } from '@chatterealm/shared';
import { GameWorldManager } from '../GameWorldManager';
import { NPCManager } from '../NPCManager';
import { createMockPlayer } from '../../testUtils/mockGameWorld';

describe('PlayerService', () => {
  let playerService: PlayerService;
  let gameWorld: GameWorld;
  let gameWorldManager: GameWorldManager;
  let occupiedPositions: Set<string>;
  let availableSpawnPoints: Set<string>;

  beforeEach(() => {
    const npcManager = new NPCManager(new Set());
    gameWorldManager = new GameWorldManager(npcManager);
    gameWorld = gameWorldManager.initializeGameWorld({ generateNPCs: false, worldType: 'test' });
    occupiedPositions = new Set();
    availableSpawnPoints = new Set();
    playerService = new PlayerService(gameWorld, gameWorldManager, occupiedPositions, availableSpawnPoints);
  });

  describe('addPlayer', () => {
    it('should add a player to an empty world', () => {
      const player = createMockPlayer('1', 'testPlayer', { x: 0, y: 0 });
      const result = playerService.addPlayer(player);

      expect(result).toBeDefined();
      expect(playerService.getPlayers()).toHaveLength(1);
      expect(playerService.getPlayer('1')).toEqual(expect.objectContaining({
        id: '1',
        displayName: 'testPlayer'
      }));
    });

    it('should add multiple players successfully', () => {
      const player1 = createMockPlayer('1', 'player1', { x: 0, y: 0 });
      const player2 = createMockPlayer('2', 'player2', { x: 1, y: 1 });

      const result1 = playerService.addPlayer(player1);
      const result2 = playerService.addPlayer(player2);

      expect(result1).toBeDefined();
      expect(result2).toBeDefined();
      expect(playerService.getPlayers()).toHaveLength(2);
    });
  });

  describe('removePlayer', () => {
    it('should remove an existing player from the world', () => {
      const player = createMockPlayer('1', 'testPlayer', { x: 5, y: 5 });
      playerService.addPlayer(player);

      const result = playerService.removePlayer('1');

      expect(result).toBeDefined();
      expect(result?.id).toBe('1');
      expect(playerService.getPlayers().length).toBe(0);
      expect(playerService.getPlayer('1')).toBeUndefined();
    });

    it('should fail to remove a non-existent player', () => {
      const result = playerService.removePlayer('nonexistent');
      expect(result).toBeNull();
    });
  });

  describe('getPlayerProfile', () => {
    it('should return the profile for an existing player', () => {
      const player = createMockPlayer('1', 'testPlayer', { x: 5, y: 5 });
      playerService.addPlayer(player);

      const profile = playerService.getPlayerProfile('1');
      expect(profile).not.toBeNull();
      expect(profile?.id).toBe('1');
      expect(profile?.displayName).toBe('testPlayer');
    });

    it('should return null for a non-existent player', () => {
      const profile = playerService.getPlayerProfile('nonexistent');
      expect(profile).toBeNull();
    });
  });
});
</file>

<file path="packages/backend/src/services/__tests__/WebSocketServer.integration.test.ts">
import { createServer, Server as HTTPServer } from 'http';
import { AddressInfo } from 'net';
import { io as ioc, Socket as ClientSocket } from 'socket.io-client';
import { WebSocketServer } from '../webSocketServer';
import { Player, PlayerClass } from '@chatterealm/shared';
import { gameService } from '../GameService';
import { GameStateDelta } from '../../models/GameRoom';

describe('WebSocketServer Integration', () => {
    let httpServer: HTTPServer;
    let wsServer: WebSocketServer;
    let clientSocket: ClientSocket;
    let port: number;

    beforeAll((done) => {
        httpServer = createServer();
        wsServer = new WebSocketServer(httpServer);
        httpServer.listen(() => {
            port = (httpServer.address() as AddressInfo).port;
            done();
        });
    });

    afterAll(() => {
        wsServer.shutdown();
        httpServer.close();
    });

    beforeEach((done) => {
        clientSocket = ioc(`http://localhost:${port}`, {
            reconnection: false,
            transports: ['websocket'],
        });
        clientSocket.on('connect', () => done());
    });

    afterEach(() => {
        if (clientSocket.connected) {
            clientSocket.disconnect();
        }
    });

    it('should broadcast only player changes, not the full player list', (done) => {
        const player1Data = { id: 'player1', displayName: 'Player One', class: PlayerClass.ROGUE };
        const player2Data = { id: 'player2', displayName: 'Player Two', class: PlayerClass.MAGE };

        let clientSocket2: ClientSocket;

        clientSocket.emit('join_game', player1Data);
        clientSocket.once('join_acknowledged', () => {
            clientSocket2 = ioc(`http://localhost:${port}`, {
                reconnection: false,
                transports: ['websocket'],
            });

            clientSocket2.on('connect', () => {
                clientSocket2.emit('join_game', player2Data);
                    clientSocket.once('game_state_delta', (deltas: GameStateDelta[]) => {
                        const playerDelta = deltas.find(d => d.type === 'players');

                        // This is the failing assertion.
                        // We expect the delta to contain only the changed player.
                        expect(playerDelta).toBeDefined();
                        expect(Array.isArray(playerDelta?.data)).toBe(true);
                        expect(playerDelta?.data.length).toBe(1);
                        expect(playerDelta?.data[0].id).toBe(player1Data.id);

                        clientSocket2.disconnect();
                        done();
                    });

                    const room = gameService.getRoom('main_room');
                    if (!room) return done(new Error('Room not found'));

                    room.movePlayer(player1Data.id, { x: 1, y: 1 });
            });
        });
    }, 10000);
});
</file>

<file path="packages/backend/src/services/contentModerationService.ts">
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';
import { ModerationResult, ModerationResultSchema } from '@chatterealm/shared';
import GeminiClient from './geminiClient';
import LRUCache from 'lru-cache';

const CACHE_SIZE = 10000;

class ContentModerationService {
  private client = GeminiClient.getInstance();
  private violationCache: LRUCache<string, ModerationResult> = new LRUCache({ max: CACHE_SIZE });

  async moderateMessage(
    message: string,
    context: {
      userId: string;
      userHistory: string[];
      chatType: 'public' | 'private' | 'guild';
    }
  ): Promise<ModerationResult> {
    // Check cache for exact matches
    const cacheKey = `${message}-${context.chatType}`;
    if (this.violationCache.has(cacheKey)) {
      return this.violationCache.get(cacheKey)!;
    }

    const prompt = `Analyze this chat message for policy violations in a multiplayer game context.

Message: "${message}"
Chat type: ${context.chatType}
User's recent messages: ${context.userHistory.slice(-3).join(' | ')}

Evaluate for:
1. Harassment or bullying
2. Hate speech or discrimination
3. Sexual or inappropriate content
4. Threats or violent content
5. Spam or advertising
6. Self-harm references

Consider:
- Game-appropriate language (mild competitive trash talk is OK)
- Context from recent messages
- Chat type (private chats have more leniency)

Provide detailed analysis and recommended action.`;

    try {
      const response = await this.client.getGenerativeModel({ model: 'gemini-pro' }).generateContent({
        contents: [{ role: 'user', parts: [{ text: prompt }] }],
        generationConfig: {
          responseMimeType: 'application/json',
          responseSchema: zodToJsonSchema(ModerationResultSchema),
          temperature: 0.3,
        },
      });

      const result = ModerationResultSchema.parse(JSON.parse(response.response.text()));
      return result;
    } catch (error) {
      console.error('Error moderating message:', error);
      // Return a default "allow" response in case of an error
      return {
        isViolation: false,
        severity: 'none',
        categories: ['none'],
        explanation: 'Error processing moderation request.',
        suggestedAction: 'allow',
      };
    }

    // Cache result if it's a violation
    if (result.isViolation) {
      this.violationCache.set(cacheKey, result);
    }

    return result;
  }

  async moderateUserProfile(profile: {
    displayName: string;
    bio: string;
    avatarDescription: string;
  }): Promise<{ allowed: boolean; issues: string[] }> {
    const content = `Display name: ${profile.displayName}\nBio: ${profile.bio}\nAvatar: ${profile.avatarDescription}`;

    const result = await this.moderateMessage(content, {
      userId: 'profile_check',
      userHistory: [],
      chatType: 'public'
    });

    return {
      allowed: !result.isViolation || result.severity === 'low',
      issues: result.categories.filter((c: string) => c !== 'none')
    };
  }
}

export default new ContentModerationService();
</file>

<file path="packages/backend/src/services/GameService.ts">
import { GameRoom } from '../models/GameRoom';
import { Player as PlayerData } from '@chatterealm/shared';

class GameService {
  private rooms: Map<string, GameRoom> = new Map();
  private static instance: GameService;

  private constructor() {}

  public static getInstance(): GameService {
    if (!GameService.instance) {
      GameService.instance = new GameService();
    }
    return GameService.instance;
  }

  public async createRoom(roomId: string): Promise<GameRoom> {
    if (this.rooms.has(roomId)) {
      return this.rooms.get(roomId)!;
    }
    const room = await GameRoom.create(roomId);
    this.rooms.set(roomId, room);
    return room;
  }

  public getRoom(roomId: string): GameRoom | undefined {
    return this.rooms.get(roomId);
  }

  public async joinRoom(roomId: string, playerData: PlayerData): Promise<GameRoom> {
    const room = this.getRoom(roomId) ?? await this.createRoom(roomId);
    room.addPlayer(playerData);
    return room;
  }

}

export const gameService = GameService.getInstance();
</file>

<file path="packages/backend/src/services/NPCManager.ts">
import { NPC, Position, BiomeType, GAME_CONFIG, WORLD_CONSTANTS } from '@chatterealm/shared';

export class NPCManager {
  private occupiedPositions: Set<string>;

  constructor(occupiedPositions: Set<string>) {
    this.occupiedPositions = occupiedPositions;
  }

  /**
   * Generate NPCs for the initial world
   */
  public generateNPCs(gridWidth: number, gridHeight: number, grid: any[]): NPC[] {
    const npcs: NPC[] = [];
    const npcCount = Math.floor(gridWidth * gridHeight * WORLD_CONSTANTS.NPC_SPAWN_CHANCE);
    
    for (let i = 0; i < npcCount; i++) {
      const position = this.findEmptySpawnPosition(gridWidth, gridHeight, grid);
      if (!position) continue;
      
      const npc: NPC = {
        id: `npc_${i}_${Date.now()}`,
        name: this.generateNPCName(),
        type: 'monster',
        position,
        stats: {
          hp: 30 + Math.floor(Math.random() * 20),
          maxHp: 30 + Math.floor(Math.random() * 20),
          attack: 3 + Math.floor(Math.random() * 4),
          defense: 1 + Math.floor(Math.random() * 3),
          speed: 1 + Math.floor(Math.random() * 2)
        },
        behavior: 'wandering',
        lootTable: [],
        isAlive: true,
        lastMoveTime: Date.now()
      };
      
      npcs.push(npc);
      this.occupiedPositions.add(`${position.x},${position.y}`);
    }
    
    return npcs;
  }

  /**
   * Generate NPCs in a specific zone (for cataclysm events)
   */
  public generateNPCsInZone(
    centerPosition: Position,
    innerRadius: number,
    outerRadius: number,
    gridWidth: number,
    gridHeight: number,
    grid: any[]
  ): NPC[] {
    const npcs: NPC[] = [];
    const center = centerPosition;
    const npcCount = Math.floor(
      (Math.PI * (outerRadius * outerRadius - innerRadius * innerRadius)) * 
      WORLD_CONSTANTS.NPC_SPAWN_CHANCE * 0.5
    );

    for (let i = 0; i < npcCount; i++) {
      // Find a position in the affected zone
      let attempts = 0;
      let position: Position | null = null;

      while (attempts < 50 && !position) {
        const angle = Math.random() * Math.PI * 2;
        const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
        const x = Math.round(center.x + Math.cos(angle) * distance);
        const y = Math.round(center.y + Math.sin(angle) * distance);

        if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight &&
            !this.occupiedPositions.has(`${x},${y}`) &&
            grid[y][x].type !== BiomeType.MOUNTAIN) {
          position = { x, y };
        }
        attempts++;
      }

      if (position) {
        const npc: NPC = {
          id: `npc_cataclysm_${i}_${Date.now()}`,
          name: this.generateNPCName(),
          type: 'monster',
          position,
          stats: {
            hp: 40 + Math.floor(Math.random() * 30),
            maxHp: 40 + Math.floor(Math.random() * 30),
            attack: 5 + Math.floor(Math.random() * 6),
            defense: 2 + Math.floor(Math.random() * 4),
            speed: 1 + Math.floor(Math.random() * 2)
          },
          behavior: 'wandering',
          lootTable: [],
          isAlive: true,
          lastMoveTime: Date.now()
        };
        
        npcs.push(npc);
        this.occupiedPositions.add(`${position.x},${position.y}`);
      }
    }

    return npcs;
  }

  /**
   * Update NPC AI and movement
   */
  public updateNPCs(npcs: NPC[], grid: any[]): void {
    npcs.forEach(npc => {
      if (!npc.isAlive) return;
      
      const now = Date.now();
      
      // Simple AI: move randomly every 5 seconds with 30% chance
      if (now - npc.lastMoveTime > 5000 && Math.random() < 0.3) {
        const directions = ['up', 'down', 'left', 'right'] as const;
        const direction = directions[Math.floor(Math.random() * directions.length)];
        
        const oldPosition = npc.position;
        const newPosition = this.calculateNewPosition(oldPosition, direction);
        
        const oldKey = `${oldPosition.x},${oldPosition.y}`;
        this.occupiedPositions.delete(oldKey);
        
        if (this.isValidMove(oldPosition, newPosition, grid) && 
            !this.occupiedPositions.has(`${newPosition.x},${newPosition.y}`)) {
          npc.position = newPosition;
          this.occupiedPositions.add(`${newPosition.x},${newPosition.y}`);
          npc.lastMoveTime = now;
        } else {
          // Restore position if move failed
          this.occupiedPositions.add(oldKey);
        }
      }
    });
  }

  /**
   * Calculate new position based on direction
   */
  private calculateNewPosition(current: Position, direction: string): Position {
    switch (direction) {
      case 'up': return { x: current.x, y: current.y - 1 };
      case 'down': return { x: current.x, y: current.y + 1 };
      case 'left': return { x: current.x - 1, y: current.y };
      case 'right': return { x: current.x + 1, y: current.y };
      default: return current;
    }
  }

  /**
   * Validate if NPC movement is allowed
   */
  private isValidMove(from: Position, to: Position, grid: any[]): boolean {
    // Check bounds
    if (to.x < 0 || to.x >= grid[0]?.length || to.y < 0 || to.y >= grid.length) {
      return false;
    }

    // Check if movement distance is valid (max 1 tile)
    const distance = Math.max(Math.abs(to.x - from.x), Math.abs(to.y - from.y));
    if (distance > 1) {
      return false;
    }

    // Check terrain
    const terrain = grid[to.y][to.x];
    return terrain.type !== BiomeType.MOUNTAIN;
  }

  /**
   * Generate a random NPC name
   */
  private generateNPCName(): string {
    const prefixes = ['Dark', 'Shadow', 'Wild', 'Fierce', 'Ancient', 'Cursed', 'Savage', 'Brutal'];
    const creatures = ['Goblin', 'Orc', 'Wolf', 'Bear', 'Spider', 'Skeleton', 'Troll', 'Bandit'];
    
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const creature = creatures[Math.floor(Math.random() * creatures.length)];
    
    return `${prefix} ${creature}`;
  }

  /**
   * Find an empty spawn position for NPCs
   */
  private findEmptySpawnPosition(gridWidth: number, gridHeight: number, grid: any[]): Position | null {
    let attempts = 0;
    const maxAttempts = 100;

    while (attempts < maxAttempts) {
      const x = Math.floor(Math.random() * gridWidth);
      const y = Math.floor(Math.random() * gridHeight);

      if (this.isValidSpawnPosition(x, y, grid)) {
        return { x, y };
      }
      attempts++;
    }

    return null;
  }

  /**
   * Validate if a spawn position is valid for NPCs
   */
  private isValidSpawnPosition(x: number, y: number, grid: any[]): boolean {
    // Check bounds
    if (x < 0 || x >= grid[0]?.length || y < 0 || y >= grid.length) {
      return false;
    }

    // Check if position is already occupied
    if (this.occupiedPositions.has(`${x},${y}`)) {
      return false;
    }

    // Check terrain
    const terrain = grid[y][x];
    if (terrain.type === BiomeType.MOUNTAIN) {
      return false;
    }

    // Check for adjacent mountains (avoid spawning surrounded by mountains)
    let adjacentMountains = 0;
    const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
    
    for (const [dx, dy] of directions) {
      const checkX = x + dx;
      const checkY = y + dy;
      
      if (checkX >= 0 && checkX < grid[0].length && checkY >= 0 && checkY < grid.length) {
        if (grid[checkY][checkX].type === BiomeType.MOUNTAIN) {
          adjacentMountains++;
        }
      }
    }

    return adjacentMountains <= 2; // Don't spawn if surrounded by too many mountains
  }

  /**
   * Get NPC at specific position
   */
  public getNPCAtPosition(npcs: NPC[], position: Position): NPC | null {
    return npcs.find(npc => 
      npc.isAlive && 
      npc.position.x === position.x && 
      npc.position.y === position.y
    ) || null;
  }

  /**
   * Remove dead NPCs from position tracking
   */
  public cleanupDeadNPCs(npcs: NPC[]): void {
    npcs.forEach(npc => {
      if (!npc.isAlive) {
        const key = `${npc.position.x},${npc.position.y}`;
        this.occupiedPositions.delete(key);
      }
    });
  }

  /**
   * Add NPC to position tracking
   */
  public addNPCPosition(position: Position): void {
    this.occupiedPositions.add(`${position.x},${position.y}`);
  }

  /**
   * Remove NPC from position tracking
   */
  public removeNPCPosition(position: Position): void {
    this.occupiedPositions.delete(`${position.x},${position.y}`);
  }

  /**
   * Update occupied positions reference
   */
  public updateOccupiedPositions(occupiedPositions: Set<string>): void {
    this.occupiedPositions = occupiedPositions;
  }
}
</file>

<file path="packages/backend/src/services/PlayerService.ts">
import { Player as PlayerData, GameWorld, PlayerProfile } from '@chatterealm/shared';
import { Player } from '../models/Player';
import { GameWorldManager } from './GameWorldManager';

export class PlayerService {
  private gameWorld: GameWorld;
  private gameWorldManager: GameWorldManager;
  private occupiedPositions: Set<string>;
  private availableSpawnPoints: Set<string>;

  constructor(
    gameWorld: GameWorld,
    gameWorldManager: GameWorldManager,
    occupiedPositions: Set<string>,
    availableSpawnPoints: Set<string>
  ) {
    this.gameWorld = gameWorld;
    this.gameWorldManager = gameWorldManager;
    this.occupiedPositions = occupiedPositions;
    this.availableSpawnPoints = availableSpawnPoints;
  }

  public addPlayer(playerData: PlayerData): Player {
    const player = new Player(playerData);
    this.gameWorldManager.addPlayer(
      this.gameWorld,
      playerData,
      this.occupiedPositions,
      this.availableSpawnPoints
    );
    return player;
  }

  public removePlayer(playerId: string): PlayerData | null {
    return this.gameWorldManager.removePlayer(
      this.gameWorld,
      playerId,
      this.occupiedPositions,
      this.availableSpawnPoints
    );
  }

  public getPlayer(playerId: string): PlayerData | undefined {
    return this.gameWorld.players.find(p => p.id === playerId);
  }

  public getPlayers(): PlayerData[] {
    return this.gameWorld.players;
  }

  public getPlayerProfile(playerId: string): PlayerProfile | null {
    const player = this.getPlayer(playerId);
    if (!player) {
      return null;
    }

    return {
      id: player.id,
      displayName: player.displayName,
      avatar: player.avatar,
      class: player.class,
      level: player.level,
      bio: player.bio || "A brave adventurer exploring the world of ChatterRealm.",
      achievements: player.achievements,
      titles: player.titles,
    };
  }
}
</file>

<file path="packages/frontend/src/components/layout/PanelSystem.tsx">
import React from 'react';
import { Responsive, WidthProvider, Layout, Layouts } from 'react-grid-layout';
import 'react-grid-layout/css/styles.css';
import { useLayoutStore } from '../../stores/layoutStore';
import ChatPanel from '../panels/ChatPanel';
import FriendsPanel from '../panels/FriendsPanel';

const ResponsiveGridLayout = WidthProvider(Responsive);

// A simple Panel component for demonstration
const Panel: React.FC<{ title: string, children?: React.ReactNode }> = ({ title, children }) => (
  <div style={{ border: '1px solid #ccc', borderRadius: '4px', height: '100%', overflow: 'auto', background: 'white' }}>
    <div style={{ background: '#f0f0f0', padding: '8px', fontWeight: 'bold', cursor: 'move' }}>{title}</div>
    <div style={{ padding: '8px' }}>{children}</div>
  </div>
);

// Component registry
const panelRegistry: { [key: string]: React.ComponentType } = {
  chat: ChatPanel,
  friends: FriendsPanel,
};

const PanelSystem: React.FC = ({ children }) => {
  const { layouts, setLayouts } = useLayoutStore();

  const onLayoutChange = (newLayout: Layout[], newLayouts: Layouts) => {
    setLayouts(newLayouts);
  };

  const generatePanels = () => {
    // We'll use the 'lg' breakpoint as the source of truth for which panels to render.
    const layout = layouts?.lg;
    if (!layout) return null;

    return layout.map((panel) => {
      const PanelComponent = panelRegistry[panel.i];
      const panelContent = panel.i === 'main-content'
        ? children
        : PanelComponent ? <PanelComponent /> : `Unknown panel: ${panel.i}`;

      return (
        <div key={panel.i}>
          <Panel title={panel.i}>{panelContent}</Panel>
        </div>
      );
    });
  };

  return (
    <ResponsiveGridLayout
      className="layout"
      layouts={layouts}
      breakpoints={{ lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }}
      cols={{ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }}
      rowHeight={30}
      onLayoutChange={onLayoutChange}
    >
      {generatePanels()}
    </ResponsiveGridLayout>
  );
};

export default PanelSystem;
</file>

<file path="packages/backend/src/models/Player.ts">
import {
  Player as PlayerData,
  Position,
  Stats,
  PlayerClass,
  Item,
  CharacterClass,
  CharacterVisual,
  ClassAbility,
  Buff,
} from '@chatterealm/shared';

export class Player {
  id: string;
  name: string;
  position: Position;
  stats: Stats;
  class: PlayerClass;
  connected: boolean;
  lastActive: number;
  bio: string;

  // Add all other PlayerData properties
  twitchUsername?: string;
  avatar: string;
  health: number;
  mana: number;
  stamina: number;
  hunger: number;
  thirst: number;
  level: number;
  experience: number;
  inventory: Item[];
  equipment: {
    weapon?: Item;
    armor?: Item;
    accessory?: Item;
  };
  achievements: string[];
  titles: string[];
  isAlive: boolean;
  lastMoveTime: number;
  spawnTime: number;
  buffs?: Buff[];
  characterClass?: CharacterClass;
  visual?: CharacterVisual;
  abilities?: ClassAbility[];
  resources?: { [key: string]: number };
  characterStats?: {
    vitality: number;
    intellect: number;
    agility: number;
    perception: number;
    resonance: number;
    scavenge: number;
  };

  constructor(playerData: Partial<PlayerData>) {
    this.id = playerData.id || '';
    this.name = playerData.displayName || 'Anonymous';
    this.position = playerData.position || { x: 0, y: 0 };
    this.stats = playerData.stats || { hp: 100, maxHp: 100, attack: 10, defense: 5, speed: 5 };
    this.class = playerData.class || PlayerClass.KNIGHT;
    this.connected = playerData.connected ?? true;
    this.lastActive = playerData.lastActive ?? Date.now();
    this.bio = playerData.bio || '';
    this.twitchUsername = playerData.twitchUsername || '';
    this.avatar = playerData.avatar || 'default_avatar.png';
    this.health = playerData.health ?? 100;
    this.mana = playerData.mana ?? 100;
    this.stamina = playerData.stamina ?? 100;
    this.hunger = playerData.hunger ?? 100;
    this.thirst = playerData.thirst ?? 100;
    this.level = playerData.level ?? 1;
    this.experience = playerData.experience ?? 0;
    this.inventory = playerData.inventory ?? [];
    this.equipment = playerData.equipment ?? {};
    this.achievements = playerData.achievements ?? [];
    this.titles = playerData.titles ?? [];
    this.isAlive = playerData.isAlive ?? true;
    this.lastMoveTime = playerData.lastMoveTime ?? 0;
    this.spawnTime = playerData.spawnTime ?? Date.now();
    this.buffs = playerData.buffs ?? [];
    this.characterClass = playerData.characterClass;
    this.visual = playerData.visual;
    this.abilities = playerData.abilities ?? [];
    this.resources = playerData.resources ?? {};
    this.characterStats = playerData.characterStats ?? { vitality: 1, intellect: 1, agility: 1, perception: 1, resonance: 1, scavenge: 1 };
  }

  public move(direction: 'up' | 'down' | 'left' | 'right'): void {
    switch (direction) {
      case 'up':
        this.position.y -= 1;
        break;
      case 'down':
        this.position.y += 1;
        break;
      case 'left':
        this.position.x -= 1;
        break;
      case 'right':
        this.position.x += 1;
        break;
    }
    this.lastActive = Date.now();
  }

  public disconnect(): void {
    this.connected = false;
    this.lastActive = Date.now();
  }

  public reconnect(): void {
    this.connected = true;
    this.lastActive = Date.now();
  }

  public getData(): PlayerData {
    // This method is useful for sending player data to the client
    return {
      id: this.id,
      displayName: this.name,
      position: this.position,
      stats: this.stats,
      class: this.class,
      connected: this.connected,
      lastActive: this.lastActive,
      bio: this.bio,
      twitchUsername: this.twitchUsername,
      avatar: this.avatar,
      health: this.health,
      mana: this.mana,
      stamina: this.stamina,
      hunger: this.hunger,
      thirst: this.thirst,
      level: this.level,
      experience: this.experience,
      inventory: this.inventory,
      equipment: this.equipment,
      achievements: this.achievements,
      titles: this.titles,
      isAlive: this.isAlive,
      lastMoveTime: this.lastMoveTime,
      spawnTime: this.spawnTime,
      buffs: this.buffs,
      characterClass: this.characterClass,
      visual: this.visual,
      abilities: this.abilities,
      resources: this.resources,
      characterStats: this.characterStats,
    };
  }
}
</file>

<file path="packages/backend/src/services/__tests__/webSocketServer.race.test.ts">
import { createServer, Server as HTTPServer } from 'http';
import { AddressInfo } from 'net';
import { io as ioc, Socket as ClientSocket } from 'socket.io-client';
import { WebSocketServer } from '../webSocketServer';
import { gameService } from '../GameService';

describe('WebSocketServer Race Conditions', () => {
    let httpServer: HTTPServer;
    let wsServer: WebSocketServer;
    let port: number;

    beforeAll((done) => {
        httpServer = createServer();
        wsServer = new WebSocketServer(httpServer);

        httpServer.listen(() => {
            port = (httpServer.address() as AddressInfo).port;
            done();
        });
    });

    afterAll(() => {
        wsServer.shutdown();
        httpServer.close();
    });

    it('should handle concurrent join_game requests for the same player and only allow one to succeed', async () => {
        const numClients = 5;
        const playerData = { id: 'race_player', displayName: 'Race Player' };
        const clients: ClientSocket[] = [];

        let successCount = 0;
        let errorCount = 0;

        const connectionPromises = [];
        for (let i = 0; i < numClients; i++) {
            const client = ioc(`http://localhost:${port}`, {
                reconnection: false,
                transports: ['websocket'],
                forceNew: true // Ensures a new connection for each client
            });
            clients.push(client);

            const connectionPromise = new Promise<void>((resolve) => {
                client.on('connect', () => resolve());
            });
            connectionPromises.push(connectionPromise);
        }

        // Wait for all clients to connect
        await Promise.all(connectionPromises);

        // Now, have all clients try to join at once
        const joinPromises = clients.map(client => {
            return new Promise<void>(resolve => {
                client.on('game_joined', () => {
                    successCount++;
                    resolve();
                });
                client.on('error', (error) => {
                    const validErrors = [
                        'Authentication already in progress for this player.',
                        'Player is already online.',
                        'Join already in progress'
                    ];
                    if (validErrors.includes(error.message)) {
                        errorCount++;
                    }
                    resolve();
                });
                client.on('join_failed', (error) => {
                    const validErrors = [
                        'Player already connected',
                        'Join failed'
                    ];
                    if (validErrors.includes(error.message)) {
                        errorCount++;
                    }
                    resolve();
                });
                client.emit('join_game', playerData);
            });
        });

        await Promise.all(joinPromises);

        const room = gameService.getRoom('main_room');
        const playersInGame = room ? room.getPlayers() : [];

        // Assertions
        expect(successCount).toBe(1);
        expect(errorCount).toBe(numClients - 1);
        expect(playersInGame.length).toBe(1);

        // Cleanup
        clients.forEach(client => client.disconnect());
    }, 10000); // Increase timeout for this test
});
</file>

<file path="packages/backend/src/services/gameStateManager.test.ts">
import { GameStateManager } from './gameStateManager';
import { GameWorld, Player, PlayerClass, BiomeType, Position, GAME_CONFIG } from '@chatterealm/shared';
import { createMockGameWorld, createMockPlayer } from '../testUtils/mockGameWorld';

describe('GameStateManager', () => {
  let gameStateManager: GameStateManager;

  beforeEach(async () => {
    gameStateManager = await GameStateManager.create({ options: { generateNPCs: false, worldType: 'test' } });
  });

  describe('game world access', () => {
    it('should provide access to the game world', () => {
      const gameWorld = gameStateManager.getGameWorld();
      
      expect(gameWorld).toBeDefined();
      expect(gameWorld.players).toEqual([]);
      expect(gameWorld.npcs).toEqual([]);
      expect(gameWorld.items).toEqual([]);
    });
  });
});
</file>

<file path="packages/backend/src/services/twitchService.ts">
import { Server } from 'socket.io';
import axios from 'axios';
import * as tmi from 'tmi.js';
import { GameStateManager } from './gameStateManager';
import ContentModerationService from './contentModerationService';
import { gameService } from './GameService';
import { NPC, Player, Item } from '@chatterealm/shared';

// Twitch IRC message types
interface TwitchMessage {
  username: string;
  displayName: string;
  message: string;
  timestamp: number;
  isSubscriber: boolean;
  isModerator: boolean;
  isBroadcaster: boolean;
  channelPoints?: number;
  history: string[];
}

export interface ChatCommand {
  command: string;
  args: string[];
  username: string;
  displayName: string;
  userId: string;
  channelPoints: number;
  timestamp: number;
}

export interface CommandHandler {
  command: string;
  handler: (cmd: ChatCommand) => Promise<string>;
  cooldown: number; // milliseconds
  requiredPoints?: number;
}

export class TwitchService {
  protected io: Server;
  private clientId: string;
  private clientSecret: string;
  private accessToken: string = '';
  private channelName: string;
  private commandCooldowns: Map<string, number> = new Map();
  private userCooldowns: Map<string, number> = new Map();
  private globalCooldowns: Map<string, number> = new Map();
  protected commandHandlers: Map<string, CommandHandler> = new Map();
  private tmiClient: tmi.Client | null = null;
  protected gameStateManager: GameStateManager;
  private connected: boolean = false;
  private userChatHistory: Map<string, string[]> = new Map();

  // Rate limiting configuration
  private readonly GLOBAL_COOLDOWN_MS = 500; // 500ms between any commands
  private readonly MAX_COMMANDS_PER_MINUTE = 30;
  private readonly COMMAND_WINDOW_MS = 60000; // 1 minute window
  private commandCounts: Map<string, { count: number; windowStart: number }> = new Map();

  // Logging methods
  private logCommand(command: string, username: string, success: boolean, error?: string): void {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      command,
      username,
      success,
      error: error || null
    };

    console.log(`[COMMAND] ${JSON.stringify(logEntry)}`);

    // Could also write to a file or external logging service
    // this.writeToLogFile(logEntry);
  }

  private logConnectionEvent(event: string, details?: any): void {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      event,
      details: details || null
    };

    console.log(`[CONNECTION] ${JSON.stringify(logEntry)}`);
  }

  private logError(context: string, error: any, username?: string): void {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      context,
      username: username || null,
      error: error.message || error,
      stack: error.stack || null
    };

    console.error(`[ERROR] ${JSON.stringify(logEntry)}`);
  }

  constructor(io: Server, clientId: string, clientSecret: string, channelName: string, gameStateManager: GameStateManager) {
    this.io = io;
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.channelName = channelName;
    this.gameStateManager = gameStateManager;

    this.initializeCommandHandlers();
    this.registerCommandAliases();
    this.initializeTmiClient();
  }

  private initializeTmiClient(): void {
    // Initialize tmi.js client
    this.tmiClient = new tmi.Client({
      options: {
        debug: true,
        messagesLogLevel: 'info'
      },
      connection: {
        reconnect: true,
        secure: true
      },
      identity: {
        username: process.env.TWITCH_BOT_USERNAME || 'your_bot_username',
        password: process.env.TWITCH_OAUTH_TOKEN || 'oauth:your_oauth_token'
      },
      channels: [this.channelName]
    });

    // Set up event listeners
    this.tmiClient.on('message', this.handleChatMessage.bind(this));
    this.tmiClient.on('connected', this.onConnected.bind(this));
    this.tmiClient.on('disconnected', this.onDisconnected.bind(this));
    this.tmiClient.on('join', this.onChannelJoin.bind(this));
    this.tmiClient.on('part', this.onChannelPart.bind(this));
  }

  private initializeCommandHandlers(): void {
    // !spawn command - join the game
    this.registerCommand('spawn', async (cmd: ChatCommand) => {
      if (cmd.args.length < 1) {
        return `@${cmd.displayName} Usage: !spawn <class> (knight/rogue/mage)`;
      }

      const playerClass = cmd.args[0].toLowerCase();
      const validClasses = ['knight', 'rogue', 'mage'];

      if (!validClasses.includes(playerClass)) {
        return `@${cmd.displayName} Invalid class! Choose: knight, rogue, or mage`;
      }

      // Check if player already exists
      const existingPlayer = this.getExistingPlayer(cmd.username);
      if (existingPlayer) {
        return `@${cmd.displayName} You're already in the game! Use !move to play.`;
      }

      // Check channel points cost (100 points)
      if (cmd.channelPoints < 100) {
        return `@${cmd.displayName} You need 100 channel points to spawn!`;
      }

      // Spawn the player using GameStateManager
      const result = await this.spawnPlayer(cmd.username, cmd.displayName, playerClass);

      if (result.success) {
        // Deduct channel points
        await this.deductChannelPoints(cmd.userId, 100);

        return `@${cmd.displayName} Welcome to Chat Grid Chronicles! You spawned as a ${playerClass}! Use !move to start playing.`;
      } else {
        return `@${cmd.displayName} Failed to spawn. The world might be full!`;
      }
    }, 5000, 100); // 5 second cooldown, 100 points

    // !move command - move player
    this.registerCommand('move', async (cmd: ChatCommand) => {
      if (cmd.args.length < 1) {
        return `@${cmd.displayName} Usage: !move <direction> (up/down/left/right)`;
      }

      const direction = cmd.args[0].toLowerCase();
      const validDirections = ['up', 'down', 'left', 'right'];

      if (!validDirections.includes(direction)) {
        return `@${cmd.displayName} Invalid direction! Use: up, down, left, or right`;
      }

      // Check if player exists
      const player = this.getExistingPlayer(cmd.username);
      if (!player) {
        return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
      }

      // Calculate new position based on direction
      const currentPos = player.position;
      let newPosition: { x: number; y: number };
      
      switch (direction) {
        case 'up':
          newPosition = { x: currentPos.x, y: currentPos.y - 1 };
          break;
        case 'down':
          newPosition = { x: currentPos.x, y: currentPos.y + 1 };
          break;
        case 'left':
          newPosition = { x: currentPos.x - 1, y: currentPos.y };
          break;
        case 'right':
          newPosition = { x: currentPos.x + 1, y: currentPos.y };
          break;
        default:
          return `@${cmd.displayName} Invalid direction! Use: up, down, left, or right`;
      }

      // Execute move using GameStateManager
      const result = this.gameStateManager.movePlayer(cmd.username, newPosition);

      if (result.success) {
        return `@${cmd.displayName} Moved ${direction}!`;
      } else {
        return `@${cmd.displayName} ${result.message || 'Cannot move there!'}`;
      }
    }, 1000); // 1 second cooldown

    // !up, !down, !left, !right commands - direct movement
    this.registerCommand('up', async (cmd: ChatCommand) => {
      return this.handleMovementCommand(cmd, 'up');
    }, 1000);

    this.registerCommand('down', async (cmd: ChatCommand) => {
      return this.handleMovementCommand(cmd, 'down');
    }, 1000);

    this.registerCommand('left', async (cmd: ChatCommand) => {
      return this.handleMovementCommand(cmd, 'left');
    }, 1000);

    this.registerCommand('right', async (cmd: ChatCommand) => {
      return this.handleMovementCommand(cmd, 'right');
    }, 1000);

    // !attack command - attack enemies
    this.registerCommand('attack', async (cmd: ChatCommand) => {
      const player = this.getExistingPlayer(cmd.username);
      if (!player) {
        return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
      }

      // Find enemy at player's position
      const enemy = this.gameStateManager.getGameWorld().npcs.find((npc: NPC) =>
        npc.position.x === player.position.x &&
        npc.position.y === player.position.y &&
        npc.isAlive
      );

      if (!enemy) {
        return `@${cmd.displayName} No enemy nearby to attack!`;
      }

      // Execute attack using GameStateManager
      const result = this.gameStateManager.attackEnemy(cmd.username, enemy.position);

      if (result.success) {
        return `@${cmd.displayName} ${result.message}`;
      } else {
        return `@${cmd.displayName} Attack failed!`;
      }
    }, 2000); // 2 second cooldown


    // !pickup command - pick up items
    this.registerCommand('pickup', async (cmd: ChatCommand) => {
      const player = this.getExistingPlayer(cmd.username);
      if (!player) {
        return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
      }

      // Find items at player's position
      const items = this.gameStateManager.getGameWorld().items.filter((item: Item) =>
        item.position &&
        item.position.x === player.position.x &&
        item.position.y === player.position.y
      );

      if (items.length === 0) {
        return `@${cmd.displayName} No items nearby to pick up!`;
      }

      // Pick up the first item
      const room = gameService.getRoom('main_room');
      if (!room) {
        return `@${cmd.displayName} Error: Game room not found.`;
      }
      const result = room.pickupItem(cmd.username, items[0].id);

      if (result.success) {
        return `@${cmd.displayName} ${result.message}`;
      } else {
        return `@${cmd.displayName} Failed to pick up item!`;
      }
    }, 2000); // 2 second cooldown

    // !status command - check player stats
    this.registerCommand('status', async (cmd: ChatCommand) => {
      const player = this.getExistingPlayer(cmd.username);
      if (!player) {
        return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
      }

      const { stats, level, experience } = player;
      return `@${cmd.displayName} [${player.class}] Lvl ${level} | HP: ${stats.hp}/${stats.maxHp} | ATK: ${stats.attack} | DEF: ${stats.defense} | XP: ${experience}`;
    }, 3000); // 3 second cooldown

    // !inventory command - check player inventory
    this.registerCommand('inventory', async (cmd: ChatCommand) => {
      const player = this.getExistingPlayer(cmd.username);
      if (!player) {
        return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
      }

      if (player.inventory.length === 0) {
        return `@${cmd.displayName} Your inventory is empty!`;
      }

      const items = player.inventory.map((item: any) => `${item.name} (${item.rarity})`).join(', ');
      return `@${cmd.displayName} Inventory: ${items}`;
    }, 3000); // 3 second cooldown


    // !use command - use an item from inventory
    this.registerCommand('use', async (cmd: ChatCommand) => {
      if (cmd.args.length < 1) {
        return `@${cmd.displayName} Usage: !use <item_name>`;
      }

      const player = this.getExistingPlayer(cmd.username);
      if (!player) {
        return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
      }

      const itemName = cmd.args.join(' ').toLowerCase();
      const item = player.inventory.find((item: any) =>
        item.name.toLowerCase().includes(itemName)
      );

      if (!item) {
        return `@${cmd.displayName} Item not found in your inventory!`;
      }

      const room = gameService.getRoom('main_room');
      if (!room) {
        return `@${cmd.displayName} Error: Game room not found.`;
      }
      const result = room.useItem(cmd.username, item.id);

      if (result.success) {
        return `@${cmd.displayName} ${result.message}`;
      } else {
        return `@${cmd.displayName} Failed to use item!`;
      }
    }, 2000); // 2 second cooldown

    // !stats command - alias for !status
    this.registerCommand('stats', async (cmd: ChatCommand) => {
      return this.commandHandlers.get('status')!.handler(cmd);
    }, 3000); // 3 second cooldown

    // !info command - get information about the game
    this.registerCommand('info', async (cmd: ChatCommand) => {
      const world = this.gameStateManager.getGameWorld();
      const playerCount = world.players.filter((p: Player) => p.isAlive).length;
      const npcCount = world.npcs.filter((n: NPC) => n.isAlive).length;
      const itemCount = world.items.length;

      return `@${cmd.displayName} Chat Grid Chronicles - Players: ${playerCount}, NPCs: ${npcCount}, Items: ${itemCount}. Use !help for commands!`;
    }, 5000); // 5 second cooldown

    // !leaderboard command - show top players
    this.registerCommand('leaderboard', async (cmd: ChatCommand) => {
      const world = this.gameStateManager.getGameWorld();
      const topPlayers = world.players
        .filter((p: Player) => p.isAlive)
        .sort((a: Player, b: Player) => b.level - a.level || b.experience - a.experience)
        .slice(0, 5);

      if (topPlayers.length === 0) {
        return `@${cmd.displayName} No players in the game yet!`;
      }

      const leaderboard = topPlayers.map((player: Player, index: number) =>
        `${index + 1}. ${player.displayName} (Lvl ${player.level})`
      ).join(', ');

      return `@${cmd.displayName} Top Players: ${leaderboard}`;
    }, 5000); // 5 second cooldown

    // !class command - change class (with cost)
    this.registerCommand('class', async (cmd: ChatCommand) => {
      if (cmd.args.length < 1) {
        return `@${cmd.displayName} Usage: !class <new_class> (knight/rogue/mage)`;
      }

      const player = this.getExistingPlayer(cmd.username);
      if (!player) {
        return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
      }

      const newClass = cmd.args[0].toLowerCase();
      const validClasses = ['knight', 'rogue', 'mage'];

      if (!validClasses.includes(newClass)) {
        return `@${cmd.displayName} Invalid class! Choose: knight, rogue, or mage`;
      }

      if (player.class === newClass) {
        return `@${cmd.displayName} You're already a ${newClass}!`;
      }

      // Check channel points cost (200 points for class change)
      if (cmd.channelPoints < 200) {
        return `@${cmd.displayName} You need 200 channel points to change class!`;
      }

      // Change class and update stats
      player.class = newClass as any;
      player.stats = this.getPlayerStatsForClass(newClass);

      // Deduct channel points
      await this.deductChannelPoints(cmd.userId, 200);

      return `@${cmd.displayName} Class changed to ${newClass}! Stats updated.`;
    }, 10000, 200); // 10 second cooldown, 200 points

    // !rest command - heal at spawn (with cost)
    this.registerCommand('rest', async (cmd: ChatCommand) => {
      const player = this.getExistingPlayer(cmd.username);
      if (!player) {
        return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
      }

      if (player.stats.hp >= player.stats.maxHp) {
        return `@${cmd.displayName} You're already at full health!`;
      }

      // Check channel points cost (50 points for rest)
      if (cmd.channelPoints < 50) {
        return `@${cmd.displayName} You need 50 channel points to rest and heal!`;
      }

      // Heal player to full
      const healAmount = player.stats.maxHp - player.stats.hp;
      player.stats.hp = player.stats.maxHp;

      // Deduct channel points
      await this.deductChannelPoints(cmd.userId, 50);

      return `@${cmd.displayName} Rested and healed for ${healAmount} HP!`;
    }, 30000, 50); // 30 second cooldown, 50 points

    // !commands command - show available commands (alias for help)
    this.registerCommand('commands', async (cmd: ChatCommand) => {
      return this.commandHandlers.get('help')!.handler(cmd);
    }, 5000); // 5 second cooldown

    // !help command - show available commands
    this.registerCommand('help', async (cmd: ChatCommand) => {
      const commands = [
        '!spawn <class> - Join the game (100 points)',
        '!move <direction> - Move your character',
        '!up/!down/!left/!right - Quick movement',
        '!attack - Attack nearby enemies',
        '!pickup - Pick up nearby items',
        '!inventory - Check your items',
        '!use <item> - Use an item',
        '!status/!stats - Check your stats',
        '!class <new_class> - Change class (200 points)',
        '!rest - Heal to full (50 points)',
        '!leaderboard - Show top players',
        '!info - Game information',
        '!help - Show this message'
      ];

      return `@${cmd.displayName} Available commands: ${commands.join(' | ')}`;
    }, 5000); // 5 second cooldown
  }

  protected handleMovementCommand(cmd: ChatCommand, direction: 'up' | 'down' | 'left' | 'right'): string {
    const player = this.getExistingPlayer(cmd.username);
    if (!player) {
      return `@${cmd.displayName} You haven't spawned yet! Use !spawn first.`;
    }

    // Calculate new position based on direction
    const currentPos = player.position;
    let newPosition: { x: number; y: number };
    
    switch (direction) {
      case 'up':
        newPosition = { x: currentPos.x, y: currentPos.y - 1 };
        break;
      case 'down':
        newPosition = { x: currentPos.x, y: currentPos.y + 1 };
        break;
      case 'left':
        newPosition = { x: currentPos.x - 1, y: currentPos.y };
        break;
      case 'right':
        newPosition = { x: currentPos.x + 1, y: currentPos.y };
        break;
    }

    const result = this.gameStateManager.movePlayer(cmd.username, newPosition);

    if (result.success) {
      return `@${cmd.displayName} Moved ${direction}!`;
    } else {
      return `@${cmd.displayName} ${result.message || 'Cannot move there!'}`;
    }
  }

  private registerCommand(
    command: string,
    handler: (cmd: ChatCommand) => Promise<string>,
    cooldown: number,
    requiredPoints?: number
  ): void {
    this.commandHandlers.set(command, {
      command,
      handler,
      cooldown,
      requiredPoints
    });
  }

  private registerCommandAlias(alias: string, targetCommand: string): void {
    const targetHandler = this.commandHandlers.get(targetCommand);
    if (targetHandler) {
      this.commandHandlers.set(alias, targetHandler);
    }
  }

  private registerCommandAliases(): void {
    // Register common aliases
    this.registerCommandAlias('s', 'status'); // !s -> !status
    this.registerCommandAlias('i', 'inventory'); // !i -> !inventory
    this.registerCommandAlias('m', 'move'); // !m -> !move
    this.registerCommandAlias('a', 'attack'); // !a -> !attack
    this.registerCommandAlias('p', 'pickup'); // !p -> !pickup
    this.registerCommandAlias('h', 'help'); // !h -> !help
    this.registerCommandAlias('l', 'leaderboard'); // !l -> !leaderboard
    this.registerCommandAlias('r', 'rest'); // !r -> !rest

    // Movement aliases
    this.registerCommandAlias('u', 'up'); // !u -> !up
    this.registerCommandAlias('d', 'down'); // !d -> !down
    this.registerCommandAlias('l', 'left'); // !l -> !left (conflicts with leaderboard, so skip)
    this.registerCommandAlias('rt', 'right'); // !rt -> !right

    // Alternative command formats
    this.registerCommandAlias('join', 'spawn'); // !join -> !spawn
    this.registerCommandAlias('enter', 'spawn'); // !enter -> !spawn
    this.registerCommandAlias('fight', 'attack'); // !fight -> !attack
    this.registerCommandAlias('grab', 'pickup'); // !grab -> !pickup
    this.registerCommandAlias('take', 'pickup'); // !take -> !pickup
    this.registerCommandAlias('heal', 'rest'); // !heal -> !rest
    this.registerCommandAlias('sleep', 'rest'); // !sleep -> !rest
  }

  // TMI.js event handlers
  private async handleChatMessage(channel: string, userstate: tmi.ChatUserstate, message: string, self: boolean): Promise<void> {
    // Don't process our own messages
    if (self) return;

    const username = userstate.username || 'unknown';
    const history = this.userChatHistory.get(username) || [];
    history.push(message);
    this.userChatHistory.set(username, history.slice(-10)); // Keep last 10 messages

    // Convert tmi.js message to our TwitchMessage format
    const twitchMessage: TwitchMessage = {
      username: username,
      displayName: userstate['display-name'] || userstate.username || 'Unknown',
      message: message,
      timestamp: Date.now(),
      isSubscriber: userstate.subscriber || false,
      isModerator: userstate.mod || false,
      isBroadcaster: userstate.badges?.broadcaster === '1' || false,
      channelPoints: 0, // Would need to implement channel point redemption handling
      history: history,
    };

    await this.processChatMessage(twitchMessage);
  }

  private onConnected(addr: string, port: number): void {
    console.log(`ðŸ”— Connected to Twitch IRC at ${addr}:${port}`);
    this.connected = true;
    this.logConnectionEvent('connected', { addr, port });

    // Send a welcome message to the channel
    if (this.tmiClient) {
      this.tmiClient.say(this.channelName, 'ðŸ¤– Chat Grid Chronicles bot is now online! Type !help for commands.');
    }
  }

  private onDisconnected(reason: string): void {
    console.log(`ðŸ”Œ Disconnected from Twitch IRC: ${reason}`);
    this.connected = false;
    this.logConnectionEvent('disconnected', { reason });
  }

  private onChannelJoin(channel: string, username: string, self: boolean): void {
    if (self) {
      console.log(`âœ… Joined channel: ${channel}`);
    } else {
      console.log(`ðŸ‘¤ ${username} joined ${channel}`);
    }
  }

  private onChannelPart(channel: string, username: string, self: boolean): void {
    if (self) {
      console.log(`âŒ Left channel: ${channel}`);
    } else {
      console.log(`ðŸ‘‹ ${username} left ${channel}`);
    }
  }

  // Rate limiting methods
  private checkGlobalCooldown(username: string): boolean {
    const lastCommand = this.globalCooldowns.get(username) || 0;
    return Date.now() - lastCommand >= this.GLOBAL_COOLDOWN_MS;
  }

  private checkCommandRateLimit(username: string): boolean {
    const now = Date.now();
    const userStats = this.commandCounts.get(username);

    if (!userStats) {
      this.commandCounts.set(username, { count: 1, windowStart: now });
      return true;
    }

    // Reset window if needed
    if (now - userStats.windowStart >= this.COMMAND_WINDOW_MS) {
      userStats.count = 1;
      userStats.windowStart = now;
      return true;
    }

    // Check if under limit
    if (userStats.count < this.MAX_COMMANDS_PER_MINUTE) {
      userStats.count++;
      return true;
    }

    return false;
  }

  private validateCommandInput(command: string, args: string[]): { valid: boolean; error?: string } {
    // Sanitize command name
    if (!/^[a-zA-Z]+$/.test(command)) {
      return { valid: false, error: 'Invalid command format' };
    }

    // Check for command injection attempts
    const fullCommand = `${command} ${args.join(' ')}`;
    if (fullCommand.includes('..') || fullCommand.includes('/') || fullCommand.includes('\\')) {
      return { valid: false, error: 'Invalid characters in command' };
    }

    // Validate argument count for specific commands
    const handler = this.commandHandlers.get(command);
    if (handler) {
      switch (command) {
        case 'spawn':
          if (args.length < 1) {
            return { valid: false, error: 'Missing class argument' };
          }
          break;
        case 'move':
          if (args.length < 1) {
            return { valid: false, error: 'Missing direction argument' };
          }
          break;
        case 'use':
          if (args.length < 1) {
            return { valid: false, error: 'Missing item name' };
          }
          break;
        case 'class':
          if (args.length < 1) {
            return { valid: false, error: 'Missing class argument' };
          }
          break;
      }
    }

    return { valid: true };
  }

  // Process incoming Twitch chat messages
  public async processChatMessage(twitchMessage: TwitchMessage): Promise<void> {
    // Check if message is a command
    if (!twitchMessage.message.startsWith('!')) {
      const moderationResult = await ContentModerationService.moderateMessage(twitchMessage.message, {
        userId: twitchMessage.username,
        userHistory: twitchMessage.history,
        chatType: 'public',
      });

      if (moderationResult.isViolation) {
        switch (moderationResult.suggestedAction) {
          case 'block':
            // Message is blocked, do nothing.
            break;
          case 'ban':
            // TODO: Implement user banning logic.
            console.warn(`Banning user ${twitchMessage.username} is not yet implemented.`);
            break;
          case 'filter':
            this.io.emit('chat_message', {
              message: moderationResult.filteredMessage,
              timestamp: Date.now(),
              isResponse: false,
              isModerated: true,
            });
            break;
          default: // 'allow', 'flag', or unknown
            this.io.emit('chat_message', {
              message: twitchMessage.message,
              timestamp: Date.now(),
              isResponse: false,
            });
        }
      } else {
        this.io.emit('chat_message', {
          message: twitchMessage.message,
          timestamp: Date.now(),
          isResponse: false,
        });
      }
      return; // Not a command
    }

    // Parse command
    const parts = twitchMessage.message.substring(1).split(' ');
    const command = parts[0].toLowerCase();
    const args = parts.slice(1);

    // Validate command input
    const validation = this.validateCommandInput(command, args);
    if (!validation.valid) {
      await this.sendChatResponse(`@${twitchMessage.displayName} ${validation.error}`);
      return;
    }

    // Check if command exists
    const handler = this.commandHandlers.get(command);
    if (!handler) {
      return; // Unknown command
    }

    // Check global cooldown
    if (!this.checkGlobalCooldown(twitchMessage.username)) {
      return; // Global cooldown active
    }

    // Check rate limit
    if (!this.checkCommandRateLimit(twitchMessage.username)) {
      await this.sendChatResponse(`@${twitchMessage.displayName} Rate limit exceeded! Slow down.`);
      return;
    }

    // Check user cooldown
    const userKey = `${twitchMessage.username}:${command}`;
    const lastUsed = this.userCooldowns.get(userKey) || 0;
    if (Date.now() - lastUsed < handler.cooldown) {
      const remaining = Math.ceil((handler.cooldown - (Date.now() - lastUsed)) / 1000);
      await this.sendChatResponse(`@${twitchMessage.displayName} Command on cooldown! ${remaining}s remaining.`);
      return;
    }

    // Check channel points if required
    if (handler.requiredPoints && (twitchMessage.channelPoints || 0) < handler.requiredPoints) {
      const response = `@${twitchMessage.displayName} You need ${handler.requiredPoints} channel points for this command!`;
      await this.sendChatResponse(response);
      return;
    }

    // Create command object
    const chatCommand: ChatCommand = {
      command,
      args,
      username: twitchMessage.username,
      displayName: twitchMessage.displayName,
      userId: twitchMessage.username, // Would be actual user ID in real implementation
      channelPoints: twitchMessage.channelPoints || 0,
      timestamp: Date.now()
    };

    try {
      // Execute command
      const response = await handler.handler(chatCommand);

      // Send response to chat
      await this.sendChatResponse(response);

      // Update cooldowns
      this.userCooldowns.set(userKey, Date.now());
      this.globalCooldowns.set(twitchMessage.username, Date.now());

      // Log successful command
      this.logCommand(command, twitchMessage.username, true);

      // Broadcast to game clients
      this.io.emit('chat_command_processed', {
        command,
        username: twitchMessage.username,
        displayName: twitchMessage.displayName,
        success: true
      });

    } catch (error) {
      // Log error
      this.logError('command_processing', error, twitchMessage.username);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logCommand(command, twitchMessage.username, false, errorMessage);

      await this.sendChatResponse(`@${twitchMessage.displayName} Sorry, something went wrong! Please try again.`);

      // Broadcast error to game clients
      this.io.emit('chat_command_processed', {
        command,
        username: twitchMessage.username,
        displayName: twitchMessage.displayName,
        success: false,
        error: 'Command execution failed'
      });
    }
  }

  // Player management methods
  protected async spawnPlayer(username: string, displayName: string, playerClass: string): Promise<{ success: boolean; player?: any; message?: string }> {
    try {
      // Create player object based on class
      const playerStats = this.getPlayerStatsForClass(playerClass);
      const player = {
        id: username,
        twitchUsername: username,
        displayName,
        avatar: this.getRandomAvatar(),
        position: { x: 0, y: 0 }, // Will be set by GameStateManager
        class: playerClass as any, // Cast to PlayerClass enum
        // Core resource pools (mirroring new Player interface fields)
        health: playerStats.hp, // Initialize health to stats.hp
        mana: 50, // Basic starting mana pool (could vary by class later)
        stamina: 100,
        hunger: 100,
        thirst: 100,
        stats: playerStats,
        level: 1,
        experience: 0,
        inventory: [],
        equipment: {
          weapon: undefined,
          armor: undefined,
          accessory: undefined
        },
        achievements: [],
        titles: [],
        isAlive: true,
        lastMoveTime: 0,
        spawnTime: Date.now(),
        connected: true,
        lastActive: Date.now()
      };

      // Add player to game using GameStateManager
      const result = this.gameStateManager.addPlayer(player);

      if (result.success) {
        return { success: true, player: player };
      } else {
        return { success: false, message: result.message };
      }
    } catch (error) {
      console.error('Error spawning player:', error);
      return { success: false, message: 'Failed to spawn player' };
    }
  }

  protected getExistingPlayer(username: string): Player | undefined {
    // Get player from GameStateManager
    return this.gameStateManager.getGameWorld().players.find((p: Player) => p.id === username);
  }

  private getPlayerStatsForClass(playerClass: string): any {
    const baseStats = {
      hp: 100,
      maxHp: 100,
      attack: 10,
      defense: 5,
      speed: 5
    };

    // Class-specific stat modifiers
    switch (playerClass) {
      case 'knight':
        return { ...baseStats, defense: 8, attack: 12 };
      case 'rogue':
        return { ...baseStats, speed: 8, attack: 15 };
      case 'mage':
        return { ...baseStats, attack: 18, hp: 80, maxHp: 80 };
      default:
        return baseStats;
    }
  }

  private async deductChannelPoints(userId: string, points: number): Promise<boolean> {
    // This would call Twitch API to deduct points
    console.log(`Deducting ${points} points from user ${userId}`);
    return true;
  }

  public async sendStreamMessage(message: string): Promise<void> {
    await this.sendChatResponse(message);
  }

  protected async sendChatResponse(message: string): Promise<void> {
    // Send message to Twitch chat via tmi.js
    if (this.tmiClient && this.connected) {
      try {
        await this.tmiClient.say(this.channelName, message);
      } catch (error) {
        console.error('Error sending chat response:', error);
      }
    } else {
      console.log(`[CHAT RESPONSE] ${message}`);
    }

    // Broadcast to frontend for display
    this.io.emit('chat_message', {
      message,
      timestamp: Date.now(),
      isResponse: true
    });
  }

  private getRandomAvatar(): string {
    const avatars = ['ðŸ¤ ', 'âš”ï¸', 'ðŸ—¡ï¸', 'ðŸ”®', 'ðŸ‡', 'ðŸ›¡ï¸', 'âš¡', 'ðŸ”¥'];
    return avatars[Math.floor(Math.random() * avatars.length)];
  }

  // Connect to Twitch using tmi.js
  public async connect(): Promise<void> {
    console.log('ðŸ”— Connecting to Twitch...');

    if (!this.tmiClient) {
      throw new Error('TMI client not initialized');
    }

    try {
      await this.tmiClient.connect();
      console.log('âœ… Twitch service connected successfully');
    } catch (error) {
      console.error('âŒ Failed to connect to Twitch:', error);
      throw error;
    }
  }

  // Disconnect from Twitch
  public async disconnect(): Promise<void> {
    console.log('ðŸ”Œ Disconnecting from Twitch...');

    if (this.tmiClient && this.connected) {
      try {
        await this.tmiClient.disconnect();
        this.connected = false;
        console.log('âœ… Twitch service disconnected successfully');
      } catch (error) {
        console.error('âŒ Error disconnecting from Twitch:', error);
      }
    }
  }

  // Check if connected to Twitch
  public isConnected(): boolean {
    return this.connected;
  }

  // Get connection status
  public getConnectionStatus(): { connected: boolean; channel: string } {
    return {
      connected: this.connected,
      channel: this.channelName
    };
  }
}
</file>

<file path="packages/frontend/src/ai/EntityManager.ts">
// packages/frontend/src/ai/EntityManager.ts

import { GameEntity } from './GameEntity';

export class EntityManager {
  private entities: Map<number, GameEntity> = new Map();

  addEntity(entity: GameEntity): void {
    this.entities.set(entity.id, entity);
  }

  removeEntity(entity: GameEntity): void {
    this.entities.delete(entity.id);
  }

  getEntityById(id: number): GameEntity | undefined {
    return this.entities.get(id);
  }

  updateEntities(delta: number): void {
    for (const entity of this.entities.values()) {
      entity.update(delta);
    }
  }

  getAllEntities(): GameEntity[] {
    return Array.from(this.entities.values());
  }
}
</file>

<file path="packages/frontend/src/ai/MessageDispatcher.ts">
// packages/frontend/src/ai/MessageDispatcher.ts

import { Telegram } from './Telegram';
import { EntityManager } from './EntityManager';
import { GameEntity } from './GameEntity';

export class MessageDispatcher {
  private static instance: MessageDispatcher;
  private priorityQueue: Telegram[] = [];
  private entityManager: EntityManager | null = null;

  private constructor() {}

  static getInstance(): MessageDispatcher {
    if (!MessageDispatcher.instance) {
      MessageDispatcher.instance = new MessageDispatcher();
    }
    return MessageDispatcher.instance;
  }

  public setEntityManager(entityManager: EntityManager): void {
    this.entityManager = entityManager;
  }

  public dispatchMessage(
    delay: number,
    senderId: number,
    receiverId: number,
    message: string,
    extraInfo?: any
  ): void {
    if (!this.entityManager) return;
    const receiver = this.entityManager.getEntityById(receiverId);
    if (!receiver) {
      console.warn('Message receiver not found');
      return;
    }

    const telegram = new Telegram(senderId, receiverId, message, 0, extraInfo);

    if (delay <= 0) {
      this.discharge(receiver, telegram);
    } else {
      const currentTime = Date.now();
      telegram.dispatchTime = currentTime + delay;
      this.priorityQueue.push(telegram);
      this.priorityQueue.sort((a, b) => a.dispatchTime - b.dispatchTime);
    }
  }

  public dispatchDelayedMessages(): void {
    const currentTime = Date.now();
    while (
      this.priorityQueue.length > 0 &&
      this.priorityQueue[0].dispatchTime < currentTime &&
      this.priorityQueue[0].dispatchTime > 0
    ) {
      const telegram = this.priorityQueue.shift()!;
      const receiver = this.entityManager.getEntityById(telegram.receiver);
      if (receiver) {
        this.discharge(receiver, telegram);
      }
    }
  }

  private discharge(receiver: GameEntity, telegram: Telegram): void {
    if (!receiver.handleMessage(telegram)) {
      console.warn('Message not handled by receiver');
    }
  }
}
</file>

<file path="packages/frontend/src/App.tsx">
import { useGameStore } from './stores/gameStore';
import { useTheme } from './hooks/useTheme';
import { useState, useEffect } from 'react';
import { initializeSounds } from './services/soundService';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';

// Import new layout components
import BaseLayout from './components/layout/BaseLayout';
import AppHeader from './components/layout/AppHeader';
import ModeNavigation from './components/layout/ModeNavigation';

// Import content components for routes
import { AnimationDemo } from './components';
import { DrawingEffectsDemo } from './components/DrawingEffectsDemo';
import { CataclysmDemo } from './components/CataclysmDemo';
import { SVGAssetDemo } from './components';
import EmojiSvgSmokeTest from './components/dev/EmojiSvgSmokeTest';
import { CharacterCreator } from './components/character/CharacterCreator';
import PlayerProfileWrapper from './components/player/PlayerProfile/PlayerProfileWrapper';

// Import mode-specific layouts
import PlayLayout from './components/layouts/PlayLayout';
import SpectateLayout from './components/layouts/SpectateLayout';
import DevLayout from './components/layouts/DevLayout';
import GameLayout from './components/layout/GameLayout'; // Still needed for legacy route

function App() {
  const {
    handleRegenerateWorld,
    handleJoinGame,
    handleStartCataclysm,
    handlePickUpItem,
    movePlayer,
  } = useGameStore();

  // Apply theme globally
  useTheme();

  const { updateAI } = useGameStore();

  useEffect(() => {
    let animationFrameId: number;

    const gameLoop = () => {
      updateAI();
      animationFrameId = requestAnimationFrame(gameLoop);
    };

    gameLoop();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [updateAI]);

  const [soundEnabled, setSoundEnabled] = useState(false);
  async function handleEnableSound() {
    try {
      const hasAudioSupport = typeof window.AudioContext !== 'undefined' ||
                            typeof (window as any).webkitAudioContext !== 'undefined';

      if (!hasAudioSupport) {
        console.warn('Audio not supported');
        setSoundEnabled(false);
        // Show user notification
        return;
      }

      await initializeSounds();
      setSoundEnabled(true);
      console.log('ðŸŽµ Sound initialized successfully');

    } catch (err) {
      console.error('Sound initialization failed:', err);
      setSoundEnabled(false);

      // Show user-friendly error message
      // You could use a toast notification here
      alert('Sound could not be enabled. Please check your browser permissions.');
    }
  }

  return (
    <Router>
      <div className="flex gap-0 min-h-screen p-0 bg-background font-inter text-text-primary box-border w-full max-w-none overflow-hidden app-container">
        <button 
          onClick={handleEnableSound} 
          disabled={soundEnabled}
          className="fixed top-4 right-4 z-50 bg-primary text-on-primary border-none px-3 py-2 rounded-md cursor-pointer font-semibold shadow-md disabled:opacity-60 disabled:cursor-default"
        >
          {soundEnabled ? 'Sound enabled' : 'Enable sound'}
        </button>
        <Routes>
          {/* Default route redirects to character creation for new users */}
          <Route path="/" element={<Navigate to="/create-character" replace />} />

          {/* Add character creation route */}
          <Route
            path="/create-character"
            element={
              <BaseLayout mode="play" headerContent={<ModeNavigation compact />}>
                <CharacterCreator />
              </BaseLayout>
            }
          />

          {/* Player Profile */}
          <Route
            path="/profile/:playerId"
            element={
              <BaseLayout mode="play" headerContent={<ModeNavigation compact />}>
                <PlayerProfileWrapper />
              </BaseLayout>
            }
          />

          {/* Play mode */}
          <Route
            path="/play"
            element={
              <BaseLayout mode="play" headerContent={<ModeNavigation compact />}>
                <PlayLayout />
              </BaseLayout>
            }
          />

          {/* Spectate mode */}
          <Route
            path="/spectate"
            element={
              <BaseLayout mode="spectate" headerContent={<ModeNavigation compact />}>
                <SpectateLayout />
              </BaseLayout>
            }
          />

          {/* Developer mode */}
          <Route
            path="/dev"
            element={
              <BaseLayout mode="dev" headerContent={<ModeNavigation compact />}>
                <DevLayout />
              </BaseLayout>
            }
          />

          {/* Dev-only emoji smoke test (quick validate svg fetching + conversion) */}
          <Route
            path="/dev/emoji-test"
            element={
              <BaseLayout mode="dev" headerContent={<ModeNavigation compact />}>
                <EmojiSvgSmokeTest />
              </BaseLayout>
            }
          />

          {/* Animation demo - GSAP and Rough animation showcase */}
          <Route
            path="/animations"
            element={
              <BaseLayout mode="dev" headerContent={<ModeNavigation compact />}>
                <AnimationDemo />
              </BaseLayout>
            }
          />

          {/* Drawing effects demo - Canvas and SVG drawing animations */}
          <Route
            path="/drawing-effects"
            element={
              <BaseLayout mode="dev" headerContent={<ModeNavigation compact />}>
                <DrawingEffectsDemo />
              </BaseLayout>
            }
          />

          {/* Cataclysm effects demo - Roughness modulation and regeneration */}
          <Route
            path="/cataclysm-demo"
            element={
              <BaseLayout mode="dev" headerContent={<ModeNavigation compact />}>
                <CataclysmDemo />
              </BaseLayout>
            }
          />

          {/* SVG Asset Converter - svg2roughjs integration */}
          <Route
            path="/svg-assets"
            element={
              <BaseLayout mode="dev" headerContent={<ModeNavigation compact />}>
                <SVGAssetDemo />
              </BaseLayout>
            }
          />

          {/* Legacy route for backward compatibility */}
          <Route
            path="/game"
            element={
              <BaseLayout mode="play" headerContent={<ModeNavigation compact />}>
                <GameLayout
                  handleRegenerateWorld={handleRegenerateWorld}
                  handleMove={movePlayer}
                  handleJoinGame={handleJoinGame}
                  handleStartCataclysm={handleStartCataclysm}
                  handlePickUpItem={handlePickUpItem}
                />
              </BaseLayout>
            }
          />
        </Routes>
      </div>
    </Router>
  );
}

export default App;
</file>

<file path="packages/backend/src/services/__tests__/LootService.test.ts">
import { LootService } from '../LootService';
import { GameStateManager } from '../gameStateManager';
import { CataclysmService } from '../CataclysmService';
import { Player, Item, ItemType, ItemRarity, GameWorld, Position } from '@chatterealm/shared';
import { createMockPlayer } from '../../testUtils/mockGameWorld';
import { LootManager } from '../LootManager';
import { NPCManager } from '../NPCManager';

// Mock dependencies
jest.mock('../gameStateManager');
jest.mock('../CataclysmService');

describe('LootService', () => {
  let lootService: LootService;
  let mockGameStateManager: jest.Mocked<GameStateManager>;
  let mockCataclysmService: jest.Mocked<CataclysmService>;
  let mockGameWorld: GameWorld;
  let player: Player;

  beforeEach(() => {
    // Create a mock GameWorld
    mockGameWorld = {
      id: 'test-world',
      players: [],
      npcs: [],
      items: [],
      grid: [],
      buildings: [],
      cataclysmCircle: {
        isActive: false,
        center: { x: 50, y: 50 },
        radius: 100,
        nextShrinkTime: 0,
        shrinkRate: 1,
      },
      worldAge: 0,
      lastResetTime: 0,
      cataclysmRoughnessMultiplier: 1.0,
      phase: 'exploration',
    };

    // Mock GameStateManager
    mockGameStateManager = new (GameStateManager as any)({ options: { generateNPCs: false, worldType: 'test' } });
    (mockGameStateManager.getGameWorld as jest.Mock).mockReturnValue(mockGameWorld);

    // Mock CataclysmService
    const mockLootManager = new LootManager();
    const mockNpcManager = new NPCManager(new Set());
    mockCataclysmService = new (CataclysmService as any)(mockLootManager, mockNpcManager, new Set());

    // Create LootService with mocked dependencies
    lootService = new LootService(mockCataclysmService);

    // Setup a player for tests
    player = createMockPlayer('player1', 'Tester', { x: 10, y: 10 });
    mockGameWorld.players.push(player);
  });

  describe('checkForInterruptions', () => {
    it('should return true if CataclysmService indicates the player is in the cataclysm', () => {
      // Arrange: Mock the looting session and CataclysmService response
      const session = { playerId: 'player1' } as any;

      // This is the core of the test: we set the mock to return true
      mockCataclysmService.isInCataclysmCircle.mockReturnValue(true);

      // Act: Call the private method (using ts-ignore for testing private methods)
      // @ts-ignore
      const result = lootService.checkForInterruptions(session, mockGameWorld);

      // Assert: Check that looting was interrupted
      expect(result).toBe(true);
      // Verify that the correct service and method were called
      expect(mockCataclysmService.isInCataclysmCircle).toHaveBeenCalledWith(player.position, mockGameWorld);
    });

    it('should return false if the player is not in the cataclysm and there are no other interruptions', () => {
      // Arrange
      const session = { playerId: 'player1' } as any;
      mockCataclysmService.isInCataclysmCircle.mockReturnValue(false); // Player is safe
      mockGameWorld.npcs = []; // No nearby enemies

      // Act
      // @ts-ignore
      const result = lootService.checkForInterruptions(session, mockGameWorld);

      // Assert
      expect(result).toBe(false);
      expect(mockCataclysmService.isInCataclysmCircle).toHaveBeenCalledWith(player.position, mockGameWorld);
    });
  });
});
</file>

<file path="packages/backend/src/services/LootService.ts">
import { Server } from 'socket.io';
import { GameStateManager } from './gameStateManager';
import { LootManager } from './LootManager';
import { TwitchService } from './twitchService';
import { Player, Item, Position, LootingSession, LootResult } from 'shared/src/types/game';
import { CataclysmService } from './CataclysmService';

export class LootService extends LootManager {
  private lootingPlayers: Map<string, LootingSession> = new Map();
  private cataclysmService: CataclysmService | null;

  constructor(cataclysmService?: CataclysmService) {
    super();
    this.cataclysmService = cataclysmService || null;
  }

  public startLooting(playerId: string, buildingId: string, gameWorld: any): LootResult {
    const player = gameWorld.players.find((p: any) => p.id === playerId);
    if (!player) return { success: false, message: 'Player not found!' };

    const building = gameWorld.buildings.find((b: any) => b.position.x === player.position.x && b.position.y === player.position.y);
    if (!building || building.id !== buildingId) return { success: false, message: 'No building to loot here!' };

    // This is a simplification. In a real scenario, building would have a loot table.
    // For now, let's assume a building has a certain number of lootable items.
    const lootableItems = 5;
    const lootingTime = this.calculateLootingTime(building);

    const session: LootingSession = {
      playerId,
      buildingId,
      startTime: Date.now(),
      duration: lootingTime,
      revealedItems: [],
      totalItems: lootableItems,
      canceled: false
    };

    this.lootingPlayers.set(playerId, session);

    return { success: true, message: `Started looting ${building.type}` };
  }

  public update(gameWorld: any): void {
    const now = Date.now();
    for (const session of this.lootingPlayers.values()) {
      if (session.canceled) {
        this.lootingPlayers.delete(session.playerId);
        continue;
      }

      if (this.checkForInterruptions(session, gameWorld)) {
        this.interruptLooting(session, gameWorld);
        continue;
      }

      const elapsedTime = now - session.startTime;
      if (elapsedTime >= session.duration) {
        this.completeLootingSession(session, gameWorld);
        continue;
      }

      const expectedReveals = Math.floor((elapsedTime / session.duration) * session.totalItems);
      const itemsToReveal = expectedReveals - session.revealedItems.length;

      if (itemsToReveal > 0) {
        for (let i = 0; i < itemsToReveal; i++) {
          const item = this.revealNextItem(session, gameWorld);
          if (item) {
            session.revealedItems.push(item);
            if (item.rarity === 'legendary' || item.rarity === 'epic') {
            }
          }
        }
      }
    }
  }

  private revealNextItem(session: LootingSession, gameWorld: any): Item | null {
    const player = gameWorld.players.find((p: any) => p.id === session.playerId);
    if (!player) return null;

    const building = gameWorld.buildings.find((b: any) => b.position.x === player.position.x && b.position.y === player.position.y);
    if (!building) return null;

    // For demonstration, we generate a new item. In a real implementation, you'd pull from the building's loot table.
    const terrain = gameWorld.grid[player.position.y][player.position.x];
    return this.generateTerrainBasedLoot(player.position, terrain?.type || ('plain' as any));
  }

  private checkForInterruptions(session: LootingSession, gameWorld: any): boolean {
    const player = gameWorld.players.find((p: any) => p.id === session.playerId);
    if (!player) return true;

    const nearbyEnemies = gameWorld.npcs.filter((npc: any) =>
        Math.abs(npc.position.x - player.position.x) <= 2 &&
        Math.abs(npc.position.y - player.position.y) <= 2 &&
        npc.isAlive
    );

    if (nearbyEnemies.length > 0) {
      const enemy = nearbyEnemies[0];
      return true;
    }

    if (this.cataclysmService && this.cataclysmService.isInCataclysmCircle(player.position, gameWorld)) {
          return true;
    }

    return false;
  }

  private interruptLooting(session: LootingSession, gameWorld: any): void {
    session.canceled = true;
    this.lootingPlayers.delete(session.playerId);
    // Items found so far might be kept or dropped, depending on game rules.
    // For now, let's assume they are dropped.
    const player = gameWorld.players.find((p: any) => p.id === session.playerId);
    if (player) {
    }
  }

  private completeLootingSession(session: LootingSession, gameWorld: any): void {
    this.lootingPlayers.delete(session.playerId);
    const player = gameWorld.players.find((p: any) => p.id === session.playerId);
    if (player && !session.canceled) {
      session.revealedItems.forEach(item => {
        if(item) player.inventory.push(item);
      });
    }
  }

  private calculateLootingTime(building: any): number {
    // Simplified calculation. Could be based on building size, type, etc.
    return (building.size.width * building.size.height) * 2000; // 2 seconds per tile
  }

  private getPlayerDisplayName(playerId: string, gameWorld: any): string {
    const player = gameWorld.players.find((p: any) => p.id === playerId);
    return player ? player.displayName : 'A looter';
  }

  public pickupItem(playerId: string, itemId: string, items: Item[], players: Player[]): any {
    const player = players.find(p => p.id === playerId);
    if (!player) return { success: false, message: 'Player not found' };

    const itemIndex = items.findIndex(i => i.id === itemId);
    if (itemIndex === -1) return { success: false, message: 'Item not found' };

    const item = items[itemIndex];
    if (!item.position || item.position.x !== player.position.x || item.position.y !== player.position.y) {
      return { success: false, message: 'Item is not at the same position as the player' };
    }

    items.splice(itemIndex, 1);
    player.inventory.push(item);

    return { success: true, message: `Picked up ${item.name}` };
  }

  public useItem(playerId: string, itemId: string, players: Player[]): any {
    const player = players.find(p => p.id === playerId);
    if (!player) return { success: false, message: 'Player not found' };

    const itemIndex = player.inventory.findIndex(i => i.id === itemId);
    if (itemIndex === -1) return { success: false, message: 'Item not found in inventory' };

    const item = player.inventory[itemIndex];
    // Add logic for using the item here
    player.inventory.splice(itemIndex, 1);

    return { success: true, message: `Used ${item.name}` };
  }

  public lootItem(playerId: string, itemId: string, items: Item[], players: Player[]): any {
    // For now, this is the same as pickupItem
    return this.pickupItem(playerId, itemId, items, players);
  }

  public inspectItem(playerId: string, itemId: string, items: Item[], players: Player[]): any {
    const item = items.find(i => i.id === itemId);
    if (!item) return { success: false, message: 'Item not found' };

    return { success: true, message: `You inspect the ${item.name}. ${item.description}` };
  }
}
</file>

<file path="packages/frontend/src/ai/Telegram.ts">
// packages/frontend/src/ai/Telegram.ts

import { ITelegram } from './AITypes';

export class Telegram implements ITelegram {
  public sender: number;
  public receiver: number;
  public message: string;
  public dispatchTime: number;
  public extraInfo?: any;

  constructor(
    sender: number,
    receiver: number,
    message: string,
    dispatchTime: number,
    extraInfo?: any
  ) {
    this.sender = sender;
    this.receiver = receiver;
    this.message = message;
    this.dispatchTime = dispatchTime;
    this.extraInfo = extraInfo;
  }
}
</file>

<file path="packages/frontend/src/components/GameCanvas/GameCanvas.tsx">
import React, { useRef, useEffect } from 'react';
import rough from 'roughjs';
import {
  Player,
  Item,
  AnimationSettings,
  BiomeType,
  GameWorld
} from 'shared';
import { GAME_CONFIG } from 'shared';
import { useGameStore } from '../../stores/gameStore';
import { renderGame } from '../renderers/canvas/RenderCoordinator';
import { CanvasDrawEffectComponent, createCanvasCirclePath, createCanvasStarPath, createCanvasLightningPath } from '../animations/CanvasDrawEffect';
import { useContainerResize } from './hooks/useContainerResize';
import { useCanvasSetup } from './hooks/useCanvasSetup';
import { useParticleManager } from './managers/ParticleManager';
import { useEffectManager } from './managers/EffectManager';
import { useRegenerationManager } from './managers/RegenerationManager';
import { webSocketClient } from '../../services/webSocketClient';
import { CataclysmVisualizer } from '../CataclysmVisualizer';
import { Position } from 'shared';

/**
 * Main game canvas component that renders the game world and handles user interactions.
 *
 * This component is responsible for:
 * - Rendering the game world using HTML5 Canvas and Rough.js for hand-drawn styling
 * - Managing particle effects, draw effects, and regeneration animations
 * - Handling user input (pointer clicks) for movement and item interactions
 * - Coordinating multiple rendering systems and animation loops
 *
 * The component uses several custom hooks and managers to handle different aspects:
 * - Container resizing and canvas setup
 * - Particle system management
 * - Draw effect animations
 * - Regeneration effect rendering
 *
 * @returns The rendered game canvas with interactive elements and animations
 *
 * @example
 * ```tsx
 * <GameCanvas />
 * ```
 */
const GameCanvas: React.FC = () => {
  const gameWorld = useGameStore(state => state.gameWorld);
  const unifiedSettings = useGameStore(state => state.unifiedSettings);

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // Use the new hooks and managers
  const containerSize = useContainerResize(containerRef);
  const canvasSetup = useCanvasSetup(
    canvasRef, 
    containerSize, 
    gameWorld?.grid, 
    8,
    unifiedSettings.visual.renderScale || 1.0 // Use setting or default to full resolution
  );
  const { particles, addParticles, updateParticles } = useParticleManager({ 
    animationSettings: unifiedSettings.animations, 
    onAddParticles: undefined 
  });
  const { drawEffects, triggerDrawEffect } = useEffectManager({ canvasRef });
  const { regenerationEffects } = useRegenerationManager({ 
    gameWorld, 
    tileSizePx: canvasSetup.tileSizePx, 
    grid: gameWorld?.grid 
  });

  const grid = gameWorld?.grid || [];
  const players = gameWorld?.players || [];
  const npcs = gameWorld?.npcs || [];
  const buildings = gameWorld?.buildings || [];
  const items = gameWorld?.items || [];
  const showGrid = unifiedSettings.animations?.showGrid ?? true;
  const animationSettings = unifiedSettings.animations;

  // Use refs to avoid restarting the animation loop
  const gameWorldRef = useRef(gameWorld);
  const gridRef = useRef(grid);
  const playersRef = useRef(players);
  const npcsRef = useRef(npcs);
  const itemsRef = useRef(items);
  const showGridRef = useRef(showGrid);
  const animationSettingsRef = useRef(animationSettings);
  const particlesRef = useRef(particles);
  const addParticlesRef = useRef(addParticles);
  const tileSizePxRef = useRef(canvasSetup.tileSizePx);
  const nightModeRef = useRef(unifiedSettings.world.nightMode);

  // Update refs when values change
  useEffect(() => {
    gameWorldRef.current = gameWorld;
  }, [gameWorld]);

  useEffect(() => {
    gridRef.current = grid;
  }, [grid]);

  useEffect(() => {
    playersRef.current = players;
  }, [players]);

  useEffect(() => {
    npcsRef.current = npcs;
  }, [npcs]);

  useEffect(() => {
    itemsRef.current = items;
  }, [items]);

  useEffect(() => {
    showGridRef.current = showGrid;
  }, [showGrid]);

  useEffect(() => {
    animationSettingsRef.current = animationSettings;
  }, [animationSettings]);

  useEffect(() => {
    particlesRef.current = particles;
  }, [particles]);

  useEffect(() => {
    addParticlesRef.current = addParticles;
  }, [addParticles]);

  useEffect(() => {
    tileSizePxRef.current = canvasSetup.tileSizePx;
  }, [canvasSetup.tileSizePx]);

  useEffect(() => {
    nightModeRef.current = unifiedSettings.world.nightMode;
  }, [unifiedSettings.world.nightMode]);

  // Render the game when setup is ready
  useEffect(() => {
    if (!canvasSetup.isReady || !canvasSetup.ctx) return;

    const rc = rough.canvas(canvasSetup.canvas!);
    let animationId: number;
    let startTime = performance.now();

    const animate = (currentTime: number) => {
      const time = (currentTime - startTime) / 1000; // Convert to seconds

      // Update particles in the main render loop
      updateParticles();

      // Only render if we have a game world
      if (gameWorldRef.current) {
        renderGame(
          rc,
          canvasSetup.ctx!,
          gridRef.current as { type: BiomeType }[][],
          playersRef.current,
          npcsRef.current,
          itemsRef.current,
          buildings,
          showGridRef.current,
          time,
          animationSettingsRef.current,
          particlesRef.current,
          addParticlesRef.current,
          tileSizePxRef.current,
          nightModeRef.current
        );
      }

      animationId = requestAnimationFrame(animate);
    };

    // Start the animation loop
    animationId = requestAnimationFrame(animate);

    // Cleanup
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, [canvasSetup.isReady, canvasSetup.ctx, updateParticles]); // Only depend on setup and updateParticles

  const handlePointerDown = (ev: React.PointerEvent) => {
    if (!canvasRef.current || !canvasSetup.isReady || !gameWorld) return;

    const rect = canvasRef.current.getBoundingClientRect();
    const clientX = ev.clientX;
    const clientY = ev.clientY;

    const cssX = clientX - rect.left;
    const cssY = clientY - rect.top;

    const localX = cssX - canvasSetup.offset.x;
    const localY = cssY - canvasSetup.offset.y;

    const tx = Math.floor(localX / canvasSetup.tileSizePx);
    const ty = Math.floor(localY / canvasSetup.tileSizePx);

    if (tx < 0 || ty < 0 || ty >= gameWorld.grid.length || tx >= (gameWorld.grid[0]?.length || 0)) return;

    const currentPlayer = useGameStore.getState().currentPlayer;
    if (!currentPlayer) return;

    // Check if clicked on an item for looting interaction
    const clickedItem = gameWorld.items.find(item => 
      item.position && item.position.x === tx && item.position.y === ty
    );

    if (clickedItem) {
      handleItemInteraction(clickedItem, currentPlayer);
      return;
    }

    // Default: move to clicked location
    useGameStore.getState().moveTo({ x: tx, y: ty });

    const pixelX = tx * canvasSetup.tileSizePx + canvasSetup.tileSizePx / 2;
    const pixelY = ty * canvasSetup.tileSizePx + canvasSetup.tileSizePx / 2;
    triggerDrawEffect(pixelX, pixelY, 'circle');
  };

  const handleItemInteraction = (item: Item, player: Player) => {
    // Check distance to item
    const distance = Math.max(
      Math.abs(item.position!.x - player.position.x),
      Math.abs(item.position!.y - player.position.y)
    );

    if (distance > GAME_CONFIG.lootInteractionRadius) {
      useGameStore.getState().setGameMessage('Item is too far away');
      return;
    }

    if (item.isHidden) {
      // Inspect hidden item
      webSocketClient.inspectItem(item.id);
    } else if (item.revealProgress >= 1.0 && item.canBeLooted) {
      // Loot revealed item
      webSocketClient.lootItem(item.id);
    } else if (item.revealProgress < 1.0) {
      // Item is still revealing
      useGameStore.getState().setGameMessage('Item is still being revealed...');
    } else {
      // Item not lootable
      useGameStore.getState().setGameMessage('Cannot loot this item right now');
    }
  };

  const getInfectedAreas = (): Position[] => {
    if (!gameWorld || !gameWorld.cataclysmCircle.isActive) {
      return [];
    }

    const infected: Position[] = [];
    const { center, radius } = gameWorld.cataclysmCircle;
    const grid = gameWorld.grid;

    for (let y = 0; y < grid.length; y++) {
      for (let x = 0; x < grid[y].length; x++) {
        const distance = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
        if (distance > radius) {
          infected.push({ x, y });
        }
      }
    }
    return infected;
  };

  const infectedAreas = getInfectedAreas();

  return (
    <div ref={containerRef} className="w-full h-full overflow-hidden p-2 box-border relative min-w-0 min-h-0" style={{ maxHeight: '100%', maxWidth: '100%' }}>
      <canvas
        ref={canvasRef}
        className={`border border-outline rounded-md block w-full h-full max-w-full max-h-full ${canvasSetup.isReady ? '' : 'hidden'}`} 
        onPointerDown={handlePointerDown}
        style={{ maxHeight: '100%', maxWidth: '100%' }}
      />
      {gameWorld?.phase === 'cataclysm' && gameWorld.cataclysmCircle.isActive && (
        <CataclysmVisualizer gameWorld={gameWorld} infectedAreas={infectedAreas} />
      )}
      {drawEffects.map(effect => (
        <CanvasDrawEffectComponent
          key={effect.id}
          canvasRef={canvasRef}
          path={effect.path}
          active={effect.active}
          duration={effect.duration}
          strokeColor={effect.strokeColor}
          strokeWidth={effect.strokeWidth}
          clearBeforeDraw={false}
        />
      ))}
      {regenerationEffects.map(effect => (
        <CanvasDrawEffectComponent
          key={effect.id}
          canvasRef={canvasRef}
          path={
            effect.type === 'circle'
              ? createCanvasCirclePath(effect.x, effect.y, 15, 12)
              : effect.type === 'star'
              ? createCanvasStarPath(effect.x, effect.y, 12, 8, 5)
              : createCanvasLightningPath(effect.x - 10, effect.y - 10, effect.x + 10, effect.y + 10, 4, 10)
          }
          active={effect.active}
          duration={2}
          strokeColor={
            effect.type === 'circle' ? '#00ff88' :
            effect.type === 'star' ? '#ff6b6b' : '#ffff00'
          }
          strokeWidth={2}
          clearBeforeDraw={false}
        />
      ))}
    </div>
  );
};

export default GameCanvas;
</file>

<file path="packages/frontend/src/components/layouts/PlayLayout.tsx">
import React, { useState, useEffect, useRef } from 'react';
import GameCanvas from '../GameCanvas';
import CharacterBuilder from '../CharacterBuilder';
import { MaterialButton, MaterialCard } from '../index';
import { useGameStore } from '../../stores/gameStore';
import { webSocketClient } from '../../services/webSocketClient';

// Define layout constants
const LAYOUT_CONSTANTS = {
  typography: {
    fontSize: {
      lg: '1.125rem'
    }
  },
  spacing: {
    md: '1rem',
    lg: '1.5rem'
  },
  borderRadius: {
    md: '8px',
    lg: '12px'
  },
  commonStyles: {
    glass: {
      background: 'rgba(255, 255, 255, 0.05)',
      border: '1px solid rgba(255, 255, 255, 0.1)'
    }
  },
  animation: {
    duration: {
      standard: '0.3s'
    },
    easing: {
      easeInOut: 'ease-in-out'
    }
  }
};

const PlayLayout: React.FC = () => {
  const { gameWorld, handleJoinGame } = useGameStore();
  const [isCharacterBuilderOpen, setIsCharacterBuilderOpen] = useState(false);
  const [currentPlayer, setCurrentPlayer] = useState<{
    displayName: string;
    class: any;
    avatar: string;
  } | null>(null);
  const [isConnecting, setIsConnecting] = useState(true);

  const lastPlayerIdRef = useRef<string | null>(null);

  useEffect(() => {
    // Check WebSocket connection
    const checkConnection = async () => {
      try {
        await webSocketClient.connect();
        setIsConnecting(false);
      } catch (err) {
        console.error('Connection failed:', err);
      }
    };
    checkConnection();
  }, []);

  // Ensure we notify server to remove the player when switching away from Play mode
  useEffect(() => {
    // When currentPlayer becomes set, store an id placeholder if available
    if (currentPlayer && (currentPlayer as any).id) {
      lastPlayerIdRef.current = (currentPlayer as any).id;
    }

    return () => {
      // On unmount or when currentPlayer/PlayLayout is removed, request server to remove last player
      if (lastPlayerIdRef.current && webSocketClient) {
        webSocketClient.leaveGame(lastPlayerIdRef.current);
      }
    };
  }, [currentPlayer]);

  // Handle character creation/join
  const handleCharacterJoin = (characterData: {
    displayName: string;
    class: any;
    avatar: string;
  }) => {
    setCurrentPlayer(characterData);
    setIsCharacterBuilderOpen(false);
    // Call the game join handler
    handleJoinGame(characterData);
  };

  // Handle opening character builder
  const handleOpenCharacterBuilder = () => {
    // If a player is currently present, request the server to remove them before creating a new one
    const pid = (currentPlayer as any)?.id;
    if (pid && webSocketClient) {
      webSocketClient.leaveGame(pid);
    }
    setCurrentPlayer(null);
    setIsCharacterBuilderOpen(true);
  };

  // Handle closing character builder
  const handleCloseCharacterBuilder = () => {
    setIsCharacterBuilderOpen(false);
  };

  if (isConnecting) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <div className="animate-spin text-6xl mb-4">âš”ï¸</div>
          <p className="text-text-secondary">Connecting to ChatteRealm...</p>
        </div>
      </div>
    );
  }

  return (
    <>
      {/* Main Content Area */}
      <div className="flex flex-1 overflow-hidden">
        {/* Game Canvas or Character Builder */}
        <div className="flex-1 overflow-hidden flex items-center justify-center relative bg-surface">
          {isCharacterBuilderOpen ? (
            <CharacterBuilder
              isOpen={isCharacterBuilderOpen}
              onClose={handleCloseCharacterBuilder}
              onJoinGame={handleCharacterJoin}
              currentPlayer={currentPlayer}
            />
          ) : !currentPlayer ? (
            // Character Creation Screen
            <div className="flex flex-col items-center justify-center gap-8 p-8 text-center">
              <div>
                <h1 className="text-4xl font-bold mb-4 text-text-primary [text-shadow:0_0_10px_var(--color-primary)]">
                  âš”ï¸ Welcome to ChatteRealm âš”ï¸
                </h1>
                <p className="text-lg text-text-secondary mb-8 max-w-xl">
                  Embark on an epic adventure in a procedurally generated world.
                  Choose your class, customize your character, and join the realm!
                </p>
              </div>

              <MaterialButton
                onClick={handleOpenCharacterBuilder}
                variant="contained"
                sx={{
                  backgroundColor: 'primary.main', // Using theme color
                  color: 'primary.contrastText', // Using theme color
                  fontSize: LAYOUT_CONSTANTS.typography.fontSize.lg,
                  padding: `${LAYOUT_CONSTANTS.spacing.md} ${LAYOUT_CONSTANTS.spacing.lg}`,
                  borderRadius: LAYOUT_CONSTANTS.borderRadius.md,
                  '&:hover': {
                    backgroundColor: 'primary.dark', // Using theme color
                    transform: 'scale(1.05)'
                  },
                  transition: `all ${LAYOUT_CONSTANTS.animation.duration.standard} ${LAYOUT_CONSTANTS.animation.easing.easeInOut}`
                }}
              >
                ðŸŽ® Create Your Character
              </MaterialButton>

              <div className="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-4xl mt-8">
                <MaterialCard sx={{ background: LAYOUT_CONSTANTS.commonStyles.glass.background, border: LAYOUT_CONSTANTS.commonStyles.glass.border, borderRadius: LAYOUT_CONSTANTS.borderRadius.lg, padding: LAYOUT_CONSTANTS.spacing.lg, textAlign: 'center' }}>
                  <h3 className="text-text-primary mb-2 text-xl">ðŸ° Dynamic World</h3>
                  <p className="text-text-secondary text-sm">Explore procedurally generated terrain with biomes, rivers, and cataclysmic events</p>
                </MaterialCard>

                <MaterialCard
                  sx={{
                    background: LAYOUT_CONSTANTS.commonStyles.glass.background,
                    border: LAYOUT_CONSTANTS.commonStyles.glass.border,
                    borderRadius: LAYOUT_CONSTANTS.borderRadius.lg,
                    padding: LAYOUT_CONSTANTS.spacing.lg,
                    textAlign: 'center'
                  }}
                >
                  <h3 className="text-text-primary mb-2 text-xl">
                    âš”ï¸ Class System
                  </h3>
                  <p className="text-text-secondary text-sm">
                    Choose from Knight, Rogue, or Mage with unique abilities and playstyles
                  </p>
                </MaterialCard>

                <MaterialCard
                  sx={{
                    background: LAYOUT_CONSTANTS.commonStyles.glass.background,
                    border: LAYOUT_CONSTANTS.commonStyles.glass.border,
                    borderRadius: LAYOUT_CONSTANTS.borderRadius.lg,
                    padding: LAYOUT_CONSTANTS.spacing.lg,
                    textAlign: 'center'
                  }}
                >
                  <h3 className="text-text-primary mb-2 text-xl">
                    ðŸŽ¨ Rich Animations
                  </h3>
                  <p className="text-text-secondary text-sm">
                    Experience smooth GSAP animations and hand-drawn effects throughout your journey
                  </p>
                </MaterialCard>
              </div>
            </div>
          ) : (
            // Game Canvas
            <div className="w-full h-full max-w-full max-h-full overflow-hidden">
              <GameCanvas />
            </div>
          )}
        </div>

  {/* Sidebar is rendered by BaseLayout */}
      </div>
    </>
  );
};

export default PlayLayout;
</file>

<file path="packages/frontend/src/services/webSocketClient.ts">
import { io, Socket } from 'socket.io-client';
import type { Player, GameWorld } from 'shared';
import { useGameStore } from '../stores/gameStore';
import { throttledLog, throttledError, throttledWarn } from '../utils/loggingUtils';
import { EntityManager } from '../ai/EntityManager';

export interface PlayerCommand {
  type: 'move' | 'move_to' | 'attack' | 'pickup' | 'use_item' | 'start_cataclysm';
  playerId: string;
  data?: any;
}

export interface CommandResult {
  command: string;
  success: boolean;
  message: string;
  data?: any;
}

export class WebSocketClient {
  private socket: Socket | null = null;
  private isConnected = false;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private hasJoinedGame = false; // Add flag to prevent duplicate joins
  private entityManager: EntityManager | null = null;

  constructor() {
    this.connect();
  }

  public setEntityManager(entityManager: EntityManager): void {
    this.entityManager = entityManager;
  }

  // Connection management
  private connect(): void {
    try {
      // Use environment variable for the backend URL
      // Prefer an explicit WebSocket URL if provided, otherwise use the backend URL or connect to same-origin
      const backendUrl = import.meta.env.VITE_WS_URL || import.meta.env.VITE_BACKEND_URL || undefined;
      // Log resolved URL so runtime mismatches (e.g., localhost:3001) are visible in console
      // eslint-disable-next-line no-console
      console.debug('[WS] Resolved backend URL:', backendUrl);

      this.socket = io(backendUrl, {
        autoConnect: true,
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionAttempts: this.maxReconnectAttempts,
        transports: ['websocket', 'polling'],
        timeout: 5000,
      });

      this.setupEventHandlers();
    } catch (error) {
      throttledError('WS_CONNECT', `Failed to create WebSocket connection: ${error}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.socket) return;

    // Connection events
    this.socket.on('connect', () => {
      throttledLog('WS_CONNECTED', `Connected to game server - Socket ID: ${this.socket?.id}`);
      this.isConnected = true;
      this.reconnectAttempts = 0;

      // Automatically join the game once connected (if not already joined)
      if (!this.hasJoinedGame) {
        throttledLog('WS_AUTO_JOIN', 'Automatically joining game after connection');
        const playerData = {
          id: 'player_' + Date.now(),
          displayName: 'TestPlayer',
          class: 'knight' as any,
          avatar: 'ðŸ¤ '
        };
        this.joinGameInternal(playerData);
      }
    });

    this.socket.on('disconnect', (reason) => {
      throttledWarn('WS_DISCONNECTED', `Disconnected from game server: ${reason}`);
      this.isConnected = false;
      if (reason === 'io server disconnect') {
        // The server intentionally disconnected the socket.
        // It will not automatically reconnect.
        this.socket?.connect();
      }
    });

    this.socket.on('connect_error', (error) => {
      // The error object may be a plain Error or a string; normalize for logging
      const msg = (error && (error.message || error.toString())) || String(error);
      throttledError('WS_CONNECT_ERROR', `Connection error: ${msg}`);
      this.reconnectAttempts++;
      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        throttledError('WS_MAX_ATTEMPTS', 'Max reconnection attempts reached - giving up');
        useGameStore.getState().setGameMessage('Failed to connect to game server. Please refresh the page.');
      }
    });

    // Game events
  this.socket.on('game_joined', (data: { player: Player; gameWorld: GameWorld }) => {
    throttledLog('GAME_JOINED', `Successfully joined game: ${data.player.displayName}`, true);
    useGameStore.getState().setCurrentPlayer(data.player);
    useGameStore.getState().setGameWorld(data.gameWorld);
    useGameStore.getState().setGameMessage(`Welcome to the game, ${data.player.displayName}!`);
    this.hasJoinedGame = true;
  });    this.socket.on('game_state_delta', (deltas: any[]) => {
      // Handle delta updates by applying them to the current game world
      const gameStore = useGameStore.getState();
      const currentWorld = gameStore.gameWorld;
      if (!currentWorld) return;

      const newWorld = { ...currentWorld };

      // Apply deltas to update the game world
      for (const delta of deltas) {
        switch (delta.type) {
          case 'players':
            newWorld.players = delta.data;
            break;
          case 'npcs':
            newWorld.npcs = delta.data;
            break;
          case 'items':
            newWorld.items = delta.data;
            break;
        }
      }

      // Update the store with the modified world
      gameStore.setGameWorld(newWorld);

      // Update current player if it was affected
      const currentPlayerId = gameStore.currentPlayer?.id;
      if (currentPlayerId) {
        const updatedPlayer = newWorld.players.find(p => p.id === currentPlayerId);
        if (updatedPlayer) {
          gameStore.setCurrentPlayer(updatedPlayer);
        }
      }
    });

    this.socket.on('player_joined', (data: { player: Player }) => {
      throttledLog('PLAYER_JOINED', `${data.player.displayName} joined the game`);
      // The game state update will handle adding the player to the world
    });

    this.socket.on('player_left', (data: { playerId: string; player: Player }) => {
      throttledLog('PLAYER_LEFT', `${data.player.displayName} left the game`);
      // The game state update will handle removing the player from the world
    });

    this.socket.on('command_result', (result: CommandResult) => {
      if (result.success) {
        useGameStore.getState().setGameMessage(result.message);
      } else {
        useGameStore.getState().setGameMessage(`Error: ${result.message}`);
      }

      // Clear message after 3 seconds
      setTimeout(() => {
        useGameStore.getState().clearMessage();
      }, 3000);
    });

    this.socket.on('error', (error: { message: string }) => {
      throttledError('SERVER_ERROR', `Server error: ${error.message}`);
      useGameStore.getState().setGameMessage(`Server error: ${error.message}`);
    });

    // Tarkov-style looting events
    this.socket.on('item_reveal_update', (data: { itemId: string; revealProgress: number }) => {
      throttledLog('ITEM_REVEAL_UPDATE', `Item ${data.itemId} reveal progress: ${data.revealProgress}`);
      // Update item reveal progress in the game world
      const currentWorld = useGameStore.getState().gameWorld;
      if (currentWorld) {
        const item = currentWorld.items.find(i => i.id === data.itemId);
        if (item) {
          item.revealProgress = data.revealProgress;
          useGameStore.getState().setGameWorld({ ...currentWorld });
        }
      }
    });

    this.socket.on('loot_success', (data: { item: any }) => {
      throttledLog('LOOT_SUCCESS', `Successfully looted ${data.item.name}`);
      useGameStore.getState().setGameMessage(`Successfully looted ${data.item.name}!`);
    });

    this.socket.on('loot_failure', (data: { reason: string }) => {
      throttledWarn('LOOT_FAILURE', `Loot failed: ${data.reason}`);
      useGameStore.getState().setGameMessage(`Loot failed: ${data.reason}`);
    });

    this.socket.on('ai_message', (data: { senderId: number, receiverId: number, message: string, extraInfo: any }) => {
      useGameStore.getState().messageDispatcher.dispatchMessage(0, data.senderId, data.receiverId, data.message, data.extraInfo);
    });
  }

  // Public methods for game actions
  public joinGame(playerData: Partial<Player>): void {
    if (!this.socket || !this.isConnected) {
      throttledError('CLIENT_ERROR', `Cannot join game - socket: ${!!this.socket}, connected: ${this.isConnected}`);
      useGameStore.getState().setGameMessage('Not connected to game server');
      return;
    }

    this.joinGameInternal(playerData);
  }

  // Allow client to explicitly leave the game (remove player from server world)
  public leaveGame(playerId?: string): void {
    if (!this.socket || !this.isConnected) {
      throttledWarn('CLIENT_LEAVE', 'Cannot leave game - not connected');
      return;
    }

    try {
      const pid = playerId || useGameStore.getState().currentPlayer?.id;
      if (!pid) {
        throttledWarn('CLIENT_LEAVE', 'No player id available to leave');
        return;
      }
      this.socket.emit('leave_game', { playerId: pid });
      // Optionally disconnect socket to fully clear client state
      // this.disconnect();
      throttledLog('CLIENT_LEAVE', `Requested leave for player ${pid}`);
    } catch (err) {
      throttledError('CLIENT_LEAVE_ERROR', `Failed to send leave_game: ${err}`);
    }
  }

  private joinGameInternal(playerData: Partial<Player>): void {
    if (!this.socket) return;

    throttledLog('CLIENT_JOIN', `Joining game with player data`, true);
    this.socket.emit('join_game', playerData);
    this.hasJoinedGame = true;
  }

  public sendPlayerCommand(command: Omit<PlayerCommand, 'playerId'>): void {
    if (!this.socket || !this.isConnected) {
      throttledError('CLIENT_ERROR', `Cannot send command - socket: ${!!this.socket}, connected: ${this.isConnected}`);
      useGameStore.getState().setGameMessage('Not connected to game server');
      return;
    }

    const currentPlayer = useGameStore.getState().currentPlayer;
    if (!currentPlayer) {
      throttledError('CLIENT_ERROR', `No current player found when sending command: ${JSON.stringify(command)}`);
      useGameStore.getState().setGameMessage('No current player found');
      return;
    }

    const fullCommand: PlayerCommand = {
      ...command,
      playerId: currentPlayer.id
    };

    this.socket.emit('player_command', fullCommand);
  }

  // Specific command methods for easier use
  public movePlayer(direction: 'up' | 'down' | 'left' | 'right'): void {
    this.sendPlayerCommand({
      type: 'move',
      data: { direction }
    });
  }

  public moveTo(target: { x: number; y: number }): void {
    this.sendPlayerCommand({
      type: 'move_to',
      data: { target }
    });
  }

  public attackPlayer(targetId: string): void {
    this.sendPlayerCommand({
      type: 'attack',
      data: { targetId }
    });
  }

  public pickupItem(itemId: string): void {
    this.sendPlayerCommand({
      type: 'pickup',
      data: { itemId }
    });
  }

  public useItem(itemId: string): void {
    this.sendPlayerCommand({
      type: 'use_item',
      data: { itemId }
    });
  }

  public startCataclysm(): void {
    this.sendPlayerCommand({
      type: 'start_cataclysm'
    });
  }

  // Tarkov-style looting commands
  public inspectItem(itemId: string): void {
    if (!this.socket || !this.isConnected) {
      throttledError('CLIENT_ERROR', 'Cannot inspect item - not connected');
      useGameStore.getState().setGameMessage('Not connected to game server');
      return;
    }

    const currentPlayer = useGameStore.getState().currentPlayer;
    if (!currentPlayer) {
      throttledError('CLIENT_ERROR', 'No current player found when inspecting item');
      useGameStore.getState().setGameMessage('No current player found');
      return;
    }

    this.socket.emit('inspect_item', itemId);
  }

  public lootItem(itemId: string): void {
    if (!this.socket || !this.isConnected) {
      throttledError('CLIENT_ERROR', 'Cannot loot item - not connected');
      useGameStore.getState().setGameMessage('Not connected to game server');
      return;
    }

    const currentPlayer = useGameStore.getState().currentPlayer;
    if (!currentPlayer) {
      throttledError('CLIENT_ERROR', 'No current player found when looting item');
      useGameStore.getState().setGameMessage('No current player found');
      return;
    }

    this.socket.emit('loot_item', itemId);
  }

  public createNewCharacter(characterData: any): Promise<Player> {
    return new Promise((resolve, reject) => {
      if (!this.socket) {
        return reject(new Error('WebSocket is not connected.'));
      }

      this.socket.emit('create_character', {
        characterData,
        timestamp: Date.now()
      });

      const onCharacterCreated = (response: { success: boolean; player: Player; error?: string }) => {
        cleanup();
        if (response.success) {
          resolve(response.player);
        } else {
          reject(new Error(response.error || 'Failed to create character.'));
        }
      };

      const onError = (error: { message: string }) => {
        cleanup();
        reject(new Error(error.message));
      };

      const cleanup = () => {
        this.socket?.off('character_created', onCharacterCreated);
        this.socket?.off('error', onError);
      }

      this.socket.once('character_created', onCharacterCreated);
      this.socket.once('error', onError);
    });
  }

  // Connection status
  public getConnectionStatus(): boolean {
    return this.isConnected;
  }

  public getReconnectAttempts(): number {
    return this.reconnectAttempts;
  }

  // Cleanup
  public disconnect(): void {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }

    this.isConnected = false;
  }

  // Singleton pattern
  private static instance: WebSocketClient | null = null;

  public static getInstance(): WebSocketClient {
    if (!WebSocketClient.instance) {
      WebSocketClient.instance = new WebSocketClient();
    }
    return WebSocketClient.instance;
  }
}

// Export singleton instance
export const webSocketClient = WebSocketClient.getInstance();
</file>

<file path="packages/shared/src/types/game.ts">
// Core Game Types for Chat Grid Chronicles
import { CharacterClass, CharacterVisual, ClassAbility } from './characterClasses';
import { BiomeType } from './biomes';

export enum SocketEvents {
  CONNECT = 'connect',
  DISCONNECT = 'disconnect',
  JOIN_GAME = 'join_game',
  GAME_JOINED = 'game_joined',
  PLAYER_COMMAND = 'player_command',
  COMMAND_RESULT = 'command_result',
  GAME_STATE_UPDATE = 'game_state_update',
  PLAYER_JOINED = 'player_joined',
  PLAYER_DISCONNECTED = 'player_disconnected',
  ERROR = 'error',
}

export interface Position {
  x: number;
  y: number;
}

export interface Stats {
  hp: number;
  maxHp: number;
  attack: number;
  defense: number;
  speed: number;
}

export enum BuildingType {
  HOUSE = 'house',
  CASTLE = 'castle',
  TOWER = 'tower',
  SHOP = 'shop',
  TAVERN = 'tavern',
  TEMPLE = 'temple',
  FARM = 'farm',
  MILL = 'mill',
  BRIDGE = 'bridge',
  WALL = 'wall',
  GATE = 'gate',
  RUINS = 'ruins',
  SHRINE = 'shrine',
  WATCHTOWER = 'watchtower',
  STABLES = 'stables',
  BLACKSMITH = 'blacksmith',
  LIBRARY = 'library',
  LABORATORY = 'laboratory',
  WAREHOUSE = 'warehouse',
  BUNKER = 'bunker'
}

export enum Buff {
  HealthRegen = 'HealthRegen',
  ManaRegen = 'ManaRegen',
  DamageBoost = 'DamageBoost',
  SpeedBoost = 'SpeedBoost',
}

export enum PlayerClass {
  KNIGHT = 'knight',
  ROGUE = 'rogue',
  MAGE = 'mage'
}

export enum ItemType {
  WEAPON = 'weapon',
  ARMOR = 'armor',
  UTILITY = 'utility',
  CONSUMABLE = 'consumable'
}

export enum ItemRarity {
  COMMON = 'common',
  UNCOMMON = 'uncommon',
  RARE = 'rare',
  EPIC = 'epic',
  LEGENDARY = 'legendary'
}

export enum MovementStyle {
  GRID = 'grid',
  FREE = 'free',
  HYBRID = 'hybrid'
}

export enum Theme {
  DARK = 'dark',
  LIGHT = 'light',
  NIGHT = 'night',
  AUTO = 'auto'
}

export enum NotificationType {
  DESKTOP = 'desktop',
  SOUND = 'sound',
  INGAME = 'ingame'
}

export interface Terrain {
  type: BiomeType;
  position: Position;
  movementCost: number;
  defenseBonus: number;
  visibilityModifier: number;
}

export interface Building {
  id:string;
  type: BuildingType;
  emoji: string;
  roughSvg?: string;
  position: Position;
  name: string;
  description: string;
  size: { width: number; height: number }; // in grid tiles
  isAccessible: boolean;
  providesBuff?: Buff;
  spawnChance: number;
  terrainPreference: BiomeType[]; // Which terrain types this building prefers
}

export interface Player {
  id: string;
  name?: string; // Made optional for backward compatibility
  twitchUsername?: string; // Made optional for new character creation system
  displayName: string;
  avatar: string; // emoji
  position: Position;
  class: PlayerClass;
  characterClass?: CharacterClass;
  visual?: CharacterVisual;
  health: number; // Added to player
  mana: number; // Added to player
  stamina: number; // Added to player
  hunger: number; // Added to player
  thirst: number; // Added to player
  stats: Stats;
  characterStats?: {
    vitality: number;
    intellect: number;
    agility: number;
    perception: number;
    resonance: number;
    scavenge: number;
  };
  abilities?: ClassAbility[];
  resources?: { [key: string]: number };
  level: number;
  experience: number;
  inventory: Item[];
  equipment: {
    weapon?: Item;
    armor?: Item;
    accessory?: Item;
  };
  achievements: string[];
  titles: string[];
  isAlive: boolean;
  lastMoveTime: number;
  spawnTime: number;
  connected: boolean; // Track if player is currently connected
  lastActive: number; // Timestamp of last activity for cleanup
  buffs?: Buff[]; // Added to player
  bio?: string;
}

export interface PlayerProfile {
  id: string;
  displayName: string;
  avatar: string;
  class: PlayerClass;
  level: number;
  bio: string;
  achievements: string[];
  titles: string[];
}

export interface JoinGameData {
  id: string;
  displayName: string;
  class: PlayerClass;
  avatar?: string;
  position?: Position;
}

export interface Item {
  id: string;
  name: string;
  type: ItemType;
  rarity: ItemRarity;
  description: string;
  stats?: Partial<Stats>;
  specialEffect?: string;
  position?: Position; // for items on ground
  ownerId?: string; // for items in inventory
  durability?: number;
  maxDurability?: number;
  // Tarkov-style looting properties
  isHidden: boolean; // Item starts hidden and must be revealed
  revealStartTime?: number; // When the reveal process started
  revealDuration: number; // How long it takes to fully reveal (based on rarity)
  revealProgress: number; // 0-1, how much of the item is revealed
  lastInteractionTime?: number; // Last time player interacted with this item
  canBeLooted: boolean; // Whether the item can be picked up
}

export interface NPC {
  id: string;
  name: string;
  type: string;
  position: Position;
  stats: Stats;
  behavior: 'aggressive' | 'defensive' | 'passive' | 'wandering';
  lootTable: Item[];
  isAlive: boolean;
  lastMoveTime: number;
}

export interface BoundingBox {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
}

export interface Biome {
  type: BiomeType;
  cells: Position[];
  bounds: BoundingBox;
}

export interface GameWorld {
  id: string;
  grid: Terrain[][];
  players: Player[];
  npcs: NPC[];
  items: Item[];
  buildings: Building[];
  cataclysmCircle: {
    center: Position;
    radius: number;
    isActive: boolean;
    shrinkRate: number;
    nextShrinkTime: number;
  };
  cataclysmRoughnessMultiplier: number; // Multiplier for terrain roughness during cataclysm (1.0 = normal, higher = more chaotic)
  worldAge: number;
  lastResetTime: number;
  phase: 'exploration' | 'cataclysm' | 'rebirth';
}

export interface GameState {
  world: GameWorld;
  activePlayers: Map<string, Player>;
  chatCommands: ChatCommand[];
  gameSettings: GameSettings;
}

export interface ChatCommand {
  id: string;
  username: string;
  command: string;
  args: string[];
  timestamp: number;
  processed: boolean;
}

export interface GameSettings {
  gridWidth: number;
  gridHeight: number;
  tileSize: number; // Standard tile size in pixels for UI rendering
  maxPlayers: number;
  cataclysmDuration: number;
  spawnCost: number; // channel points
  autoWanderCost: number;
  baseStats: Record<PlayerClass, Stats>;
  terrainConfig: Record<BiomeType, {
    movementCost: number;
    defenseBonus: number;
    visibilityModifier: number;
    spawnChance: number;
  }>;
  nightMode: boolean; // Toggle for night time rendering effects
  // Tarkov-style looting settings
  lootingEnabled: boolean;
  itemRevealTimes: Record<ItemRarity, number>; // Reveal duration in milliseconds for each rarity
  maxItemsPerTile: number; // Maximum items that can spawn in one tile
  itemSpawnRate: number; // Chance of item spawning when terrain regenerates
  lootInteractionRadius: number; // How close player needs to be to interact with loot
}

export interface BattleResult {
  winner: Player | NPC;
  loser: Player | NPC;
  damage: number;
  experience: number;
  loot?: Item[];
  timestamp: number;
}

export interface GameEvent {
  id: string;
  type: 'player_join' | 'player_move' | 'battle' | 'item_drop' | 'cataclysm_start' | 'world_reset';
  data: any;
  timestamp: number;
}

// Socket.io event types
export interface ServerToClientEvents {
  world_update: (world: GameWorld) => void;
  player_update: (player: Player) => void;
  battle_result: (result: BattleResult) => void;
  game_event: (event: GameEvent) => void;
  chat_response: (message: string) => void;
  // Tarkov-style looting events
  item_reveal_update: (itemId: string, revealProgress: number) => void;
  loot_success: (item: Item) => void;
  loot_failure: (reason: string) => void;
}

export interface ClientToServerEvents {
  join_game: (playerData: Partial<Player>) => void;
  move_player: (direction: 'up' | 'down' | 'left' | 'right') => void;
  use_item: (itemId: string) => void;
  chat_command: (command: string) => void;
  // Tarkov-style looting events
  loot_item: (itemId: string) => void;
  inspect_item: (itemId: string) => void;
}

// Unified Settings Types
export interface PlayerGameSettings {
  // General Game Settings
  autoSaveEnabled: boolean;
  tutorialEnabled: boolean;
  minimapEnabled: boolean;
  showNPCNames: boolean;
  showItemNames: boolean;
  movementStyle: MovementStyle;

  // Combat Settings
  showDamageNumbers: boolean;
  autoCombatEnabled: boolean;
}

export interface AudioSettings {
  // Volume Controls
  audioMasterVolume: number;
  sfxVolume: number;
  musicVolume: number;

  // Toggle Controls
  soundEnabled: boolean;
  musicEnabled: boolean;
}

export interface NotificationSettings {
  // General Notifications
  desktopNotifications: boolean;
  soundNotifications: boolean;
  battleNotifications: boolean;
  systemNotifications: boolean;

  // Event-specific Notification Types
  playerJoinNotifications: NotificationType[];
  itemDropNotifications: NotificationType[];
  levelUpNotifications: NotificationType[];
  cataclysmNotifications: NotificationType[];
}

export interface VisualSettings {
  // Theme & Appearance
  theme: Theme;
  language: string;
  fontSize: number;

  // Accessibility
  highContrast: boolean;
  reduceMotion: boolean;

  // Visual Display
  showGrid: boolean;
  showParticles: boolean;
  showHealthBars: boolean;
  backgroundColor: string;

  // Performance Settings
  renderScale: number; // 0.25-1.0, lower values render at smaller resolution for better performance
}

export interface WorldSettings {
  // World Dimensions
  worldWidth: number;
  worldHeight: number;

  // Terrain Animation
  grassWaveSpeed: number;
  treeSwaySpeed: number;
  flowerSpawnRate: number;
  windSpeed: number;

  // World Rendering
  nightMode: boolean;
}

export interface AnimationSettings {
  // Animation Controls
  animationSpeed: number;
  breathingRate: number;
  particleCount: number;

  // Visual Display Settings
  showParticles: boolean;
  showGrid: boolean;

  // Terrain Animation
  grassWaveSpeed: number;
  treeSwaySpeed: number;
  flowerSpawnRate: number;
  windSpeed: number;

  // Rough.js Settings
  roughness: number;
  bowing: number;
  fillWeight: number;
  hachureAngle: number;
  hachureGap: number;
  fillStyle?: string;
  seed?: number;
  strokeWidth: number;
  simplification: number;
  dashOffset: number;
  dashGap: number;
  zigzagOffset: number;
  curveFitting: number;
  curveTightness: number;
  curveStepCount: number;
  fillShapeRoughnessGain: number;
  disableMultiStroke: boolean;
  disableMultiStrokeFill: boolean;
  preserveVertices: boolean;
}

// Combined Settings Type
export interface UnifiedSettings {
  game: PlayerGameSettings;
  audio: AudioSettings;
  notifications: NotificationSettings;
  visual: VisualSettings;
  world: WorldSettings;
  animations: AnimationSettings;
}

// Auto-wander types
export interface WanderSettings {
  maxRiskLevel: number;
  stopOnDanger: boolean;
  maxDistance: number;
  avoidHighLevelAreas: boolean;
  prioritizeLoot: string[];
}

export interface DangerAssessment {
  level: number;
  threats: string[];
}

export type DangerLevel = number;

// Tarkov-style looting types
export interface LootingSession {
  playerId: string;
  buildingId: string;
  startTime: number;
  duration: number;
  revealedItems: Item[];
  totalItems: number;
  canceled: boolean;
}

export interface LootResult {
  success: boolean;
  message: string;
}

// Hand-drawn building types
export interface HandDrawnBuilding {
  type: BuildingType;
  size: { width: number; height: number };
  roughSvg: string;
  lootCapacity: number;
  searchTime: number;
  dangerLevel: number;
}

// Legacy AnimationSettings interface (keeping for compatibility)
export interface AnimationSettingsLegacy {
  animationSpeed: number;
  showGrid: boolean;
  roughness: number;
  bowing: number;
  fillWeight: number;
  hachureAngle: number;
  hachureGap: number;
  windSpeed?: number;
  grassWaveSpeed?: number;
  treeSwaySpeed?: number;
  flowerSpawnRate?: number;
  showParticles?: boolean;
  breathingRate?: number;
  particleCount?: number;
}
</file>

<file path="packages/backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "jest --config=jest.config.js",
    "dev": "nodemon src/index.ts",
    "test:join": "node ./scripts/join-and-move.js",
    "build": "tsc"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@google/genai": "^1.29.1",
    "axios": "^1.11.0",
    "compression": "^1.8.1",
    "cors": "^2.8.5",
    "express": "^4.21.2",
    "express-rate-limit": "^8.1.0",
    "express-validator": "^7.3.0",
    "helmet": "^8.1.0",
    "jsdom": "^22.1.0",
    "lru-cache": "^11.2.2",
    "shared": "workspace:*",
    "socket.io": "^4.8.1",
    "svg2roughjs": "^3.2.1",
    "tmi.js": "^1.8.5"
  },
  "devDependencies": {
    "@types/compression": "^1.8.1",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/express-rate-limit": "^6.0.2",
    "@types/jest": "^29.5.14",
    "@types/jsdom": "^21.1.7",
    "@types/node": "^24.3.0",
    "@types/supertest": "^6.0.3",
    "@types/tmi.js": "^1.8.6",
    "jest": "^29.7.0",
    "nodemon": "^3.1.10",
    "socket.io-client": "^4.7.5",
    "supertest": "^7.1.4",
    "ts-jest": "^29.4.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.2"
  }
}
</file>

<file path="packages/frontend/src/ai/index.ts">
// packages/frontend/src/ai/index.ts

export * from './GameEntity';
export * from './EntityManager';
export * from './AITypes';
</file>

<file path="packages/frontend/package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "pnpm build:shared && vite",
    "build:shared": "pnpm --filter shared build",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@fontsource/noto-emoji": "^5.2.7",
    "@mui/icons-material": "^5.18.0",
    "@mui/material": "^5.18.0",
    "@svgmoji/noto": "^3.2.0",
    "@types/lodash": "^4.17.20",
    "@types/react-grid-layout": "^1.3.5",
    "gsap": "^3.13.0",
    "is-unicode-supported": "^2.1.0",
    "lodash": "^4.17.21",
    "poisson-disk-sampling": "^2.3.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-grid-layout": "^1.5.2",
    "react-router-dom": "^6.8.0",
    "rough-notation": "^0.5.1",
    "roughjs": "^4.6.6",
    "simplex-noise": "^4.0.3",
    "simplify-js": "^1.2.4",
    "socket.io-client": "^4.7.2",
    "svg2roughjs": "^3.2.1",
    "svgmoji": "^3.2.0",
    "three": "^0.181.0",
    "tone": "^14.7.77",
    "twemoji": "^14.0.2",
    "zod": "^4.1.12",
    "zod-to-json-schema": "^3.24.6",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.13",
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.1.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@typescript-eslint/eslint-plugin": "^8.20.0",
    "@typescript-eslint/parser": "^8.20.0",
    "@vitejs/plugin-react": "^4.3.4",
    "@vitest/ui": "^2.1.8",
    "canvas": "^3.2.0",
    "eslint": "^9.18.0",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "jsdom": "^25.0.1",
    "typescript": "^5.7.3",
    "vite": "^6.0.7",
    "vitest": "^2.1.8"
  }
}
</file>

<file path="packages/frontend/src/ai/AITypes.ts">
// packages/frontend/src/ai/AITypes.ts

import { GameEntity } from './GameEntity';

export type AIEntity = GameEntity;

export interface ITelegram {
  sender: number;
  receiver: number;
  message: string;
  dispatchTime: number;
  extraInfo?: unknown;
}
</file>

<file path="packages/frontend/src/stores/gameStore.ts">
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

// Import types from shared package
import type { GameWorld, Player, UnifiedSettings } from 'shared';
import { MovementStyle, Theme, NotificationType } from 'shared';

// Import notification types
import type { NotificationData } from '../types/notification';

// Import WebSocket client
import { webSocketClient } from '../services/webSocketClient';
import { createMockGameWorld } from '../services/worldGeneration/WorldGenerator';
import { EntityManager, Time, MessageDispatcher } from '../ai';

interface GameState {
  // Core game state
  gameWorld: GameWorld | null;
  currentPlayer: Player | null;
  selectedPlayerId: string | null;

  // UI state
  selectedTab: string;
  gameMessage: string;
  showDevPanel: boolean;
  isLoading: boolean;
  error: string | null;
  lastUpdate: number;

  // Notifications state
  notifications: NotificationData[];

  // Performance and caching
  cache: Map<string, any>;
  performanceMetrics: {
    renderTime: number;
    updateFrequency: number;
    memoryUsage: number;
  };

  // Unified settings state
  unifiedSettings: UnifiedSettings;

  // AI System State
  entityManager: EntityManager;
  time: Time;
  messageDispatcher: MessageDispatcher;

  // Actions
  updateAI: () => void;
  setGameWorld: (world: GameWorld) => void;
  setCurrentPlayer: (player: Player | null) => void;
  setSelectedPlayerId: (playerId: string | null) => void;
  setSelectedTab: (tab: string) => void;
  setGameMessage: (message: string) => void;
  setShowDevPanel: (show: boolean) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  updateGameSettings: (settings: Partial<UnifiedSettings['game']>) => void;
  updateAudioSettings: (settings: Partial<UnifiedSettings['audio']>) => void;
  updateNotificationSettings: (settings: Partial<UnifiedSettings['notifications']>) => void;
  updateVisualSettings: (settings: Partial<UnifiedSettings['visual']>) => void;
  updateWorldSettings: (settings: Partial<UnifiedSettings['world']>) => void;
  updateAnimationSettings: (settings: Partial<UnifiedSettings['animations']>) => void;
  updateUnifiedSettings: (settings: Partial<UnifiedSettings>) => void;

  // Sidebar UI state
  sidebarCollapsed: boolean;
  setSidebarCollapsed: (collapsed: boolean) => void;

  // Notification actions
  addNotification: (notification: Omit<NotificationData, 'id'>) => void;
  removeNotification: (id: string) => void;
  clearNotifications: () => void;

  // Settings resets
  resetGameSettings: () => void;
  resetAudioSettings: () => void;
  resetNotificationSettings: () => void;
  resetVisualSettings: () => void;
  resetWorldSettings: () => void;
  resetAnimationSettings: () => void;
  resetAllSettings: () => void;
  exportSettings: () => string;
  importSettings: (settingsJson: string) => boolean;

  // Game actions
  joinGame: (playerData: Partial<Player>) => void;
  handleRegenerateWorld: () => void;
  handleCreateCharacter: (characterData: any) => Promise<void>;
  movePlayer: (direction: 'up' | 'down' | 'left' | 'right') => void;
  moveTo: (target: { x: number; y: number }) => void;
  attackPlayer: (targetId: string) => void;
  pickupItem: (itemId: string) => void;
  useItem: (itemId: string) => void;
  startCataclysm: () => void;
  clearMessage: () => void;
  handleJoinGame: (characterData?: { displayName: string; class: any; avatar: string }) => void;
  handleStartCataclysm: () => void;
  handlePickUpItem: () => void;

  // Utility functions
  getPlayerById: (id: string) => Player | undefined;
  getNearbyPlayers: (radius?: number) => Player[];
  getGameStats: () => { totalPlayers: number; activePlayers: number; worldAge: number };
  validateSettings: (settings: Partial<UnifiedSettings>) => boolean;
  getSetting: <K extends keyof UnifiedSettings>(category: K) => UnifiedSettings[K];
  updatePerformanceMetrics: (metrics: Partial<GameState['performanceMetrics']>) => void;
  clearCache: () => void;
}

// Default unified settings with all the default values
const createDefaultUnifiedSettings = (): UnifiedSettings => ({
  game: {
    // General Game Settings
    autoSaveEnabled: true,
    tutorialEnabled: true,
    minimapEnabled: true,
    showNPCNames: true,
    showItemNames: true,
    movementStyle: MovementStyle.GRID,

    // Combat Settings
    showDamageNumbers: true,
    autoCombatEnabled: false,
  },

  audio: {
    // Volume Controls
    audioMasterVolume: 80,
    sfxVolume: 70,
    musicVolume: 60,

    // Toggle Controls
    soundEnabled: true,
    musicEnabled: true,
  },

  notifications: {
    // General Notifications
    desktopNotifications: true,
    soundNotifications: true,
    battleNotifications: true,
    systemNotifications: true,

    // Event-specific Notification Types
    playerJoinNotifications: [NotificationType.DESKTOP, NotificationType.SOUND, NotificationType.INGAME],
    itemDropNotifications: [NotificationType.SOUND, NotificationType.INGAME],
    levelUpNotifications: [NotificationType.DESKTOP, NotificationType.SOUND, NotificationType.INGAME],
    cataclysmNotifications: [NotificationType.DESKTOP, NotificationType.INGAME],
  },

  visual: {
    // Theme & Appearance
    theme: Theme.DARK,
    language: 'en',
    fontSize: 100,

    // Accessibility
    highContrast: false,
    reduceMotion: false,

    // Visual Display
    showGrid: true,
    showParticles: true,
    showHealthBars: true,
    backgroundColor: '#191724',

    // Performance Settings
    renderScale: 1.0,  // Full resolution for crisp rendering
  },

  world: {
    // World Dimensions
    worldWidth: 40,
    worldHeight: 30,

    // Terrain Animation
    grassWaveSpeed: 0.1,
    treeSwaySpeed: 0.025,
    flowerSpawnRate: 0.01,
    windSpeed: 0.02,

    // World Rendering
    nightMode: false,
  },

  animations: {
    // Animation Controls
    animationSpeed: 1.0,
    breathingRate: 0.05,
    particleCount: 5,

    // Visual Display (duplicated in visual for backward compatibility)
    showParticles: true,
    showGrid: true,

    // Terrain Animation (duplicated with world for backward compatibility)
    grassWaveSpeed: 0.1,
    treeSwaySpeed: 0.025,
    flowerSpawnRate: 0.01,
    windSpeed: 0.02,

    // Rough.js Settings
    roughness: 0.8,  // Reduced for cleaner lines
    bowing: 0.5,     // Reduced for straighter lines
    fillWeight: 1.5, // Balanced fill weight
    hachureAngle: 45,
    hachureGap: 3,   // Tighter gap for smoother fills
    fillStyle: 'solid', // Solid fills for cleaner look
    seed: 1, // Default seed for rough.js randomness
    strokeWidth: 4.0, // Increased for thicker lines
    simplification: 0.8,
    dashOffset: 0,
    dashGap: 0,
    zigzagOffset: 0,
    curveFitting: 0.95,
    curveTightness: 0,
    curveStepCount: 9,
    fillShapeRoughnessGain: 0.4,  // Reduced for smoother fills
    disableMultiStroke: false,
    disableMultiStrokeFill: false,
    preserveVertices: false,
  },
});

export const useGameStore = create<GameState>()(
  devtools(
    persist(
      (set, get) => {
        const entityManager = new EntityManager();
        const time = Time.getInstance();
        const messageDispatcher = MessageDispatcher.getInstance();
        messageDispatcher.setEntityManager(entityManager);
        webSocketClient.setEntityManager(entityManager);


        return {
        // Core game state
        gameWorld: null,
        currentPlayer: null,
        selectedPlayerId: null,
        selectedTab: 'status',
        gameMessage: '',
        showDevPanel: false,
        isLoading: false,
        error: null,
        lastUpdate: Date.now(),

        // Notifications state
        notifications: [],

        // Performance and caching
        cache: new Map(),
        performanceMetrics: {
          renderTime: 0,
          updateFrequency: 0,
          memoryUsage: 0,
        },

        // Unified settings state with defaults
        unifiedSettings: createDefaultUnifiedSettings(),
        // UI state: whether sidebar is collapsed (for responsive layouts)
        sidebarCollapsed: false,

        // AI System State
        entityManager,
        time,
        messageDispatcher,

        // AI Actions
        updateAI: () => {
          const { time, entityManager, messageDispatcher } = get();
          time.update();
          const delta = time.getDelta();
          entityManager.updateEntities(delta);
          messageDispatcher.dispatchDelayedMessages();
        },

        // Game actions
        joinGame: (playerData) => {
          webSocketClient.joinGame(playerData);
        },

        handleRegenerateWorld: () => {
          const newWorld = createMockGameWorld();
          set({
            gameWorld: newWorld,
            currentPlayer: newWorld.players[0],
            gameMessage: 'ðŸŒ New world generated! Explore the fresh terrain!',
          });
          setTimeout(() => set({ gameMessage: '' }), 5000);
        },

        handleCreateCharacter: async (characterData) => {
          try {
            const newPlayer = await webSocketClient.createNewCharacter(characterData);
            set({
              currentPlayer: newPlayer,
              gameMessage: `Character ${newPlayer.name} created! Welcome!`,
            });
          } catch (error) {
            set({
              error: `Error creating character: ${error.message || 'Unknown error'}`,
            });
            // Re-throw the error so the UI can also react to it
            throw error;
          }
        },

        handleJoinGame: (characterData) => {
          const playerData = characterData ? {
            id: 'player_' + Date.now(),
            displayName: characterData.displayName,
            class: characterData.class,
            avatar: characterData.avatar
          } : {
            id: 'player_' + Date.now(),
            displayName: 'TestPlayer',
            class: 'knight' as any,
            avatar: 'ðŸ¤ '
          };
          webSocketClient.joinGame(playerData);
        },

        handleStartCataclysm: () => {
          set({ gameMessage: 'Cataclysm started!' });
        },

        handlePickUpItem: () => {
          set({ gameMessage: 'Looking for items...' });
        },

        movePlayer: (direction) => {
          webSocketClient.movePlayer(direction);
        },

        moveTo: (target) => {
          webSocketClient.moveTo(target);
        },

        attackPlayer: (targetId) => {
          webSocketClient.attackPlayer(targetId);
        },

        pickupItem: (itemId) => {
          webSocketClient.pickupItem(itemId);
        },

        useItem: (itemId) => {
          webSocketClient.useItem(itemId);
        },

        startCataclysm: () => {
          webSocketClient.startCataclysm();
        },

        clearMessage: () => set({ gameMessage: '' }),

        // State setters
        setGameWorld: (world) => set({ gameWorld: world }),
        setCurrentPlayer: (player) => set({ currentPlayer: player }),
        setSelectedPlayerId: (playerId) => set({ selectedPlayerId: playerId }),
        setSelectedTab: (tab) => set({ selectedTab: tab }),
        setGameMessage: (message) => set({ gameMessage: message }),
        setShowDevPanel: (show) => set({ showDevPanel: show }),
        setLoading: (loading) => set({ isLoading: loading }),
        setError: (error) => set({ error, lastUpdate: Date.now() }),
        setSidebarCollapsed: (collapsed: boolean) => set({ sidebarCollapsed: collapsed }),
        // Notification actions
        addNotification: (notification) => set((state) => ({
          notifications: [...state.notifications, {
            ...notification,
            id: `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
          }]
        })),

        removeNotification: (id) => set((state) => ({
          notifications: state.notifications.filter(n => n.id !== id)
        })),

        clearNotifications: () => set({ notifications: [] }),

        // Utility functions
        getPlayerById: (id) => {
          const state = get();
          return state.gameWorld?.players.find(player => player.id === id);
        },

        getNearbyPlayers: (radius = 5) => {
          const state = get();
          if (!state.currentPlayer || !state.gameWorld) return [];

          const { x, y } = state.currentPlayer.position;
          return state.gameWorld.players.filter(player => {
            if (player.id === state.currentPlayer?.id) return false;
            const distance = Math.sqrt(
              Math.pow(player.position.x - x, 2) + Math.pow(player.position.y - y, 2)
            );
            return distance <= radius;
          });
        },

        getGameStats: () => {
          const state = get();
          const totalPlayers = state.gameWorld?.players.length || 0;
          const activePlayers = state.gameWorld?.players.filter(p => p.connected).length || 0;
          const worldAge = state.gameWorld?.worldAge || 0;
          return { totalPlayers, activePlayers, worldAge };
        },

        validateSettings: (settings) => {
          // Basic validation for settings
          if (!settings || typeof settings !== 'object') return false;

          // Validate volume ranges
          if (settings.audio) {
            const { audioMasterVolume, sfxVolume, musicVolume } = settings.audio;
            if (audioMasterVolume < 0 || audioMasterVolume > 100) return false;
            if (sfxVolume < 0 || sfxVolume > 100) return false;
            if (musicVolume < 0 || musicVolume > 100) return false;
          }

          // Validate font size
          if (settings.visual && (settings.visual.fontSize < 50 || settings.visual.fontSize > 200)) {
            return false;
          }

          return true;
        },

        getSetting: (category) => {
          const state = get();
          return state.unifiedSettings[category];
        },

        updatePerformanceMetrics: (metrics) => set((state) => ({
          performanceMetrics: { ...state.performanceMetrics, ...metrics },
          lastUpdate: Date.now()
        })),

        clearCache: () => set({ cache: new Map() }),

        // Settings updates
        updateGameSettings: (settings) => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            game: { ...state.unifiedSettings.game, ...settings }
          }
        })),

        updateAudioSettings: (settings) => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            audio: { ...state.unifiedSettings.audio, ...settings }
          }
        })),

        updateNotificationSettings: (settings) => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            notifications: { ...state.unifiedSettings.notifications, ...settings }
          }
        })),

        updateVisualSettings: (settings) => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            visual: { ...state.unifiedSettings.visual, ...settings }
          }
        })),

        updateWorldSettings: (settings) => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            world: { ...state.unifiedSettings.world, ...settings }
          }
        })),

        updateAnimationSettings: (settings) => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            animations: { ...state.unifiedSettings.animations, ...settings }
          }
        })),

        // Legacy update methods - kept for backward compatibility but deprecated
        updateSettings: (settings) => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            game: { ...state.unifiedSettings.game, ...settings }
          }
        })),

        updateUnifiedSettings: (settings) => set((state) => ({
          unifiedSettings: { ...state.unifiedSettings, ...settings }
        })),

        // Settings resets
        resetGameSettings: () => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            game: createDefaultUnifiedSettings().game
          }
        })),

        resetAudioSettings: () => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            audio: createDefaultUnifiedSettings().audio
          }
        })),

        resetNotificationSettings: () => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            notifications: createDefaultUnifiedSettings().notifications
          }
        })),

        resetVisualSettings: () => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            visual: createDefaultUnifiedSettings().visual
          }
        })),

        resetWorldSettings: () => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            world: createDefaultUnifiedSettings().world
          }
        })),

        resetAnimationSettings: () => set((state) => ({
          unifiedSettings: {
            ...state.unifiedSettings,
            animations: createDefaultUnifiedSettings().animations
          }
        })),

        resetAllSettings: () => set({
          unifiedSettings: createDefaultUnifiedSettings()
        }),

        exportSettings: () => {
          const state = get();
          return JSON.stringify({
            settings: state.unifiedSettings,
            version: '2.0',
            exportedAt: Date.now()
          }, null, 2);
        },

        importSettings: (settingsJson: string) => {
          try {
            const importedData = JSON.parse(settingsJson);
            if (importedData && typeof importedData === 'object') {
              // Handle legacy format (version 1.0) for backward compatibility
              if (!importedData.version || importedData.version === '1.0') {
                const legacySettings = importedData.settings || importedData;
                const legacyAnimationSettings = importedData.animationSettings || {};

                // Migrate legacy settings to unified format
                const migratedSettings: UnifiedSettings = {
                  game: {
                    autoSaveEnabled: legacySettings.autoSaveEnabled ?? true,
                    tutorialEnabled: legacySettings.tutorialEnabled ?? true,
                    minimapEnabled: legacySettings.minimapEnabled ?? true,
                    showNPCNames: legacySettings.showNPCNames ?? true,
                    showItemNames: legacySettings.showItemNames ?? true,
                    movementStyle: legacySettings.movementStyle ?? MovementStyle.GRID,
                    showDamageNumbers: legacySettings.showDamageNumbers ?? true,
                    autoCombatEnabled: legacySettings.autoCombatEnabled ?? false,
                  },
                  audio: {
                    audioMasterVolume: legacySettings.audioMasterVolume ?? 80,
                    sfxVolume: legacySettings.sfxVolume ?? 70,
                    musicVolume: legacySettings.musicVolume ?? 60,
                    soundEnabled: legacySettings.soundEnabled ?? true,
                    musicEnabled: legacySettings.musicEnabled ?? true,
                  },
                  notifications: {
                    desktopNotifications: legacySettings.desktopNotifications ?? true,
                    soundNotifications: legacySettings.soundNotifications ?? true,
                    battleNotifications: legacySettings.battleNotifications ?? true,
                    systemNotifications: legacySettings.systemNotifications ?? true,
                    playerJoinNotifications: legacySettings.playerJoinNotifications ?? [NotificationType.DESKTOP, NotificationType.SOUND, NotificationType.INGAME],
                    itemDropNotifications: legacySettings.itemDropNotifications ?? [NotificationType.SOUND, NotificationType.INGAME],
                    levelUpNotifications: legacySettings.levelUpNotifications ?? [NotificationType.DESKTOP, NotificationType.SOUND, NotificationType.INGAME],
                    cataclysmNotifications: legacySettings.cataclysmNotifications ?? [NotificationType.DESKTOP, NotificationType.INGAME],
                  },
                  visual: {
                    theme: (legacySettings.theme ?? 'dark') as Theme,
                    language: legacySettings.language ?? 'en',
                    fontSize: legacySettings.fontSize ?? 100,
                    highContrast: legacySettings.highContrast ?? false,
                    reduceMotion: legacySettings.reduceMotion ?? false,
                    // Visual overlay/display flags were previously mixed into animationSettings
                    showGrid: legacySettings.showGrid ?? legacyAnimationSettings.showGrid ?? true,
                    showParticles: legacySettings.showParticles ?? legacyAnimationSettings.showParticles ?? true,
                    showHealthBars: legacySettings.showHealthBars ?? legacyAnimationSettings.showHealthBars ?? true,
                    backgroundColor: legacySettings.backgroundColor ?? legacyAnimationSettings.backgroundColor ?? '#191724',
                    renderScale: 0.75, // Default render scale for performance
                  },
                  world: {
                    worldWidth: legacyAnimationSettings.worldWidth ?? 40,
                    worldHeight: legacyAnimationSettings.worldHeight ?? 30,
                    grassWaveSpeed: legacyAnimationSettings.grassWaveSpeed ?? 0.1,
                    treeSwaySpeed: legacyAnimationSettings.treeSwaySpeed ?? 0.025,
                    flowerSpawnRate: legacyAnimationSettings.flowerSpawnRate ?? 0.01,
                    windSpeed: legacyAnimationSettings.windSpeed ?? 0.02,
                    nightMode: false, // Default to day mode for legacy settings
                  },
                  animations: {
                    animationSpeed: legacyAnimationSettings.animationSpeed ?? 1.0,
                    breathingRate: legacyAnimationSettings.breathingRate ?? 0.05,
                    particleCount: legacyAnimationSettings.particleCount ?? legacyAnimationSettings.particles ?? 5,
                    showParticles: legacyAnimationSettings.showParticles ?? legacySettings.showParticles ?? true,
                    showGrid: legacyAnimationSettings.showGrid ?? legacySettings.showGrid ?? true,
                    grassWaveSpeed: legacyAnimationSettings.grassWaveSpeed ?? legacySettings.grassWaveSpeed ?? 0.1,
                    treeSwaySpeed: legacyAnimationSettings.treeSwaySpeed ?? legacySettings.treeSwaySpeed ?? 0.025,
                    flowerSpawnRate: legacyAnimationSettings.flowerSpawnRate ?? legacySettings.flowerSpawnRate ?? 0.01,
                    windSpeed: legacyAnimationSettings.windSpeed ?? legacySettings.windSpeed ?? 0.02,
                    roughness: legacyAnimationSettings.roughness ?? 1.5,
                    bowing: legacyAnimationSettings.bowing ?? 1.2,
                    fillWeight: legacyAnimationSettings.fillWeight ?? 1.5,
                    hachureAngle: legacyAnimationSettings.hachureAngle ?? 45,
                    hachureGap: legacyAnimationSettings.hachureGap ?? 4,
                    fillStyle: legacyAnimationSettings.fillStyle ?? 'hachure',
                    seed: legacyAnimationSettings.seed ?? 1,
                    strokeWidth: 3.0,
                    simplification: 0.8,
                    dashOffset: 0,
                    dashGap: 0,
                    zigzagOffset: 0,
                    curveFitting: 0.95,
                    curveTightness: 0,
                    curveStepCount: 9,
                    fillShapeRoughnessGain: 0.8,
                    disableMultiStroke: false,
                    disableMultiStrokeFill: false,
                    preserveVertices: false,
                  },
                };
                set({ unifiedSettings: migratedSettings });
              } else {
                // Handle new unified format
                if (importedData.settings && typeof importedData.settings === 'object') {
                  set({ unifiedSettings: { ...get().unifiedSettings, ...importedData.settings } });
                }
              }
              return true;
            }
          } catch (error) {
            console.error('Failed to import settings:', error);
          }
          return false;
        },
      }
    },
      {
        name: 'game-store-v2',
        partialize: (state) => ({
          unifiedSettings: state.unifiedSettings,
          selectedTab: state.selectedTab,
          showDevPanel: state.showDevPanel,
          // Persist the sidebar collapsed state so user preference survives reloads
          sidebarCollapsed: state.sidebarCollapsed,
        }),
        // Migration logic for upgrading from old format and to ensure defaults
        onRehydrateStorage: () => (state) => {
          if (state) {
            // Ensure sidebarCollapsed exists in persisted snapshot
            if (typeof (state as any).sidebarCollapsed === 'undefined') {
              (state as any).sidebarCollapsed = false;
            }

            // If no unifiedSettings, create from defaults (old storage will be migrated via import logic)
            if (!state.unifiedSettings) {
              state.unifiedSettings = createDefaultUnifiedSettings();
            }
          }
        }
      }
    ),
    {
      name: 'game-store-v2'
    }
  )
);
</file>

<file path="packages/backend/src/services/PlayerMovementService.ts">
import { Player, Position, GameWorld, BiomeType, MOVEMENT_CONSTANTS } from '@chatterealm/shared';

export interface MoveResult {
  success: boolean;
  message: string;
  newPosition?: Position;
  path?: Position[];
}

export interface PathfindingNode {
  position: Position;
  gCost: number;
  hCost: number;
  fCost: number;
  parent: PathfindingNode | null;
}

export class PlayerMovementService {
  private occupiedPositions: Set<string> = new Set();
  private reservedPositions: Set<string> = new Set();
  private availableSpawnPoints: Set<string> = new Set();
  private playerMovementQueues: Map<string, Position[]> = new Map();

  constructor(gameWorld: GameWorld) {
    this.initializeOccupiedPositions(gameWorld);
  }

  /**
   * Initialize occupied positions from the current game world
   */
  private initializeOccupiedPositions(gameWorld: GameWorld): void {
    this.occupiedPositions.clear();
    this.reservedPositions.clear();
    this.availableSpawnPoints.clear();

    // Mark player positions as occupied
    gameWorld.players.forEach(player => {
      if (player.isAlive) {
        this.occupiedPositions.add(`${player.position.x},${player.position.y}`);
      }
    });

    // Mark NPC positions as occupied
    gameWorld.npcs.forEach(npc => {
      if (npc.isAlive) {
        this.occupiedPositions.add(`${npc.position.x},${npc.position.y}`);
      }
    });

    // Mark building positions as occupied
    gameWorld.buildings.forEach(building => {
      for (let y = building.position.y; y < building.position.y + building.size.height; y++) {
        for (let x = building.position.x; x < building.position.x + building.size.width; x++) {
          this.occupiedPositions.add(`${x},${y}`);
        }
      }
    });

    // Populate available spawn points (non-mountain, non-occupied tiles)
    for (let y = 0; y < gameWorld.grid.length; y++) {
      for (let x = 0; x < gameWorld.grid[y].length; x++) {
        const terrain = gameWorld.grid[y][x];
        if (terrain.type !== BiomeType.MOUNTAIN && 
            !this.occupiedPositions.has(`${x},${y}`)) {
          this.availableSpawnPoints.add(`${x},${y}`);
        }
      }
    }
  }

  /**
   * Request player movement to a target position with pathfinding
   */
  public requestMoveTo(playerId: string, target: Position, gameWorld: GameWorld): MoveResult {
    const player = gameWorld.players.find(p => p.id === playerId);
    if (!player) {
      return { success: false, message: 'Player not found.' };
    }

    if (!player.isAlive) {
      return { success: false, message: 'Cannot move while defeated.' };
    }

    // Instant validation for distance
    const distance = this.getDistance(player.position, target);
    if (distance > 20) { // A reasonable limit for a single move request
      return { success: false, message: 'Target is too far.' };
    }

    // Check if target is within world bounds
    if (target.x < 0 || target.x >= gameWorld.grid[0].length || 
        target.y < 0 || target.y >= gameWorld.grid.length) {
      return { success: false, message: 'Target position is out of bounds.' };
    }

    // Check if target is accessible
    const targetTerrain = gameWorld.grid[target.y][target.x];
    if (targetTerrain.type === BiomeType.MOUNTAIN) {
      return { success: false, message: 'Cannot move to mountain terrain.' };
    }

    // Find path to target
    const path = this.findPath(player.position, target, gameWorld.grid);
    if (!path || path.length === 0) {
      return { success: false, message: 'No path found to target location.' };
    }

    // Set up movement queue for the player
    this.playerMovementQueues.set(playerId, path);

    return {
      success: true,
      message: `Movement planned to (${target.x}, ${target.y}). ${path.length} steps.`,
      path
    };
  }

  /**
   * Process a single movement step for a player
   */
  public processSinglePlayerQueueStep(playerId: string, gameWorld: GameWorld): MoveResult {
    const player = gameWorld.players.find(p => p.id === playerId);
    if (!player || !player.isAlive) {
      this.playerMovementQueues.delete(playerId);
      return { success: false, message: 'Player not found or not alive.' };
    }

    const queue = this.playerMovementQueues.get(playerId);
    if (!queue || queue.length === 0) {
      return { success: false, message: 'No movement queued.' };
    }

    const nextPosition = queue.shift()!;
    const moveResult = this.movePlayer(playerId, nextPosition, gameWorld);

    // Clear queue if movement failed or completed
    if (!moveResult.success || queue.length === 0) {
      this.playerMovementQueues.delete(playerId);
    }

    return moveResult;
  }

  /**
   * Process movement queues for all players
   */
  public processPlayerMovementQueues(gameWorld: GameWorld): void {
    for (const playerId of this.playerMovementQueues.keys()) {
      this.processSinglePlayerQueueStep(playerId, gameWorld);
    }
  }

  /**
   * Move a player to a new position
   */
  public movePlayer(playerId: string, newPosition: Position, gameWorld: GameWorld): MoveResult {
    const player = gameWorld.players.find(p => p.id === playerId);
    if (!player) {
      return { success: false, message: 'Player not found.' };
    }

    if (!player.isAlive) {
      return { success: false, message: 'Cannot move while defeated.' };
    }

    // Validate the move
    if (!this.isValidMove(player.position, newPosition, gameWorld.grid)) {
      return { success: false, message: 'Invalid move.' };
    }

    // Check if destination is occupied
    if (this.isPositionOccupied(newPosition)) {
      return { success: false, message: 'Destination is occupied.' };
    }

    // Update positions
    const oldKey = `${player.position.x},${player.position.y}`;
    const newKey = `${newPosition.x},${newPosition.y}`;
    
    this.occupiedPositions.delete(oldKey);
    this.occupiedPositions.add(newKey);
    this.availableSpawnPoints.add(oldKey);
    this.availableSpawnPoints.delete(newKey);
    
    player.position = { ...newPosition };
    player.lastMoveTime = Date.now();

    return {
      success: true,
      message: `Moved to (${newPosition.x}, ${newPosition.y}).`,
      newPosition
    };
  }

  /**
   * A* pathfinding algorithm
   */
  public findPath(start: Position, target: Position, grid: any[][], maxNodes = 20000): Position[] | null {
    const openSet: PathfindingNode[] = [];
    const closedSet: Set<string> = new Set();
    const gridHeight = grid.length;
    const gridWidth = grid[0]?.length || 0;

    if (gridWidth === 0 || gridHeight === 0) return null;

    const startNode: PathfindingNode = {
      position: start,
      gCost: 0,
      hCost: this.getDistance(start, target),
      fCost: 0,
      parent: null
    };
    startNode.fCost = startNode.gCost + startNode.hCost;

    openSet.push(startNode);
    const openSetMap: Map<string, PathfindingNode> = new Map();
    openSetMap.set(`${start.x},${start.y}`, startNode);
    let nodesProcessed = 0;

    while (openSet.length > 0 && nodesProcessed < maxNodes) {
      nodesProcessed++;

      // Find node with lowest fCost using linear scan (avoid full sort)
      let bestIndex = 0;
      for (let i = 1; i < openSet.length; i++) {
        const a = openSet[i];
        const b = openSet[bestIndex];
        if (a.fCost < b.fCost || (a.fCost === b.fCost && a.hCost < b.hCost)) {
          bestIndex = i;
        }
      }
      const currentNode = openSet.splice(bestIndex, 1)[0];
      openSetMap.delete(`${currentNode.position.x},${currentNode.position.y}`);

      const currentKey = `${currentNode.position.x},${currentNode.position.y}`;
      closedSet.add(currentKey);

      // Check if we reached the target
      if (currentNode.position.x === target.x && currentNode.position.y === target.y) {
        return this.reconstructPath(currentNode);
      }

      // Check all adjacent positions (8-directional movement)
      const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1],           [0, 1],
        [1, -1],  [1, 0],  [1, 1]
      ];

      for (const [dx, dy] of directions) {
        const neighborPos: Position = {
          x: currentNode.position.x + dx,
          y: currentNode.position.y + dy
        };

        // Check bounds
        if (neighborPos.x < 0 || neighborPos.x >= gridWidth || 
            neighborPos.y < 0 || neighborPos.y >= gridHeight) {
          continue;
        }

        const neighborKey = `${neighborPos.x},${neighborPos.y}`;
        if (closedSet.has(neighborKey)) continue;

        // Check if the neighbor is walkable
        const terrain = grid[neighborPos.y][neighborPos.x];
        if (terrain.type === BiomeType.MOUNTAIN) continue;

        // Skip if occupied (unless it's the target)
        if (this.isPositionOccupied(neighborPos) && 
            !(neighborPos.x === target.x && neighborPos.y === target.y)) {
          continue;
        }

        // Calculate movement cost (diagonal moves cost more)
        const isDiagonal = dx !== 0 && dy !== 0;
        const movementCost = isDiagonal ? 1.41 : 1.0;
        const terrainCost = terrain.movementCost || 1.0;
        const gCost = currentNode.gCost + (movementCost * terrainCost);

        // Check if this neighbor is already in the open set
        const existingNeighborKey = `${neighborPos.x},${neighborPos.y}`;
        const existingNode = openSetMap.get(existingNeighborKey);

        if (existingNode) {
          if (gCost < existingNode.gCost) {
            existingNode.gCost = gCost;
            existingNode.fCost = existingNode.gCost + existingNode.hCost;
            existingNode.parent = currentNode;
          }
        } else {
          const neighborNode: PathfindingNode = {
            position: neighborPos,
            gCost,
            hCost: this.getDistance(neighborPos, target),
            fCost: 0,
            parent: currentNode
          };
          neighborNode.fCost = neighborNode.gCost + neighborNode.hCost;
          openSet.push(neighborNode);
          openSetMap.set(neighborKey, neighborNode);
        }
      }
    }

    return null; // No path found
  }

  /**
   * Reconstruct the path from the pathfinding result
   */
  private reconstructPath(endNode: PathfindingNode): Position[] {
    const path: Position[] = [];
    let currentNode: PathfindingNode | null = endNode;

    while (currentNode !== null) {
      path.unshift(currentNode.position);
      currentNode = currentNode.parent;
    }

    // Remove the starting position only when there's more than one step
    if (path.length > 1) path.shift();
    return path;
  }

  /**
   * Calculate distance between two positions (Manhattan distance)
   */
  private getDistance(pos1: Position, pos2: Position): number {
    // Use Chebyshev distance (max of dx,dy) which is admissible for 8-directional movement
    const dx = Math.abs(pos1.x - pos2.x);
    const dy = Math.abs(pos1.y - pos2.y);
    return Math.max(dx, dy);
  }

  /**
   * Check if a move is valid
   */
  private isValidMove(from: Position, to: Position, grid: any[][]): boolean {
    if (!from) {
      return false;
    }
    // Check bounds
    if (to.x < 0 || to.x >= grid[0].length || to.y < 0 || to.y >= grid.length) {
      return false;
    }

    // Check if movement distance is valid (max 1 tile)
    const distance = Math.max(Math.abs(to.x - from.x), Math.abs(to.y - from.y));
    if (distance > MOVEMENT_CONSTANTS.MAX_MOVE_DISTANCE) {
      return false;
    }

    // Check terrain
    const terrain = grid[to.y][to.x];
    return terrain.type !== BiomeType.MOUNTAIN;
  }

  /**
   * Check if a position is occupied
   */
  public isPositionOccupied(position: Position): boolean {
    return this.occupiedPositions.has(`${position.x},${position.y}`);
  }

  /**
   * Find an empty spawn position
   */
  public findEmptySpawnPosition(): Position | null {
    if (this.availableSpawnPoints.size === 0) {
      return null;
    }

    const pointsArray = Array.from(this.availableSpawnPoints);
    const randomPoint = pointsArray[Math.floor(Math.random() * pointsArray.length)];
    const [x, y] = randomPoint.split(',').map(Number);
    
    return { x, y };
  }

  /**
   * Add a player to position tracking
   */
  public addPlayerPosition(position: Position): void {
    const key = `${position.x},${position.y}`;
    this.occupiedPositions.add(key);
    this.availableSpawnPoints.delete(key);
  }

  /**
   * Expose internal occupied positions set for coordination with other services
   */
  public getOccupiedPositions(): Set<string> {
    return this.occupiedPositions;
  }

  /**
   * Expose internal available spawn points set for coordination with other services
   */
  public getAvailableSpawnPoints(): Set<string> {
    return this.availableSpawnPoints;
  }

  /**
   * Remove a player from position tracking
   */
  public removePlayerPosition(position: Position): void {
    const key = `${position.x},${position.y}`;
    this.occupiedPositions.delete(key);
    this.availableSpawnPoints.add(key);
  }

  /**
   * Update occupied positions when game world changes
   */
  public updateOccupiedPositions(gameWorld: GameWorld): void {
    this.initializeOccupiedPositions(gameWorld);
  }

  /**
   * Get current movement queue for a player
   */
  public getPlayerMovementQueue(playerId: string): Position[] | undefined {
    return this.playerMovementQueues.get(playerId);
  }

  /**
   * Clear movement queue for a player
   */
  public clearPlayerMovementQueue(playerId: string): void {
    this.playerMovementQueues.delete(playerId);
  }
}
</file>

<file path="packages/backend/src/services/gameStateManager.ts">
import { GameWorld, GAME_CONFIG, BiomeType, Player, NPC, LootResult, Building } from '@chatterealm/shared';
import { PlayerMovementService, MoveResult } from './PlayerMovementService';
import { CombatService, CombatResult } from './CombatService';
import { LootService } from './LootService';
import { ItemResult } from './LootManager';
import { GameWorldManager } from './GameWorldManager';
import { NPCManager } from './NPCManager';
import { EventEmitter } from 'events';

// --- Service Fallbacks (Null Object Pattern) ---

class NullPlayerMovementService extends PlayerMovementService {
  constructor() {
    // Pass a dummy GameWorld that is immediately discarded.
    super({
      id: 'null-world',
      grid: [],
      players: [],
      npcs: [],
      items: [],
      buildings: [],
      worldAge: 0,
      phase: 'exploration',
      cataclysmCircle: {
        center: { x: 0, y: 0 },
        radius: 0,
        isActive: false,
        shrinkRate: 0,
        nextShrinkTime: 0,
      },
      cataclysmRoughnessMultiplier: 0,
      lastResetTime: 0,
    });
  }
  movePlayer(playerId: string, newPosition: any, world?: GameWorld): MoveResult {
    return { success: false, message: 'PlayerMovementService unavailable' };
  }
}

class NullCombatService extends CombatService {
  processAttack(attacker: Player, defender: NPC, attackerPosition: { x: number, y: number }, defenderPosition: { x: number, y: number }): CombatResult {
    return { success: false, message: 'CombatService unavailable' };
  }
}

class NullLootService extends LootService {
  constructor() {
    super();
  }
  startLooting(playerId: string, buildingId: string, gameWorld: any): LootResult {
    return { success: false, message: 'LootService unavailable' };
  }
}


// --- Interfaces ---

interface GameServices {
  playerMovement: PlayerMovementService;
  combat: CombatService;
  loot: LootService;
}

interface GameStateManagerConfig {
  services?: Partial<GameServices>;
  options?: { generateNPCs?: boolean; worldType?: 'test' | 'default' };
}

interface GameStateManagerEvents {
  error: (error: Error) => void;
  warning: (warning: string) => void;
  stateChanged: (state: GameWorld) => void;
}

export class GameStateManager extends EventEmitter {
  private gameWorld: GameWorld | null = null;
  private gameWorldManager!: GameWorldManager;
  private npcManager!: NPCManager;
  private services!: GameServices;
  private isInitialized = false;
  private healthStatus = {
    worldManager: false,
    npcManager: false,
    playerMovement: false,
    combat: false,
    loot: false
  };

  private constructor(config: GameStateManagerConfig = {}) {
    super();
  }

  public static async create(config: GameStateManagerConfig = {}): Promise<GameStateManager> {
    const instance = new GameStateManager(config);
    await instance.initializeComponents(config);
    instance.isInitialized = true;
    return instance;
  }

  private async initializeComponents(config: GameStateManagerConfig): Promise<void> {
    try {
      this.npcManager = new NPCManager(new Set());
      this.healthStatus.npcManager = true;

      this.gameWorldManager = new GameWorldManager(this.npcManager);
      this.healthStatus.worldManager = true;

      this.gameWorld = await this.retryOperation(
        () => this.gameWorldManager.initializeGameWorld(config.options),
        'Game world initialization'
      );

      this.services = this.initializeServices(config.services);
    } catch (error) {
      console.error('Component initialization failed:', error);
      throw error;
    }
  }

  private initializeServices(serviceConfig?: Partial<GameServices>): GameServices {
    const services: Partial<GameServices> = {};

    try {
      services.playerMovement = serviceConfig?.playerMovement || new PlayerMovementService(this.getGameWorld());
      this.healthStatus.playerMovement = true;
    } catch (error) {
      console.error('PlayerMovementService initialization failed:', error);
      this.healthStatus.playerMovement = false;
      this.emit('warning', 'PlayerMovementService unavailable - using fallback');
      services.playerMovement = new NullPlayerMovementService();
    }

    try {
      services.combat = serviceConfig?.combat || new CombatService();
      this.healthStatus.combat = true;
    } catch (error) {
      console.error('CombatService initialization failed:', error);
      this.healthStatus.combat = false;
      this.emit('warning', 'CombatService unavailable - using fallback');
      services.combat = new NullCombatService();
    }

    try {
      services.loot = serviceConfig?.loot || new LootService();
      this.healthStatus.loot = true;
    } catch (error) {
      console.error('LootService initialization failed:', error);
      this.healthStatus.loot = false;
      this.emit('warning', 'LootService unavailable - using fallback');
      services.loot = new NullLootService();
    }

    return services as GameServices;
  }

  private async retryOperation<T>(
    operation: () => T,
    operationName: string,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<T> {
    let lastError: Error | undefined;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return operation();
      } catch (error) {
        lastError = error as Error;
        console.warn(`${operationName} failed (attempt ${attempt}/${maxRetries}):`, error);
        if (attempt < maxRetries) {
          const waitTime = delay * Math.pow(2, attempt - 1);
          await new Promise(resolve => setTimeout(resolve, waitTime));
        }
      }
    }
    throw new Error(`${operationName} failed after ${maxRetries} attempts: ${lastError!.message}`);
  }

  public update(): void {
    if (!this.isInitialized || !this.gameWorld) {
      console.warn('Attempted to update uninitialized GameStateManager');
      return;
    }
    try {
      this.safeUpdate(() => this.npcManager.updateNPCs(this.getGameWorld().npcs, this.getGameWorld().grid), 'NPC update');
      this.safeUpdate(() => this.gameWorldManager.updateWorldAge(this.getGameWorld()), 'World age update');
      this.safeUpdate(() => this.npcManager.cleanupDeadNPCs(this.getGameWorld().npcs), 'NPC cleanup');
      this.emit('stateChanged', this.gameWorld);
    } catch (error) {
      console.error('Critical error during game state update:', error);
      this.emit('error', error as Error);
    }
  }

  private safeUpdate(operation: () => void, operationName: string): void {
    try {
      operation();
    } catch (error: any) {
      console.error(`${operationName} failed:`, error);
      this.emit('warning', `${operationName} failed: ${error.message}`);
    }
  }

  public getHealthStatus() {
    return {
      ...this.healthStatus,
      initialized: this.isInitialized,
      worldAvailable: this.gameWorld !== null
    };
  }

  public getGameWorld(): GameWorld {
    if (!this.gameWorld) {
      throw new Error('Game world not initialized');
    }
    return this.gameWorld;
  }

  // --- Passthrough methods to existing services ---

  public getGameWorldManager(): GameWorldManager { return this.gameWorldManager; }
  public getNPCManager(): NPCManager { return this.npcManager; }

  public getBuildingAt(position: any): Building | undefined {
    return this.getGameWorld().buildings.find((b: Building) => b.position.x === position.x && b.position.y === position.y);
  }

  public getTerrainAt(position: any): any {
    const world = this.getGameWorld();
    if (position.x < 0 || position.x >= GAME_CONFIG.gridWidth || position.y < 0 || position.y >= GAME_CONFIG.gridHeight) {
      return undefined;
    }
    return world.grid[position.y][position.x];
  }

  public movePlayer(playerId: string, newPosition: any): MoveResult {
    return this.services.playerMovement.movePlayer(playerId, newPosition, this.getGameWorld());
  }

  public attackEnemy(playerId: string, enemyPosition: any): CombatResult {
    const world = this.getGameWorld();
    const attacker = world.players.find((p: Player) => p.id === playerId);
    const defender = world.npcs.find((n: NPC) => n.position.x === enemyPosition.x && n.position.y === enemyPosition.y);
    if (!attacker || !defender) {
      return { success: false, message: 'Attacker or defender not found' };
    }
    return this.services.combat.processAttack(attacker, defender, attacker.position, defender.position);
  }

  public startLooting(playerId: string, buildingId: string): LootResult {
    return this.services.loot.startLooting(playerId, buildingId, this.getGameWorld());
  }

  public addPlayer(player: any): { success: boolean; player?: any; message?: string } {
    const world = this.getGameWorld();
    const occupied = this.services.playerMovement.getOccupiedPositions();
    const available = this.services.playerMovement.getAvailableSpawnPoints();
    const ok = this.gameWorldManager.addPlayer(world, player, occupied, available);
    if (ok) {
      this.services.playerMovement.addPlayerPosition(player.position);
      return { success: true, player, message: 'Player added' };
    }
    return { success: false, message: 'Failed to add player' };
  }

  public isPositionValid(position: any): boolean {
    const world = this.getGameWorld();
    if (!world.grid) return false;
    if (!this.gameWorldManager.isWithinBounds(world, position)) return false;
    const terrain = this.gameWorldManager.getTerrainAt(world, position);
    if (!terrain) return false;
    return terrain.type !== BiomeType.MOUNTAIN;
  }

  public isPositionOccupied(position: any): boolean {
    return this.services.playerMovement.isPositionOccupied(position);
  }
}
</file>

<file path="packages/frontend/src/ai/GameEntity.ts">
// packages/frontend/src/ai/GameEntity.ts

import { Vector3 } from 'three';
import { Telegram } from './Telegram';

export class GameEntity {
  public name: string;
  public position: Vector3;
  public boundingRadius: number;
  private static nextId = 0;
  public id: number;

  constructor(name = 'GameEntity', position = new Vector3()) {
    this.id = GameEntity.nextId++;
    this.name = name;
    this.position = position;
    this.boundingRadius = 0;
  }

  update(delta: number): void {
    // To be implemented by subclasses
  }

  handleMessage(telegram: Telegram): boolean {
    // To be implemented by subclasses
    return false;
  }
}
</file>

<file path="packages/backend/src/index.ts">
import express from 'express';
import { createServer } from 'http';

// Graceful shutdown and error handling
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  // In production, you might want to exit gracefully
  if (process.env.NODE_ENV === 'production') {
    process.exit(1);
  }
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  // In production, you might want to exit gracefully
  if (process.env.NODE_ENV === 'production') {
    process.exit(1);
  }
});
import compression from 'compression';
import cors from 'cors';
import crypto from 'crypto';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { body, query, validationResult } from 'express-validator';
import { WebSocketServer } from './services/webSocketServer';
import { GameStateManager } from './services/gameStateManager';
import { EmojiService } from './services/EmojiService';
import { StreamOptimizedTwitchService } from './services/StreamOptimizedTwitchService';
import { StreamCommentaryService } from './services/StreamCommentaryService';
import { AutoWanderService } from './services/AutoWanderService';
import { LootService } from './services/LootService';
import { PlayerMovementService } from './services/PlayerMovementService';
import { CombatService } from './services/CombatService';
import { HandDrawnBuildingService } from './services/HandDrawnBuildingService';
import { GAME_CONFIG } from '@chatterealm/shared';
import { validateEnv } from './config/env';
import AIProxyService from './services/aiProxyService';

const app = express();
const env = validateEnv();
const httpServer = createServer(app);

let gameStateManager: GameStateManager;
const emojiService = new EmojiService();
let webSocketServer: WebSocketServer;
const handDrawnBuildingService = new HandDrawnBuildingService();
let twitchService: StreamOptimizedTwitchService | null = null;

// The remaining services are instantiated within GameStateManager or are not used.

// All services are now injected into GameStateManager via its constructor.

// Middleware
// Security headers
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "blob:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
  }
}));

// CORS Configuration
const allowedOriginsEnv = env.ALLOWED_ORIGINS;
const allowedOrigins = allowedOriginsEnv 
  ? allowedOriginsEnv.split(',').map(origin => origin.trim())
  : process.env.NODE_ENV === 'production'
    ? ['https://chatterrealm.com']
    : ['http://localhost:3000', 'http://localhost:5173'];

// Enhanced CORS with additional security
app.use(cors({
  origin: function (origin, callback) {
    // Allow requests with no origin (mobile apps, postman, etc.)
    if (!origin && process.env.NODE_ENV === 'development') {
      return callback(null, true);
    }

    if (!origin) {
      return callback(new Error('Origin header required'), false);
    }

    // Validate origin format
    try {
      const url = new URL(origin);
      if (allowedOrigins.includes(origin)) {
        callback(null, true);
      } else {
        console.warn(`Blocked unauthorized origin: ${origin}`);
        callback(new Error('Origin not allowed'), false);
      }
    } catch (error) {
      callback(new Error('Invalid origin format'), false);
    }
  },
  credentials: true,
  methods: ['GET', 'POST'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  maxAge: 86400,
  optionsSuccessStatus: 200
}));

app.use((req: any, res, next) => {
  req.id = crypto.randomUUID();
  res.setHeader('X-Request-ID', req.id);
  next();
});

app.use(compression({
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  },
  threshold: 1024
}));

// Enhanced async request logging with structured logging
app.use((req: any, res, next) => {
  const start = process.hrtime.bigint();
  req.id = req.id || crypto.randomUUID();

  const originalSend = res.send;
  res.send = function(data) {
    const duration = Number(process.hrtime.bigint() - start) / 1000000; // Convert to ms

    // Async logging to prevent blocking
    setImmediate(() => {
      const logData = {
        method: req.method,
        path: req.path,
        statusCode: res.statusCode,
        duration: `${duration.toFixed(2)}ms`,
        requestId: req.id,
        userAgent: req.get('User-Agent'),
        timestamp: new Date().toISOString()
      };

      if (duration > 1000) { // Log slow requests
        console.warn('Slow request detected:', logData);
      } else {
        console.log(JSON.stringify(logData));
      }
    });

    return originalSend.call(this, data);
  };

  next();
});

// Memory monitoring middleware
app.use((req, res, next) => {
  const memUsage = process.memoryUsage();
  const memUsedMB = memUsage.heapUsed / 1024 / 1024;

  if (memUsedMB > 500) { // Alert at 500MB
    console.warn(`High memory usage: ${memUsedMB.toFixed(2)}MB`);
  }

  res.setHeader('X-Memory-Usage', `${memUsedMB.toFixed(2)}MB`);
  next();
});
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Rate limiting with configurable values
const rateLimitWindowMs = env.RATE_LIMIT_WINDOW_MS;
const rateLimitMaxRequests = env.RATE_LIMIT_MAX_REQUESTS;

const apiLimiter = rateLimit({
  windowMs: rateLimitWindowMs,
  max: rateLimitMaxRequests,
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many requests from this IP, please try again later.',
});

app.use('/api/', apiLimiter);

// Health check endpoint
app.get('/', (req, res) => {
  const uptime = process.uptime();
  const memUsage = process.memoryUsage();

  res.json({
    status: 'ok',
    message: 'ChatterRealm Backend API',
    version: '1.0.0',
    uptime: `${Math.floor(uptime / 60)}m ${Math.floor(uptime % 60)}s`,
    memory: {
      used: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
      total: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`
    },
    world: {
      players: gameStateManager.getGameWorld().players.length,
      npcs: gameStateManager.getGameWorld().npcs.length,
      items: gameStateManager.getGameWorld().items.length,
      phase: gameStateManager.getGameWorld().phase
    },
    websocket: {
      connections: webSocketServer.getPlayerCount()
    }
  });
});

// API Routes
app.post('/api/ai-proxy', AIProxyService.validateRequest, (req, res) => {
  AIProxyService.handleRequest(req, res);
});

app.post('/api/game/command', (req, res) => {
  // TODO: Implement game command handler
  res.json({ success: true });
});

app.get('/api/world', (req, res) => {
  try {
    const world = gameStateManager.getGameWorld();
    if (!world) {
      return res.status(404).json({ error: 'Game world not initialized' });
    }
    res.json(world);
  } catch (error) {
    console.error('Error fetching world data:', error);
    res.status(500).json({ error: 'Failed to fetch world data' });
  }
});

app.get('/api/players', (req, res) => {
  try {
    const world = gameStateManager.getGameWorld();
    if (!world) {
      return res.status(404).json({ error: 'Game world not initialized' });
    }
    res.json(world.players || []);
  } catch (error) {
    console.error('Error fetching players:', error);
    res.status(500).json({ error: 'Failed to fetch players' });
  }
});

// Global error handling middleware
app.use((error: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Express error:', error);
  res.status(500).json({
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'
  });
});

// 404 handler for undefined routes
app.use((req, res) => {
  res.status(404).json({
    error: 'Not found',
    message: `Route ${req.method} ${req.path} not found`
  });
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Received SIGINT, shutting down gracefully...');
  if (twitchService) {
    twitchService.destroy();
  }
  webSocketServer.shutdown();
  httpServer.close(() => {
    console.log('âœ… HTTP server closed');
    process.exit(0);
  });
});

process.on('SIGTERM', () => {
  console.log('\nðŸ›‘ Received SIGTERM, shutting down gracefully...');
  if (twitchService) {
    twitchService.destroy();
  }
  webSocketServer.shutdown();
  httpServer.close(() => {
    console.log('âœ… HTTP server closed');
    process.exit(0);
  });
});

// Initialize and start the server
async function startServer() {
  try {
    gameStateManager = await GameStateManager.create();
    // Conditionally instantiate WebSocketServer based on test environment
    if (process.env.NODE_ENV !== 'test') {
      webSocketServer = new WebSocketServer(httpServer, gameStateManager);
    } else {
      webSocketServer = new WebSocketServer(httpServer);
    }

    const twitchClientId = env.TWITCH_CLIENT_ID;
    const twitchClientSecret = env.TWITCH_CLIENT_SECRET;
    const twitchChannelName = env.TWITCH_CHANNEL_NAME;

    if (twitchClientId && twitchClientSecret && twitchChannelName) {
      twitchService = new StreamOptimizedTwitchService(
        webSocketServer.getIO(),
        twitchClientId,
        twitchClientSecret,
        twitchChannelName,
        gameStateManager,
      );

      // Connect to Twitch
      twitchService.connect().catch(err => {
          console.error("Failed to connect to Twitch:", err);
      });
      console.log('ðŸ”Œ Twitch integration enabled.');
    } else {
      console.warn('âš ï¸ Twitch credentials not provided in environment variables (TWITCH_CLIENT_ID, TWITCH_CLIENT_SECRET, TWITCH_CHANNEL_NAME). Twitch integration is disabled.');
    }

    // Start the server only if this file is run directly
    if (require.main === module) {
      httpServer.listen(env.PORT, '0.0.0.0', () => {
        console.log(`ðŸš€ ChatterRealm Backend running on http://localhost:${env.PORT}`);
        console.log(`ðŸ“Š Game World: ${GAME_CONFIG.gridWidth}x${GAME_CONFIG.gridHeight} grid`);
        console.log(`ðŸ‘¥ Max Players: ${GAME_CONFIG.maxPlayers}`);
        console.log(`ðŸŽ® Enhanced WebSocket server with continuous game loop active`);
        console.log(`ðŸŒ Full game state management and cataclysm mechanics enabled`);
        console.log(`ðŸ”’ CORS enabled for: ${allowedOrigins.join(', ')}`);
        console.log(`â±ï¸  Rate limit: ${rateLimitMaxRequests} requests per ${rateLimitWindowMs / 60000} minutes`);
      });
    }
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
}

startServer();

// Enhanced emoji endpoint with comprehensive validation
const emojiValidation = [
  query('char')
    .isLength({ min: 1, max: 10 })
    .matches(/^[\p{Emoji_Presentation}\p{Emoji}\uFE0F]{1,4}$/u)
    .withMessage('Invalid emoji character'),
  query('roughness')
    .optional()
    .isFloat({ min: 0, max: 10 })
    .withMessage('Roughness must be between 0 and 10'),
  query('bowing')
    .optional()
    .isFloat({ min: 0, max: 10 })
    .withMessage('Bowing must be between 0 and 10'),
];

app.get('/api/emoji', emojiValidation, async (req: express.Request, res: express.Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      error: 'Validation failed',
      details: errors.array()
    });
  }

  try {
    const emoji = req.query.char as string;
    const wantRough = req.query.rough === 'true';

    const svg = await emojiService.resolveEmojiSvg(emoji);

    if (!wantRough) {
      res.type('image/svg+xml');
      res.set('Cache-Control', 'public, max-age=86400'); // 24 hours
      return res.send(svg);
    }

    const options = {
      roughness: req.query.roughness ? Number(req.query.roughness) : undefined,
      bowing: req.query.bowing ? Number(req.query.bowing) : undefined,
    };

    const roughSvg = await emojiService.convertToRoughSvg(svg, options, emoji);

    res.type('image/svg+xml');
    res.set('Cache-Control', 'public, max-age=3600'); // 1 hour for processed content
    res.send(roughSvg);

  } catch (error: any) {
    console.error(`Emoji processing error for ${req.query.char}:`, error);
    res.status(500).json({
      error: 'Processing failed',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Internal error'
    });
  }
});

// Export the app and server for testing purposes
export { app, httpServer };
</file>

<file path="packages/backend/src/models/GameRoom.ts">
import { GameWorld, Player as PlayerData, NPC, Item, PlayerProfile } from '@chatterealm/shared';
import { GameStateManager } from '../services/gameStateManager';
import { Player } from './Player';
import { PlayerService } from '../services/PlayerService';
import { CombatService } from '../services/CombatService';
import { LootService } from '../services/LootService';
import { PlayerMovementService } from '../services/PlayerMovementService';
import { GameWorldManager } from '../services/GameWorldManager';
import { NPCManager } from '../services/NPCManager';
import { CataclysmService } from '../services/CataclysmService';
import { LootManager } from '../services/LootManager';

// A simple deep-clone function for this use case.
// For a real-world app, a more robust library like lodash.cloneDeep would be better.
const clone = <T>(obj: T): T => JSON.parse(JSON.stringify(obj));

export interface GameStateDelta {
  type: 'players' | 'npcs' | 'items';
  data: any;
}

export class GameRoom {
  id: string;
  private players: Map<string, Player> = new Map();
  private gameStateManager: GameStateManager;
  private playerService: PlayerService;
  private combatService: CombatService;
  private lootService: LootService;
  private movementService: PlayerMovementService;
  private cataclysmService: CataclysmService;
  private lastGameState: GameWorld;

  private constructor(roomId: string) {
    this.id = roomId;
    // Properties will be initialized in the async `initialize` method
    this.players = new Map();
    this.gameStateManager = null!;
    this.playerService = null!;
    this.combatService = null!;
    this.lootService = null!;
    this.movementService = null!;
    this.cataclysmService = null!;
    this.lastGameState = null!;
  }

  public static async create(roomId: string): Promise<GameRoom> {
    const room = new GameRoom(roomId);
    await room.initialize();
    return room;
  }

  private async initialize(): Promise<void> {
    this.gameStateManager = await GameStateManager.create();
    const gameWorld = this.gameStateManager.getGameWorld();
    const npcManager = this.gameStateManager.getNPCManager();
    const gameWorldManager = this.gameStateManager.getGameWorldManager();
    this.playerService = new PlayerService(gameWorld, gameWorldManager, new Set(), new Set());
    this.combatService = new CombatService();
    this.cataclysmService = new CataclysmService(new LootManager(), npcManager, new Set());
    this.lootService = new LootService(this.cataclysmService);
    this.movementService = new PlayerMovementService(gameWorld);
    this.lastGameState = clone(gameWorld);
  }

  /**
   * The main update tick for this room.
   */
  public update(): void {
    this.gameStateManager.update();
  }

  /**
   * Cleans up the game state.
   */
  public cleanup(): void {
    const now = Date.now();
    const disconnectedPlayers = this.playerService.getPlayers().filter(p => !p.connected && (now - p.lastActive > 60000));
    for (const player of disconnectedPlayers) {
      this.removePlayer(player.id);
    }
  }

  /**
   * Adds a player to the game room and to the underlying game state.
   */
  public addPlayer(playerData: PlayerData): Player {
    const player = this.playerService.addPlayer(playerData);
    this.players.set(player.id, player);
    return player;
  }

  /**
   * Removes a player from the game room and the underlying game state.
   */
  public removePlayer(playerId: string): PlayerData | null {
    const player = this.players.get(playerId);
    if (player) {
      player.disconnect();
      this.players.delete(playerId);
    }
    return this.playerService.removePlayer(playerId);
  }

  public getPlayers(): PlayerData[] {
    return this.playerService.getPlayers();
  }

  public getPlayerProfile(playerId: string): PlayerProfile | null {
    return this.playerService.getPlayerProfile(playerId);
  }

  /**
   * Returns the current state of the game world from the state manager.
   */
  public getGameState(): GameWorld {
    return this.gameStateManager.getGameWorld();
  }

  public movePlayer(playerId: string, newPosition: { x: number; y: number }): any {
    return this.movementService.movePlayer(playerId, newPosition, this.gameStateManager.getGameWorld());
  }

  public attackEnemy(playerId: string, targetPosition: { x: number; y: number }): any {
    const player = this.playerService.getPlayer(playerId);
    if (!player) {
      return { success: false, message: 'Player not found.' };
    }
    const enemy = this.combatService.getEnemyAtPosition(this.gameStateManager.getGameWorld().npcs, targetPosition);
    if (!enemy) {
      return { success: false, message: 'No enemy found at target position.' };
    }
    return this.combatService.processAttack(player, enemy, player.position, targetPosition);
  }

  public pickupItem(playerId: string, itemId: string): any {
    const gameWorld = this.gameStateManager.getGameWorld();
    return this.lootService.pickupItem(playerId, itemId, gameWorld.items, gameWorld.players);
  }

  public useItem(playerId: string, itemId: string): any {
    const gameWorld = this.gameStateManager.getGameWorld();
    return this.lootService.useItem(playerId, itemId, gameWorld.players);
  }

  public lootItem(playerId: string, itemId: string): any {
    const gameWorld = this.gameStateManager.getGameWorld();
    return this.lootService.lootItem(playerId, itemId, gameWorld.items, gameWorld.players);
  }

  public inspectItem(playerId: string, itemId: string): any {
    const gameWorld = this.gameStateManager.getGameWorld();
    return this.lootService.inspectItem(playerId, itemId, gameWorld.items, gameWorld.players);
  }

  /**
   * Calculates the difference between the current and last game state.
   */
  public getGameStateDelta(): GameStateDelta[] {
    const currentState = this.gameStateManager.getGameWorld();
    const deltas: GameStateDelta[] = [];

    const changedPlayers = this.findChangedEntities(this.lastGameState.players, currentState.players);
    if (changedPlayers.length > 0) {
      deltas.push({ type: 'players', data: changedPlayers });
    }

    const changedNpcs = this.findChangedEntities(this.lastGameState.npcs, currentState.npcs);
    if (changedNpcs.length > 0) {
      deltas.push({ type: 'npcs', data: changedNpcs });
    }

    const changedItems = this.findChangedEntities(this.lastGameState.items, currentState.items);
    if (changedItems.length > 0) {
      deltas.push({ type: 'items', data: changedItems });
    }

    // After calculating the delta, update the last known state.
    this.lastGameState = clone(currentState);

    return deltas;
  }

  private getComparableState(entity: any): any {
    const { lastMoveTime, lastActive, ...comparableState } = entity;
    return comparableState;
  }

  private findChangedEntities<T extends { id: string }>(oldEntities: T[], newEntities: T[]): T[] {
    const oldEntityMap = new Map(oldEntities.map(e => [e.id, e]));
    const newEntityMap = new Map(newEntities.map(e => [e.id, e]));
    const changed: T[] = [];

    // Check for new or changed entities
    for (const [id, newEntity] of newEntityMap.entries()) {
      const oldEntity = oldEntityMap.get(id);
      if (!oldEntity) {
        changed.push(newEntity); // It's a new entity
      } else {
        // Compare without volatile properties
        const oldComparable = this.getComparableState(oldEntity);
        const newComparable = this.getComparableState(newEntity);
        if (JSON.stringify(oldComparable) !== JSON.stringify(newComparable)) {
          changed.push(newEntity);
        }
      }
    }
    return changed;
  }
}
</file>

<file path="packages/backend/src/services/webSocketServer.ts">
import { Server as SocketIOServer, Socket } from 'socket.io';
import { Server as HTTPServer } from 'http';
import { GameActionResult } from './CataclysmService';
import { MoveResult } from './PlayerMovementService';
import { CombatResult } from './CombatService';
import { ItemResult } from './LootManager';
import { Player as PlayerData, GameWorld, PlayerClass, JoinGameData, SocketEvents } from '@chatterealm/shared';
import { CharacterHandler } from '../handlers/CharacterHandler';
import { RateLimiter } from './RateLimiter';

export interface ClientData {
  playerId: string;
  socketId: string;
  connectedAt: number;
}

export interface PlayerCommand {
  type: 'move' | 'move_to' | 'attack' | 'pickup' | 'use_item' | 'start_cataclysm' | 'loot_item' | 'inspect_item';
  playerId: string;
  data?: any;
}

// The QueuedCommand interface is no longer needed with the simplified authentication logic.

import { gameService } from './GameService';
import { GameStateManager } from './gameStateManager';
import { Player } from '../models/Player';

// Central socket room name used across this module
const SOCKET_MAIN_ROOM = 'main_room';

export class WebSocketServer {
  private io: SocketIOServer;
  private characterHandler: CharacterHandler;
  private connectedClients: Map<string, ClientData> = new Map();
  private playerSockets: Map<string, string> = new Map(); // playerId -> socketId
  private authenticationLocks: Set<string> = new Set();
  private gameLoopInterval: NodeJS.Timeout | null = null;
  private isGameLoopRunning: boolean = false;
  private cleanupInterval: NodeJS.Timeout | null = null; // Add cleanup interval for stale entries
  private rateLimiter: RateLimiter;
  private currentInterval: number = 1000; // Add this line
  private gameLoopStats = {
    totalUpdates: 0,
    lastUpdateTime: 0,
    averageUpdateTime: 0,
    errorCount: 0
  };
  private gameStateManager: GameStateManager | undefined;
  private commandHandlers: { [key: string]: (room: any, playerId: string, data: any) => any };

  constructor(httpServer: HTTPServer, gameStateManager?: GameStateManager) {
    this.gameStateManager = gameStateManager;
    this.commandHandlers = {
      move: (room, playerId, data) => room.movePlayer(playerId, data.position),
      attack: (room, playerId, data) => room.attackEnemy(playerId, data.targetPosition),
      pickup: (room, playerId, data) => room.pickupItem(playerId, data.itemId),
      loot_item: (room, playerId, data) => room.lootItem(playerId, data.itemId),
      inspect_item: (room, playerId, data) => room.inspectItem(playerId, data.itemId),
    };
    // Initialize Socket.IO server with CORS configuration
    this.io = new SocketIOServer(httpServer, {
      cors: {
        origin: (origin, callback) => {
          const allowedOrigins = process.env.NODE_ENV === 'production'
            ? ['https://chatterrealm.com', 'https://www.chatterrealm.com']
            : ['http://localhost:3000', 'http://localhost:5173', 'http://127.0.0.1:3000', 'http://127.0.0.1:5173'];

          if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
          } else {
            callback(new Error('Not allowed by CORS'));
          }
        },
        methods: ["GET", "POST"],
        credentials: true
      },
      pingTimeout: 60000,
      pingInterval: 25000
    });

    this.characterHandler = new CharacterHandler(this.io);
    this.rateLimiter = new RateLimiter({ maxEvents: 20, windowMs: 1000 });
    this.setupEventHandlers();
    this.startGameLoop();
    this.startCleanupInterval(); // Start periodic stale client cleanup
  }

  public getIO(): SocketIOServer {
    return this.io;
  }

  private setupEventHandlers(): void {
    this.io.on('connection', (socket: Socket) => {
      console.log(`[CONNECTION] Client connected: ${socket.id}`);
      console.log(`[CONNECTION] Current connectedClients count: ${this.connectedClients.size}`);
      console.log(`[CONNECTION] Current playerSockets count: ${this.playerSockets.size}`);
      console.log(`[CONNECTION] ConnectedClients keys: [${Array.from(this.connectedClients.keys()).join(', ')}]`);

      // Handle player join
      socket.on(SocketEvents.JOIN_GAME, (playerData: JoinGameData) => {
        console.log(`[JOIN_GAME_RECEIVED] Socket ${socket.id} attempting to join with data:`, playerData);
        this.handlePlayerJoin(socket, playerData);
      });

      // Handle character creation
      socket.on('create_character', (data: any) => {
        this.characterHandler.handleCreateCharacter(socket, data);
      });

      // Handle explicit leave requests from clients
      socket.on('leave_game', (data: { playerId?: string } | undefined) => {
        try {
          const pid = data?.playerId || this.connectedClients.get(socket.id)?.playerId;
          if (!pid) {
            console.warn(`[LEAVE_GAME] No playerId provided and no mapping found for socket ${socket.id}`);
            return;
          }

          console.log(`[LEAVE_GAME] Received leave request for player ${pid} from socket ${socket.id}`);
          const roomId = 'main_room';
          const room = gameService.getRoom(roomId);
          if(room) {
            room.removePlayer(pid);
          }

          this.io.to(roomId).emit('player_left', { playerId: pid });


          // Clean up client tracking maps
          this.connectedClients.delete(socket.id);
          if (this.playerSockets.get(pid) === socket.id) this.playerSockets.delete(pid);
        } catch (err) {
          console.error('[LEAVE_GAME] Error handling leave_game:', err);
        }
      });

      // Handle player commands
      socket.on(SocketEvents.PLAYER_COMMAND, (command: PlayerCommand) => {
        console.log(`[COMMAND_RECEIVED] Socket ${socket.id} sent command:`, command.type);
        console.log(`[COMMAND_RECEIVED] Socket in connectedClients: ${this.connectedClients.has(socket.id)}`);
        this.handlePlayerCommand(socket, command);
      });

      // Tarkov-style looting commands
      socket.on('inspect_item', (itemId: string) => {
        const clientData = this.connectedClients.get(socket.id);
        if (clientData) {
          this.handlePlayerCommand(socket, {
            type: 'inspect_item',
            playerId: clientData.playerId,
            data: { itemId },
          });
        }
      });

      socket.on('loot_item', (itemId: string) => {
        const clientData = this.connectedClients.get(socket.id);
        if (clientData) {
          this.handlePlayerCommand(socket, {
            type: 'loot_item',
            playerId: clientData.playerId,
            data: { itemId },
          });
        }
      });

      // Handle client disconnect
      socket.on('disconnect', () => {
        this.handlePlayerDisconnect(socket);
      });

      // Handle connection errors
      socket.on('error', (error) => {
        console.error(`Socket error for ${socket.id}:`, error);
        this.handlePlayerDisconnect(socket);
      });

      socket.on('get_player_profile', (playerId: string) => {
        const room = gameService.getRoom('main_room');
        if (room) {
          const profile = room.getPlayerProfile(playerId);
          socket.emit('player_profile', profile);
        }
      });
    });
  }

  private async handlePlayerJoin(socket: Socket, playerData: JoinGameData): Promise<void> {
    const lockKey = `join_${playerData.id}`;

    if (this.authenticationLocks.has(lockKey)) {
      socket.emit('error', { message: 'Join already in progress' });
      return;
    }

    // Set lock with automatic cleanup
    this.authenticationLocks.add(lockKey);
    const cleanupTimeout = setTimeout(() => {
      this.authenticationLocks.delete(lockKey);
      console.warn(`[AUTH] Cleaned up stale lock for player: ${playerData.id}`);
    }, 30000); // 30-second timeout

    try {
      // Add atomic check-and-set operation
      const existingSocket = this.playerSockets.get(playerData.id);
      if (existingSocket && this.io.sockets.sockets.has(existingSocket)) {
        throw new Error('Player already connected');
      }

      console.log(`[JOIN_START] Processing join for socket ${socket.id} with player data:`, playerData);
      console.log(`[JOIN_START] ConnectedClients before join: ${this.connectedClients.size}`);

      // Set authentication state to prevent race conditions
      socket.data.isAuthenticating = true;
      socket.data.commandQueue = [];

      // Create player object with all required properties
      const player = new Player(playerData);

      const room = await gameService.joinRoom(SOCKET_MAIN_ROOM, player.getData());

      if (!room) {
        console.error(`[SPAWN_ERROR] Failed to add player ${player.name} to room ${SOCKET_MAIN_ROOM}`);
        socket.emit('error', { message: 'Failed to join room' });
        return;
      }

      console.log(`[JOIN_REGISTERING] About to register socket ${socket.id} in connectedClients`);

      // Use authoritative player instance created by the room
      const addedPlayer = room.getPlayers().find(p => p.id === playerData.id);
      if (!addedPlayer) {
        console.error(`[SPAWN_ERROR] Player added but authoritative instance not found for id ${playerData.id}`);
        socket.emit('error', { message: 'Failed to join room (internal)' });
        return;
      }

      // Track client connection using authoritative player id
      const clientData: ClientData = {
        playerId: addedPlayer.id,
        socketId: socket.id,
        connectedAt: Date.now()
      };

      this.connectedClients.set(socket.id, clientData);
      this.playerSockets.set(addedPlayer.id, socket.id);

      console.log(`[JOIN_REGISTERED] Socket ${socket.id} registered in connectedClients`);
      console.log(`[JOIN_REGISTERED] ConnectedClients after join: ${this.connectedClients.size}`);
      console.log(`[JOIN_REGISTERED] ConnectedClients keys: [${Array.from(this.connectedClients.keys()).join(', ')}]`);

      socket.data.isAuthenticated = true;
      delete socket.data.isAuthenticating;

      // Process any queued commands
      if (socket.data.commandQueue && socket.data.commandQueue.length > 0) {
        socket.data.commandQueue.forEach((queuedCommand: PlayerCommand) => {
          this.handlePlayerCommand(socket, queuedCommand);
        });
        socket.data.commandQueue = [];
      }

      // Join player to their personal room for targeted updates
      socket.join(`player_${addedPlayer.id}`);

      // Send success response with initial game state using authoritative player
      socket.emit(SocketEvents.GAME_JOINED, {
        player: addedPlayer,
        gameWorld: room.getGameState(),
      });

      // Broadcast player joined to all other clients in the main room
      socket.to(SOCKET_MAIN_ROOM).emit(SocketEvents.PLAYER_JOINED, {
        player: addedPlayer
      });

      // Join the main game room
      socket.join(SOCKET_MAIN_ROOM);

      socket.emit('join_acknowledged', { status: 'success' });

      console.log(`[JOIN_SUCCESS] Player ${player.name} fully joined the game`);
      clearTimeout(cleanupTimeout); // Cancel cleanup on success
    } catch (error) {
      console.error('Player join failed:', error);
      socket.emit('join_failed', {
        message: error instanceof Error ? error.message : 'Join failed'
      });
    } finally {
      this.authenticationLocks.delete(lockKey);
      clearTimeout(cleanupTimeout);
    }
  }

  private handlePlayerCommand(socket: Socket, command: PlayerCommand): void {
    if (this.rateLimiter.isRateLimited(socket.id)) {
      socket.emit('rate_limit', { message: 'Too many commands. Please slow down.' });
      return;
    }
    if (socket.data.isAuthenticated) {
      // Proceed to process the command
    } else if (socket.data.isAuthenticating) {
      if (!socket.data.commandQueue) socket.data.commandQueue = [];
      socket.data.commandQueue.push(command);
      return;
    } else {
      socket.emit('error', { message: 'Not authenticated' });
      return;
    }

    try {
      const clientData = this.connectedClients.get(socket.id);
      if (!clientData) {
        console.error(`[AUTH_ERROR] Not authenticated - socket ${socket.id} not found in connectedClients`);
        console.error(`[AUTH_ERROR] Connected clients: ${Array.from(this.connectedClients.keys()).join(', ')}`);
        console.error(`[AUTH_ERROR] Player sockets: ${Array.from(this.playerSockets.entries()).map(([pid, sid]) => `${pid}:${sid}`).join(', ')}`);
        // If connectedClients is missing the current socket, it's a critical authentication failure.
        // Aggressively clean up potential orphaned playerSockets mapping to prevent future errors for this state.
        let cleanedOrphanedPlayerSockets = false;
        for (const [playerId, storedSocketId] of this.playerSockets.entries()) {
          if (storedSocketId === socket.id) {
            console.warn(`[AUTH_CLEANUP] Found and removing orphaned playerSockets entry for playerId: ${playerId}, socketId: ${socket.id}.`);
            this.playerSockets.delete(playerId);
            cleanedOrphanedPlayerSockets = true;
          }
        }

        if (cleanedOrphanedPlayerSockets) {
            console.log(`[AUTH_CLEANUP_SUCCESS] Inconsistent playerSockets entry(ies) found and cleaned up for socket ${socket.id}.`);
        } else {
            console.warn(`[AUTH_CLEANUP_NONE] No orphaned playerSockets entries found for socket ${socket.id}, but clientData was missing.`);
        }

        socket.emit('error', { message: 'Not authenticated' });
        return;
      }

      const room = gameService.getRoom('main_room');
      if (!room) {
        socket.emit('error', { message: 'Game room not found.' });
        return;
      }

      const { playerId, type, data } = command;
      const handler = this.commandHandlers[type];

      if (handler) {
        const result = handler(room, playerId, data);
        if (result && !result.success) {
          socket.emit('action_failed', { message: result.message });
        }
      } else {
        socket.emit('error', { message: `Unknown command type: ${type}` });
      }

    } catch (error) {
      console.error('Error handling player command:', error);
      socket.emit('error', { message: 'Command execution failed' });
    }
  }


  private handlePlayerDisconnect(socket: Socket): void {
    this.rateLimiter.cleanup(socket.id);
    try {
      const clientData = this.connectedClients.get(socket.id);
      if (clientData) {
        const roomId = 'main_room';
        const room = gameService.getRoom(roomId);
        if (room) {
            const player = room.removePlayer(clientData.playerId);
            if (player) {
              // Broadcast player disconnected to all clients in the room
              this.io.to(roomId).emit(SocketEvents.PLAYER_DISCONNECTED, {
                playerId: clientData.playerId,
                player: player,
              });
            }
        }

        // Ensure explicit cleanup of mappings from connectedClients and playerSockets
        this.connectedClients.delete(socket.id);
        // Only delete from playerSockets if it still points to the disconnecting socket
        if (this.playerSockets.get(clientData.playerId) === socket.id) {
          this.playerSockets.delete(clientData.playerId);
        }

        // Ensure any authentication locks are cleared for this player
        this.authenticationLocks.delete(clientData.playerId);

        console.log(`Client disconnected: ${socket.id}`);
      }
    } catch (error) {
      console.error('Error handling player disconnect:', error);
    }
  }

  // Broadcast only deltas (state changes)
  public broadcastGameDeltas(): void {
    try {
      const room = gameService.getRoom('main_room');
      if (room) {
        const deltas = room.getGameStateDelta();
        // Only broadcast if there are actual changes
        if (Array.isArray(deltas) && deltas.length > 0) {
          this.io.to(SOCKET_MAIN_ROOM).emit('game_state_delta', deltas);
        }
      }
    } catch (error) {
      console.error('Error broadcasting game deltas:', error);
    }
  }

  private startGameLoop(): void {
    console.log('ðŸŽ® Starting game loop...');
    this.isGameLoopRunning = true;
    this.gameLoopInterval = setInterval(() => this.executeGameLoop(), this.currentInterval);
    console.log(`âœ… Game loop started successfully with interval: ${this.currentInterval}ms`);
  }

  private adjustGameLoopInterval(newInterval: number): void {
    if (this.currentInterval !== newInterval) {
      console.log(`ðŸ”„ Adjusting game loop interval: ${this.currentInterval}ms â†’ ${newInterval}ms`);
      this.currentInterval = newInterval;
      this.restartGameLoop();
    }
  }

  private restartGameLoop(): void {
    if (this.gameLoopInterval) {
      clearInterval(this.gameLoopInterval);
    }

    this.gameLoopInterval = setInterval(() => {
      this.executeGameLoop();
    }, this.currentInterval);
  }

  private executeGameLoop(): void {
    const startTime = Date.now();

    try {
      const playerCount = this.getPlayerCount();

      // ðŸ”¥ KEY FIX: Dynamic interval adjustment
      if (playerCount === 0) {
        this.adjustGameLoopInterval(10000); // 10 seconds when empty
        this.cleanupGameState();
        const updateTime = Date.now() - startTime;
        this.updateGameLoopStats(updateTime);
        return;
      } else if (playerCount < 10) {
        this.adjustGameLoopInterval(2000); // 2 seconds for small groups
      } else {
        this.adjustGameLoopInterval(1000); // 1 second for active games
      }

      const room = gameService.getRoom('main_room');
      if (room) {
        room.update();
      }

      this.broadcastGameDeltas();

      const updateTime = Date.now() - startTime;
      this.updateGameLoopStats(updateTime);

      // Performance monitoring
      if (this.gameLoopStats.totalUpdates % 60 === 0) {
        this.logGameLoopStats();

        // Proactive memory cleanup
        this.performMemoryCleanup();
      }
    } catch (error) {
      this.handleGameLoopError(error as Error);
    }
  }

  private performMemoryCleanup(): void {
    // Force garbage collection in development
    if (process.env.NODE_ENV === 'development' && global.gc) {
      global.gc();
    }

    // Clean up stale game state
    const room = gameService.getRoom('main_room');
    if (room && typeof room.cleanup === 'function') {
      room.cleanup();
    }
  }

  private handleGameLoopError(error: Error): void {
    this.gameLoopStats.errorCount++;
    console.error('âŒ Error in game loop execution:', error);

    // Exponential backoff for error recovery
    const errorBackoff = Math.min(this.gameLoopStats.errorCount * 1000, 10000);
    this.adjustGameLoopInterval(this.currentInterval + errorBackoff);
  }

  private cleanupGameState(): void {
    // Add game state cleanup logic here
    const room = gameService.getRoom('main_room');
    if (room) {
      room.cleanup(); // Implement this method in GameService
    }
  }

  private updateGameLoopStats(updateTime: number): void {
    this.gameLoopStats.totalUpdates++;
    this.gameLoopStats.lastUpdateTime = Date.now();

    // Calculate rolling average update time
    const alpha = 0.1; // Smoothing factor
    this.gameLoopStats.averageUpdateTime =
      this.gameLoopStats.averageUpdateTime * (1 - alpha) + updateTime * alpha;
  }

  private logGameLoopStats(): void {
    console.log('ðŸ“Š Game Loop Performance Stats:', {
      totalUpdates: this.gameLoopStats.totalUpdates,
      averageUpdateTime: `${this.gameLoopStats.averageUpdateTime.toFixed(2)}ms`,
      errorCount: this.gameLoopStats.errorCount,
      activePlayers: this.getPlayerCount(),
      lastUpdate: new Date(this.gameLoopStats.lastUpdateTime).toISOString()
    });
  }

  private stopGameLoop(): void {
    if (this.gameLoopInterval) {
      clearInterval(this.gameLoopInterval);
      this.gameLoopInterval = null;
      this.isGameLoopRunning = false;
    }
  }

  // Periodic cleanup of stale ClientData entries to prevent memory leaks
  private startCleanupInterval(): void {
    if (this.cleanupInterval) return; // already started
    console.log('ðŸ§¹ Starting stale client cleanup interval...');

    // Run cleanup every 30 seconds
    this.cleanupInterval = setInterval(() => {
      this.cleanupStaleClientData();
    }, 30000);

    console.log('âœ… Stale client cleanup started successfully');
  }

  private stopCleanupInterval(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }

  private cleanupStaleClientData(): void {
    const staleSockets = new Set<string>();

    // First pass: identify stale sockets
    this.connectedClients.forEach((clientData, socketId) => {
      if (!this.io.sockets.sockets.has(socketId)) {
        staleSockets.add(socketId);
      }
    });

    // Second pass: batch cleanup
    if (staleSockets.size > 0) {
      staleSockets.forEach(socketId => {
        const clientData = this.connectedClients.get(socketId);
        if (clientData) {
          this.connectedClients.delete(socketId);
          // Use atomic operation to prevent race conditions
          if (this.playerSockets.get(clientData.playerId) === socketId) {
            this.playerSockets.delete(clientData.playerId);
          }
        }
      });

      console.log(`[CLEANUP] Removed ${staleSockets.size} stale connections`);
    }
  }

  // Periodic cleanup of stale ClientData entries to prevent memory leaks

  // Public methods for external access
  public getConnectedClients(): ClientData[] {
    return Array.from(this.connectedClients.values());
  }

  public getPlayerCount(): number {
    return this.connectedClients.size;
  }

  public getGameLoopStats() {
    return this.gameLoopStats;
  }

  public validateEnvironment() {
    if (!process.env.NODE_ENV) {
      throw new Error('NODE_ENV is not defined.');
    }
  }

  public isPlayerOnline(playerId: string): boolean {
    return this.playerSockets.has(playerId);
  }

  public sendToPlayer(playerId: string, event: string, data: any): void {
    const socketId = this.playerSockets.get(playerId);
    if (socketId) {
      this.io.to(socketId).emit(event, data);
    }
  }

  public broadcast(event: string, data: any): void {
    this.io.to(SOCKET_MAIN_ROOM).emit(event, data);
  }

  // Graceful shutdown
  public shutdown(): void {
    console.log('Shutting down WebSocket server...');

    // Stop the game loop first
    this.stopGameLoop();

    // Stop cleanup interval
    this.stopCleanupInterval();

    // Disconnect all clients
    this.io.disconnectSockets();

    // Clear tracking maps
    this.connectedClients.clear();
    this.playerSockets.clear();

    console.log('âœ… WebSocket server shutdown complete');
  }
}
</file>

</files>
